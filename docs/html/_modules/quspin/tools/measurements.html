
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>quspin.tools.measurements &#8212; QuSpin 0.2.5 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.2.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">QuSpin 0.2.5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for quspin.tools.measurements</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="c1"># need linear algebra packages</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span> <span class="k">as</span> <span class="nn">_sla</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">_la</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">_npla</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">_sp</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">binom</span><span class="p">,</span> <span class="n">hyp2f1</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">isgenerator</span> <span class="k">as</span> <span class="n">_isgenerator</span> 

<span class="c1"># needed for isinstance only</span>
<span class="kn">from</span> <span class="nn">..operators</span> <span class="k">import</span> <span class="n">ishamiltonian</span> <span class="k">as</span> <span class="n">_ishamiltonian</span>
<span class="kn">from</span> <span class="nn">..operators</span> <span class="k">import</span> <span class="n">hamiltonian</span> <span class="k">as</span> <span class="n">_hamiltonian</span>
<span class="kn">from</span> <span class="nn">..basis</span> <span class="k">import</span> <span class="n">spin_basis_1d</span><span class="p">,</span><span class="n">photon_basis</span><span class="p">,</span><span class="n">isbasis</span>
<span class="kn">from</span> <span class="nn">..basis.photon</span> <span class="k">import</span> <span class="n">photon_Hspace_dim</span>

<span class="kn">import</span> <span class="nn">warnings</span>


<span class="n">__all__</span> <span class="o">=</span>  <span class="p">[</span><span class="s2">&quot;ent_entropy&quot;</span><span class="p">,</span> 
			<span class="s2">&quot;diag_ensemble&quot;</span><span class="p">,</span>
			<span class="s2">&quot;ED_state_vs_time&quot;</span><span class="p">,</span>
			<span class="s2">&quot;obs_vs_time&quot;</span><span class="p">,</span>
			<span class="s2">&quot;project_op&quot;</span><span class="p">,</span>
			<span class="s2">&quot;KL_div&quot;</span><span class="p">,</span>
			<span class="s2">&quot;mean_level_spacing&quot;</span><span class="p">,</span>
			<span class="s2">&quot;evolve&quot;</span><span class="p">]</span>



<div class="viewcode-block" id="ent_entropy"><a class="viewcode-back" href="../../../generated/quspin.tools.measurements.ent_entropy.html#quspin.tools.measurements.ent_entropy">[docs]</a><span class="k">def</span> <span class="nf">ent_entropy</span><span class="p">(</span><span class="n">system_state</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">chain_subsys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">DM</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">svd_return_vec</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span><span class="kc">False</span><span class="p">,</span><span class="kc">False</span><span class="p">],</span><span class="o">**</span><span class="n">_basis_kwargs</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Calculates entanglement entropy of a subsystem using Singular Value Decomposition (svd).</span>

<span class="sd">	**Note: We recommend the use of the** `basis.ent_entropy()` **method instead of this function.</span>
<span class="sd">	This function is a wrapper.**</span>


<span class="sd">	The entanglement entropy is NORMALISED by the size of the reduced subsystem. </span>

<span class="sd">	Consider a quantum chain of :math:`N` sites in the state defined by the density matrix :math:`\\rho`.</span>
<span class="sd">	Define a subsystem :math:`A` of :math:`N_A` sites and its complement :math:`A^c` containing :math:`N=N_A + N_{A^c}`</span>
<span class="sd">	sites. Given the reduced density matrices </span>
<span class="sd">	</span>
<span class="sd">	.. math::</span>
<span class="sd">		\\rho_A = \\mathrm{tr}_B \\rho, \\qquad \\rho_{A^c} = \\mathrm{tr}_{A^c} \\rho </span>

<span class="sd">	the entanglement entropy densities of subsystems :math:`A` and :math:`B` (normalised w.r.t. their size, respectively) read </span>

<span class="sd">	.. math::</span>
<span class="sd">		S_\\mathrm{ent}^A = -\\frac{1}{N_A}\\mathrm{tr}_A \\rho_A\\log\\rho_A,\\qquad S_\\mathrm{ent}^B = -\\frac{1}{N_A}\\mathrm{tr}_{A^c} \\rho_{A^c}\\log\\rho_{A^c}</span>

<span class="sd">	For :math:`\\rho` pure, we have :math:`S_\\mathrm{ent}^A = S_\\mathrm{ent}^B`.</span>

<span class="sd">	Examples</span>
<span class="sd">	--------</span>

<span class="sd">	The example below shows how to compute the entanglement entropy of a pure state. The state is chosen as one of</span>
<span class="sd">	the eigenstates of the spin-1/2 Hamiltonian :math:`H=\\sum_j hS^x_j + g S^z_j`.</span>

<span class="sd">	.. literalinclude:: ../../doc_examples/ent_entropy-example.py</span>
<span class="sd">		:linenos:</span>
<span class="sd">		:language: python</span>
<span class="sd">		:lines: 7-</span>



<span class="sd">	Parameters</span>
<span class="sd">	-----------</span>
<span class="sd">	system_state : {array_like,dict}</span>
<span class="sd">		State of the quantum system; can be either of:</span>

<span class="sd">			* numpy.ndarray: pure state, shape = (Ns,).</span>
<span class="sd">			* numpy.ndarray: density matrix (DM), shape=(Ns,Ns).</span>
<span class="sd">			* dict: diagonal DM as dictionary of the form {&#39;V_rho&#39;: V_rho, &#39;rho_d&#39;: rho_d}, where </span>

<span class="sd">				-- numpy.ndarray: `rho_d` is a diagonal DM, shape = (Ns,).</span>

<span class="sd">				-- numpy.ndarray: `V_rho` contains eigenbasis of the DM in the columns, shape = (Ns,Ns).</span>

<span class="sd">				The dict keys CANNOT be chosen arbitrarily.</span>
<span class="sd">			* dict: collection of pure states as dict of the form {&#39;V_states&#39;: V_states}, contained</span>
<span class="sd">				in the columns of V_states, shape = (Ns,Nvecs). </span>

<span class="sd">				Use this input to PARALLELISE the calculation of the entanglement entropy.</span>
<span class="sd">	basis : :obj:`basis`</span>
<span class="sd">		Basis used to construct `system_state` in. Must be instance of either one of QuSpin&#39;s `basis` classes. </span>
<span class="sd">	chain_subsys : list, optional </span>
<span class="sd">		Lattice sites to specify the chain subsystem of interest. Default is:</span>

<span class="sd">		* [0,1,...,N/2-1,N/2] for `spin_basis_1d`, `fermion_basis_1d`, `boson_basis_1d`.</span>
<span class="sd">		* [0,1,...,N-1,N] for `photon_basis`.</span>
<span class="sd">	DM : str, optional </span>
<span class="sd">		Flag to enable the calculation of the reduced density matrix. Available string expressions are:</span>

<span class="sd">		* &quot;chain_subsys&quot;: calculates the reduced DM of the subsystem &#39;chain_subsys&#39; and</span>
<span class="sd">			returns it under the key &quot;DM_chain_subsys&quot;.</span>
<span class="sd">		* &quot;other_subsys&quot;: calculates the reduced DM of the complement of &#39;chain_subsys&#39; and</span>
<span class="sd">			returns it under the key &quot;DM_other_subsys&quot;.</span>
<span class="sd">		* &quot;both&quot;: calculates and returns both density matrices as defined above.</span>

<span class="sd">		Default is &quot;False&quot;. 	</span>
<span class="sd">	alpha : float, optional </span>
<span class="sd">		Renyi :math:`\\alpha` parameter. Default is &#39;1.0&#39;. </span>

<span class="sd">		When `alpha` is different from unity, the output keys have attached &quot;_Renyi&quot; to their label.</span>
<span class="sd">	svd_return_vec : list(bool), optional</span>
<span class="sd">		Three booleans to determine which Singular Value Decomposition (svd) quantities are returned:</span>

<span class="sd">		* `[ . ,True, . ]` svd singular values.</span>
<span class="sd">		* `[ . , . ,True]` and `[True, . , . ]` are depricated.</span>

<span class="sd">		Default is `[False,False,False]`.</span>

<span class="sd">	Returns</span>
<span class="sd">	--------</span>
<span class="sd">	dict</span>
<span class="sd">		The following keys of the output dict are available, depending on the choice of flags:</span>

<span class="sd">		* &quot;Sent&quot;: entanglement entropy.</span>
<span class="sd">		* &quot;DM_chain_subsys&quot;: (optional) reduced density matrix of chain subsystem.</span>
<span class="sd">		* &quot;DM_other_subsys&quot;: (optional) reduced density matrix of the complement subsystem.</span>
<span class="sd">		* &quot;lmbda&quot;: (optional) svd singular values.</span>

<span class="sd">	&quot;&quot;&quot;</span>

	<span class="c1"># initiate variables</span>
	<span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Sent&quot;</span><span class="p">]</span>
	<span class="n">translate_dict</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Sent&quot;</span><span class="p">:</span><span class="s2">&quot;Sent_A&quot;</span><span class="p">}</span>

	<span class="k">if</span> <span class="n">DM</span> <span class="o">==</span> <span class="s1">&#39;chain_subsys&#39;</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_chain_subsys&quot;</span><span class="p">)</span>
		<span class="n">_basis_kwargs</span><span class="p">[</span><span class="s2">&quot;return_rdm&quot;</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;A&quot;</span>
		

	<span class="k">elif</span> <span class="n">DM</span> <span class="o">==</span><span class="s1">&#39;other_subsys&#39;</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_other_subsys&quot;</span><span class="p">)</span>
		<span class="n">_basis_kwargs</span><span class="p">[</span><span class="s2">&quot;return_rdm&quot;</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;B&quot;</span>
		<span class="n">translate_dict</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Sent&quot;</span><span class="p">:</span><span class="s2">&quot;Sent_B&quot;</span><span class="p">}</span>

	<span class="k">elif</span> <span class="n">DM</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_chain_subsys&quot;</span><span class="p">)</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_other_subsys&quot;</span><span class="p">)</span>
		<span class="n">_basis_kwargs</span><span class="p">[</span><span class="s2">&quot;return_rdm&quot;</span><span class="p">]</span><span class="o">=</span><span class="s2">&quot;both&quot;</span>

	<span class="k">elif</span> <span class="n">DM</span> <span class="ow">and</span> <span class="n">DM</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;chain_subsys&#39;</span><span class="p">,</span><span class="s1">&#39;other_subsys&#39;</span><span class="p">,</span><span class="s1">&#39;both&#39;</span><span class="p">]:</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unexpected keyword argument for &#39;DM&#39;!&quot;</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">svd_return_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lmbda&#39;</span><span class="p">)</span>
		<span class="n">_basis_kwargs</span><span class="p">[</span><span class="s2">&quot;return_rdm_EVs&quot;</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>

	<span class="c1">### translate arguments</span>
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">system_state</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
		<span class="k">if</span> <span class="s2">&quot;rho_d&quot;</span> <span class="ow">in</span> <span class="n">system_state</span> <span class="ow">and</span> <span class="s2">&quot;V_rho&quot;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="p">:</span>
			<span class="n">V_rho</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s2">&quot;V_rho&quot;</span><span class="p">]</span>
			<span class="n">rho_d</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s2">&quot;rho_d&quot;</span><span class="p">]</span> 
			<span class="n">state</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ji,j,jk-&gt;ik&quot;</span><span class="p">,</span><span class="n">V_rho</span><span class="p">,</span><span class="n">rho_d</span><span class="p">,</span><span class="n">V_rho</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
		<span class="k">elif</span> <span class="s2">&quot;V_states&quot;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="p">:</span>
			<span class="n">state</span><span class="o">=</span><span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;V_states&#39;</span><span class="p">]</span>
			<span class="n">_basis_kwargs</span><span class="p">[</span><span class="s2">&quot;enforce_pure&quot;</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting dictionary with keys [&#39;V_rho&#39;,&#39;rho_d&#39;] or [&#39;V_states&#39;]&quot;</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">state</span><span class="o">=</span><span class="n">system_state</span>

	<span class="n">translate_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;DM_chain_subsys&quot;</span><span class="p">:</span><span class="s1">&#39;rdm_A&#39;</span><span class="p">,</span><span class="s2">&quot;DM_other_subsys&quot;</span><span class="p">:</span><span class="s1">&#39;rdm_B&#39;</span><span class="p">,</span><span class="s2">&quot;both&quot;</span><span class="p">:</span><span class="s1">&#39;both&#39;</span><span class="p">,</span><span class="s1">&#39;lmbda&#39;</span><span class="p">:</span><span class="s2">&quot;p_A&quot;</span><span class="p">})</span>
	
	<span class="n">Sent</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">ent_entropy</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">sub_sys_A</span><span class="o">=</span><span class="n">chain_subsys</span><span class="p">,</span><span class="o">**</span><span class="n">_basis_kwargs</span><span class="p">)</span>
	



	<span class="c1"># store variables to dictionary</span>
	<span class="n">return_dict</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
		<span class="n">j</span><span class="o">=</span><span class="n">translate_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;lmbda&#39;</span><span class="p">:</span>
			<span class="n">return_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">Sent</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">return_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sent</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

	<span class="n">return_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Sent</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">return_dict</span></div>
		
<div class="viewcode-block" id="diag_ensemble"><a class="viewcode-back" href="../../../generated/quspin.tools.measurements.diag_ensemble.html#quspin.tools.measurements.diag_ensemble">[docs]</a><span class="k">def</span> <span class="nf">diag_ensemble</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">system_state</span><span class="p">,</span><span class="n">E2</span><span class="p">,</span><span class="n">V2</span><span class="p">,</span><span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">rho_d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">Obs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">delta_t_Obs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">delta_q_Obs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">Sd_Renyi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">Srdm_Renyi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">Srdm_args</span><span class="o">=</span><span class="p">{}):</span>
	<span class="sd">&quot;&quot;&quot;Calculates expectation values in the Diagonal ensemble of the initial state. </span>

<span class="sd">	Equivalently, these are also the infinite-time expectation values after a sudden quench from a </span>
<span class="sd">	Hamiltonian :math:`H_1` to a Hamiltonian :math:`H_2`. Let us label the two eigenbases by</span>

<span class="sd">	.. math::</span>
<span class="sd">		V_1=\\{|n_1\\rangle: H_1|n_1\\rangle=E_1|n_1\\rangle\\} \qquad V_2=\\{|n_2\\rangle: H_2|n_2\\rangle=E_2|n_2\\rangle\\}</span>

<span class="sd">	See eg. `arXiv:1509.06411 &lt;https://arxiv.org/abs/1509.06411/&gt;`_ for the physical definition of Diagonal Ensemble.</span>
<span class="sd">	</span>
<span class="sd">	**Note: All expectation values depend statistically on the symmetry block used via the available number of </span>
<span class="sd">	states, due to the generic system-size dependence!**</span>

<span class="sd">	Examples</span>
<span class="sd">	--------</span>

<span class="sd">	We prepare a quantum system in an eigenstate :math:`\\psi_1` of the Hamiltonian :math:`H_1=\\sum_j hS^x_j + g S^z_j`.</span>
<span class="sd">	At time :math:`t=0` we quench to the Hamiltonian :math:`H_2=\\sum_j JS^z_{j+1}S^z_j+ hS^x_j + g S^z_j`, and evolve</span>
<span class="sd">	the initial state :math:`\\psi_1` with it. We compute the infinite-time (i.e. Diagonal Ensemble) expectation value of the Hamiltonian :math:`H_1`, and</span>
<span class="sd">	it&#39;s infinite-time temporal fluctuations :math:`\\delta_t\\mathcal{O}^\\psi_d` (see above for the definition). </span>

<span class="sd">	.. literalinclude:: ../../doc_examples/diag_ens-example.py</span>
<span class="sd">		:linenos:</span>
<span class="sd">		:language: python</span>
<span class="sd">		:lines: 7-</span>

<span class="sd">	Parameters</span>
<span class="sd">	-----------</span>
<span class="sd">	N : int</span>
<span class="sd">		System size/dimension (e.g. number of sites).</span>
<span class="sd">	system_state : {array_like,dict}</span>
<span class="sd">		State of the quantum system; can be either of:</span>

<span class="sd">			* numpy.ndarray: pure state, shape = (Ns,) or (,Ns).</span>
<span class="sd">			* numpy.ndarray: density matrix (DM), shape = (Ns,Ns).</span>
<span class="sd">			* dict: mixed DM as dictionary `{&quot;V1&quot;:V1, &quot;E1&quot;:E1, &quot;f&quot;:f, &quot;f_args&quot;:f_args, &quot;V1_state&quot;:int, &quot;f_norm&quot;:`False`}` to define a diagonal DM in the basis :math:`V_1` of the Hamiltonian :math:`H_1`. The meaning of the keys (keys CANNOT be chosen arbitrarily) is as flollows:</span>

<span class="sd">				* numpy.ndarray: `V1` (required) contains eigenbasis of :math:`H_1` in the columns.</span>
<span class="sd">				* numpy.ndarray: `E1` (required) eigenenergies of :math:`H_1`.</span>
<span class="sd">				* :obj:`function` &#39;f&#39; (optional) is a function which represents the distribution of the spectrum </span>
<span class="sd">					used to define the mixed DM of the initial state (see example). </span>

<span class="sd">					Default is a thermal distribution with inverse temperature `beta`: </span>
<span class="sd">					`f = lambda E,beta: numpy.exp(-beta*(E - E[0]) )`. </span>
<span class="sd">				* list(float): `f_args` (required) list of arguments for function `f`. </span>

<span class="sd">					If `f` is not defined, by default we have :math:`f(E)=\\exp(-\\beta(E - E_\\mathrm{GS}))`, </span>
<span class="sd">					and `f_args=[beta]` specifies the inverse temeprature.</span>
<span class="sd">				* list(int): `V1_state` (optional) is a list of integers to specify arbitrary states of `V1` </span>
<span class="sd">					whose pure expectations are also returned.</span>
<span class="sd">				* bool: `f_norm` (optional). If set to `False` the mixed DM built from `f` is NOT normalised</span>
<span class="sd">					and the norm is returned under the key `f_norm`. </span>

<span class="sd">					Use this option if you need to average your results over multiple symmetry blocks, which</span>
<span class="sd">					require a separate normalisations. </span>

<span class="sd">				If this option is specified, then all Diagonal Ensemble quantities are averaged over </span>
<span class="sd">				the energy distribution :math:`f(E_1,f\\_args)`:</span>
<span class="sd">				</span>
<span class="sd">				.. math::</span>
<span class="sd">					\\overline{\\mathcal{M}_d} = \\frac{1}{Z_f}\\sum_{n_1} f(E_{n_1},f\\_args)\\mathcal{M}^{n_1}_d, \\qquad \\mathcal{M}^{\\psi}_d = \\langle\\mathcal{O}\\rangle_d^\\psi,\\ \\delta_q\\mathcal{O}^\\psi_d,\\ \\delta_t\\mathcal{O}^\\psi_d,\\ S_d^\\psi,\\ S_\\mathrm{rdm}^\\psi</span>
<span class="sd">	V2 : numpy.ndarray</span>
<span class="sd">		Contains the basis of the Hamiltonian :math:`H_2` in the columns.</span>
<span class="sd">	E2 : numpy.ndarray</span>
<span class="sd">		Contains the eigenenergies corresponding to the eigenstates in `V2`. </span>

<span class="sd">		This variable is only used to check for degeneracies, in which case the function is NOT expected to</span>
<span class="sd">		produce correct resultsand raises an error.</span>
<span class="sd">	rho_d : bool, optional </span>
<span class="sd">		When set to `True`, returns the Diagonal ensemble DM. Default is `False`.</span>

<span class="sd">		Adds the key &quot;rho_d&quot; to output. </span>

<span class="sd">		For example, if `system_state` is the pure state :math:`|\\psi\\rangle`:</span>
<span class="sd">		</span>
<span class="sd">		.. math::</span>
<span class="sd">			\\rho_d^\\psi = \\sum_{n_2} \\left|\\langle\\psi|n_2\\rangle\\right|^2\\left|n_2\\rangle\\langle n_2\\right| = \\sum_{n_2} \\left(\\rho_d^\\psi\\right)_{n_2n_2}\\left|n_2\\rangle\\langle n_2\\right| </span>
<span class="sd">	Obs : :obj:, optional</span>
<span class="sd">		Hermitian matrix of the same shape as `V2`, to calculate the Diagonal ensemble expectation value of. </span>
<span class="sd">		</span>
<span class="sd">		Adds the key &quot;Obs&quot; to output. Can be of type `numpy.ndarray` or an instance of the `hamiltonian` class.</span>

<span class="sd">		For example, if `system_state` is the pure state :math:`|\\psi\\rangle`:</span>
<span class="sd">  		</span>
<span class="sd">  		.. math::</span>
<span class="sd">  			\\langle\mathcal{O}\\rangle_d^\\psi = \\lim_{T\\to\\infty}\\frac{1}{T}\\int_0^T\\mathrm{d}t \\frac{1}{N}\\langle\\psi\\left|\\mathcal{O}(t)\\right|\\psi\\rangle = \\frac{1}{N}\\sum_{n_2}\\left(\\rho_d^\\psi\\right)_{n_2n_2} \\langle n_2\\left|\\mathcal{O}\\right|n_2\\rangle</span>
<span class="sd">	delta_q_Obs : bool, optional</span>
<span class="sd">		QUANTUM fluctuations of the expectation of `Obs` at infinite times. Requires `Obs`. Calculates</span>
<span class="sd">		temporal fluctuations `delta_t_Obs` for along the way (see above).</span>
<span class="sd">		</span>
<span class="sd">		Adds keys &quot;delta_q_Obs&quot; and &quot;delta_t_Obs&quot; to output.</span>

<span class="sd">		For example, if `system_state` is the pure state :math:`|\\psi\\rangle`:</span>
<span class="sd">  		</span>
<span class="sd">  		.. math::</span>
<span class="sd">  			\\delta_q\\mathcal{O}^\\psi_d = \\frac{1}{N}\\sqrt{\\lim_{T\\to\\infty}\\frac{1}{T}\\int_0^T\\mathrm{d}t \\langle\\psi\\left| \\mathcal{O}(t)\\right| \\psi\\rangle^2 - \\langle\\mathcal{O}\\rangle_d^2}= \\frac{1}{N}\\sqrt{ \\sum_{n_2\\neq m_2} \\left(\\rho_d^\\psi\\right)_{n_2n_2} [\\mathcal{O}]^2_{n_2m_2} \\left(\\rho_d^\\psi\\right)_{m_2m_2} }</span>
<span class="sd">	delta_t_Obs : bool, optional</span>
<span class="sd">		TEMPORAL fluctuations around infinite-time expectation of `Obs`. Requires `Obs`. </span>
<span class="sd">		</span>
<span class="sd">		Adds the key &quot;delta_t_Obs&quot; to output.</span>

<span class="sd">		For example, if `system_state` is the pure state :math:`|\\psi\\rangle`:</span>

<span class="sd">		.. math::  </span>
<span class="sd">  			\\delta_t\\mathcal{O}^\\psi_d = \\frac{1}{N}\\sqrt{ \\lim_{T\\to\infty}\\frac{1}{T}\\int_0^T\\mathrm{d}t \\langle\\psi\\left|[\\mathcal{O}(t)]^2\\right|\\psi\\rangle - \\langle\\psi\\left|\\mathcal{O}(t)\\right|\\psi\\rangle^2} = \\frac{1}{N}\\sqrt{\\langle\\mathcal{O}^2\\rangle_d - \\langle\\mathcal{O}\\rangle_d^2 - \\left(\\delta_q\\mathcal{O}^\\psi_d\\right)^2 }</span>
<span class="sd">	alpha : float, optional</span>
<span class="sd">		Renyi :math:`alpha` parameter. Default is `alpha = 1.0`.</span>
<span class="sd">	Sd_Renyi : bool, optional</span>
<span class="sd">		Computes the DIAGONAL Renyi entropy in the basis of :math:`H_2`. \</span>

<span class="sd">		The default Renyi parameter is `alpha=1.0` (see below). \</span>

<span class="sd">		Adds the key &quot;Sd_Renyi&quot; to output.\</span>

<span class="sd">		For example, if `system_state` is the pure state :math:`|\\psi\\rangle`:</span>
<span class="sd">  		</span>
<span class="sd">  		.. math::</span>
<span class="sd">  			S_d^\\psi = \\frac{1}{1-\\alpha}\\log\\mathrm{tr}\\left(\\rho_d^\\psi\\right)^\\alpha</span>
<span class="sd">	Srdm_Renyi : bool, optional</span>
<span class="sd">		Computes ENTANGLEMENT Renyi entropy of a subsystem (see `Srdm_args` for subsystem definition). </span>

<span class="sd">		Requires passing the (otherwise optional) argument `Srdm_args` (see below).</span>
<span class="sd">		</span>
<span class="sd">		The default Renyi parameter is `alpha=1.0` (see below). </span>

<span class="sd">		Adds the key &quot;Srdm_Renyi&quot; to output.</span>

<span class="sd">		For example, if `system_state` is the pure state :math:`|\\psi\\rangle` </span>
<span class="sd">		(see also notation in documentation of `ent_entropy`):</span>
<span class="sd">  		</span>
<span class="sd">  		.. math::</span>
<span class="sd">  			S_\\mathrm{rdm}^\\psi = \\frac{1}{1-\\alpha}\\log \\mathrm{tr}_{A} \\left( \\mathrm{tr}_{A^c} \\rho_d^\\psi \\right)^\\alpha </span>
<span class="sd">	Srdm_args : dict, semi-optional</span>
<span class="sd">		Dictionary which contains all arguments required for the computation of the entanglement Renyi </span>
<span class="sd">		entropy. Required when `Srdm_Renyi = True`. The following keys are allowed/supported:</span>

<span class="sd">			* &quot;basis&quot;: obj(basis), required</span>
<span class="sd">				Basis used to build `system_state` in. Must be an instance of the `basis` class. </span>
<span class="sd">			* &quot;chain_subsys&quot; : list, optional </span>
<span class="sd">				Lattice sites to specify the chain subsystem of interest. Default is:</span>

<span class="sd">				-- [0,1,...,N/2-1,N/2] for `spin_basis_1d`, `fermion_basis_1d`, `boson_basis_1d`.</span>

<span class="sd">				-- [0,1,...,N-1,N] for `photon_basis`.</span>
<span class="sd">	density : bool, optional </span>
<span class="sd">		If set to `True`, all observables are normalised by the system size `N`, except</span>
<span class="sd">		for the `Srdm_Renyi` which is normalised by the subsystem size, i.e. by the length of `chain_subsys`.</span>
<span class="sd">		Default is &#39;True&#39;.</span>

<span class="sd">	Returns</span>
<span class="sd">	-------- </span>
<span class="sd">	dict</span>
<span class="sd">		The following keys of the output are possible, depending on the choice of flags:</span>

<span class="sd">		* &quot;rho_d&quot;: density matrix of Diagonal Ensemble.</span>
<span class="sd">		* &quot;Obs_...&quot;: infinite-time expectation of observable `Obs`.</span>
<span class="sd">		* &quot;delta_t_Obs_...&quot;: infinite-time temporal fluctuations of `Obs`.</span>
<span class="sd">		* &quot;delta_q_Obs_...&quot;: infinite-time quantum fluctuations of `Obs`.</span>
<span class="sd">		* &quot;Sd_...&quot; (&quot;Sd_Renyi_...&quot; for :math:`\\alpha\\neq1.0`): Renyi diagonal entropy of density matrix of </span>
<span class="sd">			`rho_d` with parameter `alpha`.</span>
<span class="sd">		* &quot;Srdm_...&quot; (&quot;Srdm_Renyi_...&quot; for :math:`\\alpha\\neq1.0`): Renyi entanglement entropy of reduced DM of </span>
<span class="sd">			`rho_d` (`rho_d` is a mixed DM itself) with parameter `alpha`.</span>

<span class="sd">		Replace &quot;...&quot; above by &#39;pure&#39;, &#39;thermal&#39; or &#39;mixed&#39; depending on input parameters.</span>

<span class="sd">	</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="c1"># check if E2 are all unique</span>
	<span class="n">E2</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">E2</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span> <span class="n">_np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">E2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">E3</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">E2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot use function &#39;diag_ensemble&#39; with dengenerate e&#39;values &#39;E2&#39;!&quot;</span><span class="p">)</span>
	<span class="k">del</span> <span class="n">E2</span>

	<span class="k">if</span> <span class="n">N</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;System size &#39;N&#39; must be a positive integer!&quot;</span><span class="p">)</span>


	<span class="c1"># various checks</span>
	<span class="k">if</span> <span class="n">delta_t_Obs</span> <span class="ow">or</span> <span class="n">delta_q_Obs</span><span class="p">:</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">Obs</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting to parse the observable &#39;Obs&#39; whenever &#39;delta_t_Obs = True&#39; or &#39;delta_q_Obs = True&#39;!&quot;</span><span class="p">)</span>
	
	<span class="c1"># calculate diagonal ensemble DM</span>

	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">system_state</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span> <span class="c1"># initial state either pure or DM</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">system_state</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># pure state</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;pure&#39;</span>
			<span class="c1"># calculate diag ensemble DM</span>
			<span class="n">rho</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">system_state</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V2</span><span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">;</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">system_state</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># DM</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;DM&#39;</span>
			<span class="c1"># calculate diag ensemble DM</span>
			<span class="n">rho</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span> <span class="s1">&#39;ij,ji-&gt;i&#39;</span><span class="p">,</span> <span class="n">V2</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">system_state</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V2</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">real</span>

	
	<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">system_state</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span> <span class="c1"># initial state is defined by diag distr</span>
		<span class="c1"># define allowed keys</span>
		<span class="n">key_strings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;V1&#39;</span><span class="p">,</span><span class="s1">&#39;E1&#39;</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">,</span><span class="s1">&#39;f_args&#39;</span><span class="p">,</span><span class="s1">&#39;V1_state&#39;</span><span class="p">,</span><span class="s1">&#39;f_norm&#39;</span><span class="p">]</span>

		<span class="k">if</span> <span class="s1">&#39;V1&#39;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">V1</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;V1&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Dictionary &#39;system_state&#39; must contain states matrix &#39;V1&#39;!&quot;</span><span class="p">)</span>
		
		<span class="k">if</span> <span class="s1">&#39;E1&#39;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">E1</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;E1&#39;</span><span class="p">]</span> <span class="p">)</span>
			<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">E1</span><span class="p">)</span><span class="o">!=</span><span class="n">E1</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting ordered vector of energies &#39;E1&#39;!&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Dictionary &#39;system_state&#39; must contain eigenvalues vector &#39;E1&#39;!&quot;</span><span class="p">)</span>
		
		<span class="k">if</span> <span class="s1">&#39;f_args&#39;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">f_args</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;f_args&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Dictionary &#39;system_state&#39; must contain function arguments list &#39;f_args&#39;!&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="s1">&#39;V1_state&#39;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">V1_state</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;V1_state&#39;</span><span class="p">]</span>

		<span class="c1"># check if user has passed the distribution &#39;f&#39;</span>
		<span class="k">if</span> <span class="s1">&#39;f&#39;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">f</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;mixed&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;thermal&#39;</span>
			<span class="c1"># define Gibbs distribution (up to normalisation)</span>
			<span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">E1</span><span class="p">,</span><span class="n">beta</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span><span class="o">*</span><span class="p">(</span><span class="n">E1</span> <span class="o">-</span> <span class="n">E1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

		<span class="k">if</span> <span class="s1">&#39;f_norm&#39;</span> <span class="ow">in</span> <span class="n">system_state</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">f_norm</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;f_norm&#39;</span><span class="p">]</span>
			<span class="n">f_norms</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">f_args</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">f_args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">f_norm</span> <span class="o">=</span> <span class="kc">True</span>

		<span class="k">if</span> <span class="s1">&#39;V1_state&#39;</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">V1_state</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting an integer value for variable &#39;V1_state&#39;!&quot;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">V1_state</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">V1_state</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">E1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Value &#39;V1_state&#39; violates &#39;0 &lt;= V1_state &lt;= len(E1)-1&#39;!&quot;</span><span class="p">)</span>

		<span class="c1"># define diagonal (in V1) mixed DM</span>
		
		<span class="n">rho_mixed</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">E1</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">f_args</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">f_args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
			<span class="k">if</span> <span class="n">f_norm</span><span class="p">:</span>
				<span class="n">rho_mixed</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">E1</span><span class="p">,</span><span class="n">arg</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">E1</span><span class="p">,</span><span class="n">arg</span><span class="p">))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">rho_mixed</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">E1</span><span class="p">,</span><span class="n">arg</span><span class="p">)</span>
				<span class="c1"># calculate normalisation</span>
				<span class="n">f_norms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">E1</span><span class="p">,</span><span class="n">arg</span><span class="p">))</span>


		<span class="c1"># calculate diag ensemble DM for each state in V1</span>
		<span class="n">rho</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">V2</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V1</span><span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># components are (n,psi)</span>

		<span class="k">del</span> <span class="n">V1</span><span class="p">,</span> <span class="n">E1</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Wrong variable type for &#39;system_state&#39;! E.g., use np.ndarray.&quot;</span><span class="p">)</span>


	<span class="c1"># clear up memory</span>
	<span class="k">del</span> <span class="n">system_state</span>

	<span class="c1"># add floating point number to zero elements</span>
	<span class="n">rho</span><span class="p">[</span><span class="n">rho</span><span class="o">&lt;=</span><span class="mi">1</span><span class="n">E</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">rho</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>


	<span class="c1"># prepare observables</span>
	<span class="k">if</span> <span class="n">Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">delta_t_Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">delta_q_Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">delta_t_Obs</span> <span class="ow">or</span> <span class="n">delta_q_Obs</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
			<span class="c1"># diagonal matrix elements of Obs^2 in the basis V2</span>
			<span class="c1">#delta_t_Obs =  _np.einsum( &#39;ij,ji-&gt;i&#39;, V2.T.conj(), Obs.dot(Obs).dot(V2) ).real</span>
			<span class="n">Obs</span> <span class="o">=</span> <span class="n">V2</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">Obs</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V2</span><span class="p">)</span> <span class="p">)</span>
			<span class="n">delta_t_Obs</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">Obs</span><span class="p">)</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">delta_t_Obs</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">delta_q_Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
				<span class="n">delta_q_Obs</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Obs</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Obs</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
			<span class="n">Obs</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Obs</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
			
		<span class="k">elif</span> <span class="n">Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
			<span class="c1"># diagonal matrix elements of Obs in the basis V2</span>
			<span class="n">Obs</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ji-&gt;i&#39;</span><span class="p">,</span> <span class="n">V2</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">Obs</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V2</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">real</span>

		
	<span class="k">if</span> <span class="n">Srdm_Renyi</span><span class="p">:</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		# calculate singular values of columns of V2</span>
<span class="sd">		v, _, N_A = _reshape_as_subsys({&quot;V_states&quot;:V2},**Srdm_args)</span>

<span class="sd">		U, lmbda, _ = _npla.svd(v, full_matrices=False)</span>
<span class="sd">		if istate in [&#39;mixed&#39;,&#39;thermal&#39;]:</span>
<span class="sd">			DM_chain_subsys = _np.einsum(&#39;nm,nij,nj,nkj-&gt;mik&#39;,rho,U,lmbda**2,U.conj() )</span>
<span class="sd">		else:</span>
<span class="sd">			DM_chain_subsys = _np.einsum(&#39;n,nij,nj,nkj-&gt;ik&#39;,rho,U,lmbda**2,U.conj() )</span>
<span class="sd">			</span>
<span class="sd">		Srdm_Renyi = _npla.eigvalsh(DM_chain_subsys).T # components (i,psi)</span>
<span class="sd">		del v, U, DM_chain_subsys</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">basis</span><span class="o">=</span><span class="n">Srdm_args</span><span class="p">[</span><span class="s1">&#39;basis&#39;</span><span class="p">]</span>
		<span class="n">partial_tr_args</span><span class="o">=</span><span class="n">Srdm_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="k">del</span> <span class="n">partial_tr_args</span><span class="p">[</span><span class="s1">&#39;basis&#39;</span><span class="p">]</span>
		<span class="k">if</span> <span class="s1">&#39;sub_sys_A&#39;</span> <span class="ow">in</span> <span class="n">Srdm_args</span><span class="p">:</span>
			<span class="n">sub_sys_A</span> <span class="o">=</span> <span class="n">Srdm_args</span><span class="p">[</span><span class="s1">&#39;sub_sys_A&#39;</span><span class="p">]</span>
			<span class="k">del</span> <span class="n">partial_tr_args</span><span class="p">[</span><span class="s1">&#39;sub_sys_A&#39;</span><span class="p">]</span>

		<span class="k">elif</span> <span class="s1">&#39;chain_subsys&#39;</span> <span class="ow">in</span> <span class="n">Srdm_args</span><span class="p">:</span>
			<span class="n">sub_sys_A</span> <span class="o">=</span> <span class="n">Srdm_args</span><span class="p">[</span><span class="s1">&#39;chain_subsys&#39;</span><span class="p">]</span>
			<span class="k">del</span> <span class="n">partial_tr_args</span><span class="p">[</span><span class="s1">&#39;chain_subsys&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">sub_sys_A</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">L</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span>
		<span class="n">N_A</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_sys_A</span><span class="p">)</span>
		<span class="n">rdm_A</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">partial_trace</span><span class="p">(</span><span class="n">V2</span><span class="p">,</span><span class="n">sub_sys_A</span><span class="o">=</span><span class="n">sub_sys_A</span><span class="p">,</span><span class="n">enforce_pure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="o">**</span><span class="n">partial_tr_args</span><span class="p">)</span>
		<span class="n">rdm</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;n...,nij-&gt;...ij&#39;</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">rdm_A</span><span class="p">)</span>
	
		<span class="n">Srdm_Renyi</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">rdm</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1"># components (i,psi) </span>
		
	<span class="c1"># clear up memory</span>
	<span class="k">del</span> <span class="n">V2</span>

	<span class="c1"># calculate diag expectation values</span>
	<span class="n">Expt_Diag</span> <span class="o">=</span> <span class="n">_inf_time_obs</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">istate</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span><span class="n">Obs</span><span class="o">=</span><span class="n">Obs</span><span class="p">,</span><span class="n">delta_t_Obs</span><span class="o">=</span><span class="n">delta_t_Obs</span><span class="p">,</span><span class="n">delta_q_Obs</span><span class="o">=</span><span class="n">delta_q_Obs</span><span class="p">,</span><span class="n">Srdm_Renyi</span><span class="o">=</span><span class="n">Srdm_Renyi</span><span class="p">,</span><span class="n">Sd_Renyi</span><span class="o">=</span><span class="n">Sd_Renyi</span><span class="p">)</span>
	

	<span class="n">Expt_Diag_Vstate</span><span class="o">=</span><span class="p">{}</span>
	<span class="c1"># compute density</span>
	<span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">Expt_Diag</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
		<span class="k">if</span> <span class="n">density</span><span class="p">:</span>
			<span class="k">if</span> <span class="s1">&#39;rdm&#39;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
				<span class="n">value</span> <span class="o">/=</span> <span class="n">N_A</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">value</span> <span class="o">/=</span> <span class="n">N</span>

		<span class="n">Expt_Diag</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
		<span class="c1"># calculate thermal expectations</span>
		<span class="k">if</span> <span class="n">istate</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mixed&#39;</span><span class="p">,</span><span class="s1">&#39;thermal&#39;</span><span class="p">]:</span>
			<span class="n">Expt_Diag_state</span> <span class="o">=</span> <span class="p">{}</span>
			<span class="n">Expt_Diag</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rho_mixed</span><span class="p">)</span>
			<span class="c1"># if &#39;GS&#39; option is passed save GS value</span>
			<span class="k">if</span> <span class="s1">&#39;V1_state&#39;</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
				<span class="n">state_key</span> <span class="o">=</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">istate</span><span class="p">)]</span><span class="o">+</span><span class="s1">&#39;V1_state&#39;</span>
				<span class="n">Expt_Diag_Vstate</span><span class="p">[</span><span class="n">state_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">V1_state</span><span class="p">]</span>
			<span class="c1"># merge state and mixed dicts</span>
			<span class="n">Expt_Diag</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Expt_Diag_state</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">istate</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mixed&#39;</span><span class="p">,</span><span class="s1">&#39;thermal&#39;</span><span class="p">]:</span>
		<span class="k">if</span> <span class="n">f_norm</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
			<span class="n">Expt_Diag</span><span class="p">[</span><span class="s1">&#39;f_norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_norms</span>
		<span class="k">if</span> <span class="s1">&#39;V1_state&#39;</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
			<span class="n">Expt_Diag</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Expt_Diag_Vstate</span><span class="p">)</span>
			
	<span class="c1"># return diag ensemble density matrix if requested</span>
	<span class="k">if</span> <span class="n">rho_d</span><span class="p">:</span>
		<span class="k">if</span> <span class="s1">&#39;V1_state&#39;</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
			<span class="n">Expt_Diag</span><span class="p">[</span><span class="s1">&#39;rho_d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[:,</span><span class="n">V1_state</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">Expt_Diag</span><span class="p">[</span><span class="s1">&#39;rho_d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span>


	<span class="k">return</span> <span class="n">Expt_Diag</span></div>

<div class="viewcode-block" id="obs_vs_time"><a class="viewcode-back" href="../../../generated/quspin.tools.measurements.obs_vs_time.html#quspin.tools.measurements.obs_vs_time">[docs]</a><span class="k">def</span> <span class="nf">obs_vs_time</span><span class="p">(</span><span class="n">psi_t</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">Obs_dict</span><span class="p">,</span><span class="n">return_state</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">Sent_args</span><span class="o">=</span><span class="p">{},</span><span class="n">enforce_pure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Calculates expectation value of observable(s) as a function of time in a time-dependent state.</span>

<span class="sd">	Examples</span>
<span class="sd">	--------</span>

<span class="sd">	The following example shows how to calculate the expectation values :math:`\\langle\\psi_1(t)|H_1|\\psi_1(t)\\rangle`</span>
<span class="sd">	and :math:`\\langle\\psi_1(t)|H_2|\\psi_1(t)\\rangle`.</span>

<span class="sd">	The initial state is an eigenstate of :math:`H_1=\\sum_j hS^x_j + g S^z_j`. The time evolution is done </span>
<span class="sd">	under :math:`H_2=\\sum_j JS^z_{j+1}S^z_j+ hS^x_j + g S^z_j`.</span>

<span class="sd">	.. literalinclude:: ../../doc_examples/obs_vs_time-example.py</span>
<span class="sd">		:linenos:</span>
<span class="sd">		:language: python</span>
<span class="sd">		:lines: 7-</span>

<span class="sd">	Parameters</span>
<span class="sd">	-----------</span>
<span class="sd">	psi_t : {tuple,aray_like,generator}</span>
<span class="sd">		Time-dependent state data; can be either one of:</span>

<span class="sd">		* tuple: `psi_t = (psi, E, V)` where </span>
<span class="sd">			-- np.ndarray: initial state `psi`.</span>

<span class="sd">			-- np.ndarray: unitary matrix `V`, contains all eigenstates of the Hamiltonian :math:`H`.</span>

<span class="sd">			-- np.ndarray: real-valued array `E`, contains all eigenvalues of the Hamiltonian :math:`H`. </span>
<span class="sd">			   The order of the eigenvalues must correspond to the order of the columns of `V`.</span>

<span class="sd">			Use this option when the initial state is evolved with a time-INdependent Hamiltonian :math:`H`.</span>
<span class="sd">		* numpy.ndarray: array with the states evaluated at `times` stored in the last dimension. </span>
<span class="sd">			Can be 2D (single time-dependent state) or 3D (many time-dependent states or </span>
<span class="sd">			time-dep mixed density matrix, see `enforce_pure` argument.)</span>

<span class="sd">			Use this option for PARALLELISATION over many states.</span>
<span class="sd">		* obj: generator which generates the states.</span>

<span class="sd">	Obs_dict : dict</span>
<span class="sd">		Dictionary with observables (e.g. `hamiltonian objects`) stored in the `values`, to calculate </span>
<span class="sd">		their time-dependent expectation value. Dictionary `keys` are chosen by user.</span>
<span class="sd">	times : numpy.ndarray</span>
<span class="sd">		Vector of times to evaluate the expectation values at. This is important for time-dependent observables. </span>
<span class="sd">	return_state : bool, optional</span>
<span class="sd">		If set to `True`, adds key &quot;psi_time&quot; to output. The columns of the array</span>
<span class="sd">		contain the state vector at the `times` which specifies the column index. Default is `False`, unless</span>
<span class="sd">		`Sent_args` is nonempty.</span>
<span class="sd">	Srdm_args : dict, optional </span>
<span class="sd">		If nonempty, this dictionary contains the arguments necessary for the calculation of the entanglement</span>
<span class="sd">		entropy. The following key is required:</span>
<span class="sd">			</span>
<span class="sd">			* &quot;basis&quot;: the basis used to build `system_state` in. Must be an instance of the `basis` class.</span>

<span class="sd">		The user can choose optional arguments according to those provided in the function method </span>
<span class="sd">		`basis.ent_entropy()` of the `basis` class [preferred], or the function `ent_entropy()`. </span>

<span class="sd">		If only the `basis` is passed, the default parameters of `basis.ent_entropy()` are assumed.</span>
<span class="sd">	enforce_pure : bool, optional</span>
<span class="sd">		Flag to enforce pure state expectation values in the case that `psi_t` is an array of pure states</span>
<span class="sd">		in the columns. (`psi_t` will otherwise be interpreted as a mixed density matrix).</span>
<span class="sd">	verbose : bool, optional</span>
<span class="sd">		If set to `True`, displays a message at every `times` step after the calculation is complete.</span>
<span class="sd">		Default is `False`.</span>

<span class="sd">	Returns</span>
<span class="sd">	--------</span>
<span class="sd">	dict</span>
<span class="sd">		The following keys of the output are possible, depending on the choice of flags:</span>
<span class="sd">		</span>
<span class="sd">			* &quot;custom_name&quot;: for each key of `Obs_dict`, the time-dependent expectation of the </span>
<span class="sd">				corresponding observable `Obs_dict[key]` is calculated and returned under the user-defined name</span>
<span class="sd">				for the observable.</span>
<span class="sd">			* &quot;psi_t&quot;: (optional) returns time-dependent state, if `return_state=True` or `Srdm_args` is nonempty.</span>
<span class="sd">			* &quot;Sent_time&quot;: (optional) returns dictionary with keys corresponding to the entanglement entropy </span>
<span class="sd">				calculation for each time in `times`. Can have more keys than just &quot;Sent_A&quot;, e.g. if the reduced</span>
<span class="sd">				DM was also requested (toggled through `Srdm_args`.)</span>

<span class="sd">	&quot;&quot;&quot;</span>

	
	<span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Expt_time&#39;</span><span class="p">]</span>
	
	<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Obs_dict</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Obs_dict must be a dictionary.&quot;</span><span class="p">)</span>

	<span class="n">num_Obs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Obs_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

	<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">Obs_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">_ishamiltonian</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
			<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">_sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">__class__</span> <span class="ow">in</span> <span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">matrix</span><span class="p">]):</span>
				<span class="n">val</span> <span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

			<span class="n">Obs_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">_hamiltonian</span><span class="p">([</span><span class="n">val</span><span class="p">],[],</span><span class="n">dtype</span><span class="o">=</span><span class="n">val</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


	<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>

		<span class="n">psi</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">psi_t</span>

		<span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;V&#39; must be a square matrix&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Number of eigenstates in &#39;V&#39; must equal number of eigenvalues in &#39;E&#39;!&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Variables &#39;psi&#39; and &#39;E&#39; must have the same dimension!&quot;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">Obs</span> <span class="ow">in</span> <span class="n">Obs_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
			<span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Obs</span><span class="o">.</span><span class="n">_shape</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;shapes of &#39;V1&#39; and &#39;Obs&#39; must be equal!&quot;</span><span class="p">)</span>
			

		<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
			<span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Variable &#39;times&#39; must be a array or iter like object!&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">return_state</span><span class="p">:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;psi_t&quot;</span><span class="p">)</span>

		
		<span class="c1"># get iterator over time dependent state (see function above)</span>
		<span class="k">if</span> <span class="n">return_state</span><span class="p">:</span>
			<span class="n">psi_t</span> <span class="o">=</span> <span class="n">ED_state_vs_time</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">iterate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">psi_t</span> <span class="o">=</span> <span class="n">ED_state_vs_time</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">iterate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


	<span class="k">elif</span> <span class="n">psi_t</span><span class="o">.</span><span class="n">__class__</span> <span class="ow">in</span> <span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">matrix</span><span class="p">]:</span>


		<span class="k">for</span> <span class="n">Obs</span> <span class="ow">in</span> <span class="n">Obs_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
			<span class="k">if</span> <span class="n">psi_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Obs</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;states must be in columns of input matrix.&quot;</span><span class="p">)</span>


		<span class="k">if</span> <span class="n">return_state</span><span class="p">:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;psi_t&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">return_state</span><span class="o">=</span><span class="kc">True</span> <span class="c1"># set to True to use einsum but do not return state</span>

	<span class="k">elif</span> <span class="n">_isgenerator</span><span class="p">(</span><span class="n">psi_t</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">return_state</span><span class="p">:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;psi_t&quot;</span><span class="p">)</span>
			<span class="n">psi_t_list</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">psi</span> <span class="ow">in</span> <span class="n">psi_t</span><span class="p">:</span>
				<span class="n">psi_t_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>

			<span class="n">psi_t</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">psi_t_list</span><span class="p">))</span>

			<span class="k">for</span> <span class="n">Obs</span> <span class="ow">in</span> <span class="n">Obs_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
				<span class="k">if</span> <span class="n">psi_t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Obs</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;states must be in columns of input matrix.&quot;</span><span class="p">)</span>

	<span class="k">else</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input not recognized&quot;</span><span class="p">)</span>
	
	<span class="c1"># calculate observables and Sent</span>
	<span class="n">Expt_time</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">calc_Sent</span> <span class="o">=</span> <span class="kc">False</span>
	
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sent_args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">Sent_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Sent_args</span><span class="p">)</span>
		<span class="n">basis</span> <span class="o">=</span> <span class="n">Sent_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;basis&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">basis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sent_args requires &#39;basis&#39; for calculation&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">isbasis</span><span class="p">(</span><span class="n">basis</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;basis&#39; object must be a proper basis object&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="p">(</span><span class="s2">&quot;chain_subsys&quot;</span> <span class="ow">in</span> <span class="n">Sent_args</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;DM&quot;</span> <span class="ow">in</span> <span class="n">Sent_args</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;svd_return_vec&quot;</span> <span class="ow">in</span> <span class="n">Sent_args</span><span class="p">):</span>
			<span class="n">calc_ent_entropy</span> <span class="o">=</span> <span class="n">ent_entropy</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">calc_ent_entropy</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">ent_entropy</span>
			<span class="k">del</span> <span class="n">Sent_args</span><span class="p">[</span><span class="s2">&quot;basis&quot;</span><span class="p">]</span>

		<span class="n">calc_Sent</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Sent_time&quot;</span><span class="p">)</span>
	
	<span class="k">if</span> <span class="n">return_state</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">Obs</span> <span class="ow">in</span> <span class="n">Obs_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="n">Expt_time</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">Obs</span><span class="o">.</span><span class="n">expt_value</span><span class="p">(</span><span class="n">psi_t</span><span class="p">,</span><span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">enforce_pure</span><span class="o">=</span><span class="n">enforce_pure</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
			
		<span class="c1"># calculate entanglement entropy if requested	</span>
		<span class="k">if</span> <span class="n">calc_Sent</span><span class="p">:</span>
			<span class="n">Sent_time</span> <span class="o">=</span> <span class="n">calc_ent_entropy</span><span class="p">(</span><span class="n">psi_t</span><span class="p">,</span><span class="o">**</span><span class="n">Sent_args</span><span class="p">)</span>


	<span class="k">else</span><span class="p">:</span>
		<span class="n">psi</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span> <span class="c1"># get first state from iterator.</span>
		<span class="c1"># do first calculations of loop</span>

		<span class="n">time</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

		<span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">Obs</span> <span class="ow">in</span> <span class="n">Obs_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			
			<span class="n">val</span> <span class="o">=</span> <span class="n">Obs</span><span class="o">.</span><span class="n">expt_value</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
			<span class="n">dtype</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
			<span class="n">Expt_time</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">Expt_time</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>



		<span class="c1"># get initial dictionary from ent_entropy function</span>
		<span class="c1"># use this to set up dictionary for the rest of calculation.</span>
		<span class="k">if</span> <span class="n">calc_Sent</span><span class="p">:</span>
			<span class="n">Sent_time</span> <span class="o">=</span> <span class="n">calc_ent_entropy</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="o">**</span><span class="n">Sent_args</span><span class="p">)</span>

			<span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="n">Sent_time</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="n">val</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
				<span class="n">dtype</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">dtype</span>
				<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),)</span> <span class="o">+</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span>
				<span class="n">Sent_time</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
				<span class="n">Sent_time</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

		<span class="c1"># loop over psi generator</span>
		<span class="k">for</span> <span class="n">m</span><span class="p">,</span><span class="n">psi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">psi_t</span><span class="p">):</span>

			<span class="n">time</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

			<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;obs_vs_time integrated to t=</span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>

			<span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">Obs</span> <span class="ow">in</span> <span class="n">Obs_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="n">Expt_time</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Obs</span><span class="o">.</span><span class="n">expt_value</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span><span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

			<span class="k">if</span> <span class="n">calc_Sent</span><span class="p">:</span>
				<span class="n">Sent_time_update</span> <span class="o">=</span> <span class="n">calc_ent_entropy</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="o">**</span><span class="n">Sent_args</span><span class="p">)</span>
				<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">Sent_time</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
					<span class="n">Sent_time</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sent_time_update</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

		
	<span class="n">return_dict</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="s1">&#39;Expt_time&#39;</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="n">Expt_time</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="n">return_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">return_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span>

	<span class="k">return</span> <span class="n">return_dict</span></div>

<div class="viewcode-block" id="ED_state_vs_time"><a class="viewcode-back" href="../../../generated/quspin.tools.measurements.ED_state_vs_time.html#quspin.tools.measurements.ED_state_vs_time">[docs]</a><span class="k">def</span> <span class="nf">ED_state_vs_time</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">iterate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Calculates the time evolution of initial state using a complete eigenbasis. </span>

<span class="sd">	The time evolution is carried out under the Hamiltonian :math:`H` with eigenenergies `E` and eigenstates `V`. </span>

<span class="sd">	Examples</span>
<span class="sd">	--------</span>

<span class="sd">	The following example shows how to time-evolve a state :math:`\\psi` using the entire eigensystem </span>
<span class="sd">	:math:`(E_1,V_1)` of a Hamiltonian :math:`H_1=\\sum_j hS^x_j + g S^z_j`.</span>
<span class="sd">	</span>
<span class="sd">	.. literalinclude:: ../../doc_examples/ED_state_vs_time-example.py</span>
<span class="sd">		:linenos:</span>
<span class="sd">		:language: python</span>
<span class="sd">		:lines: 7-</span>

<span class="sd">	Parameters</span>
<span class="sd">	-----------</span>
<span class="sd">	psi : numpy.ndarray</span>
<span class="sd">		Initial state.</span>
<span class="sd">	V : numpy.ndarray</span>
<span class="sd">		Unitary matrix containing all eigenstates of the Hamiltonian :math:`H` in its columns. </span>
<span class="sd">	E : numpy.ndarray</span>
<span class="sd">		Eigenvalues of the Hamiltonian :math:`H`, listed in the order which corresponds to the columns of `V`. </span>
<span class="sd">	times : numpy.ndarray</span>
<span class="sd">		Vector of time to evaluate the time evolved state at. </span>
<span class="sd">	iterate : bool, optional</span>
<span class="sd">		If set to `True`, the function returns the generator of the time evolved state. </span>

<span class="sd">	Returns</span>
<span class="sd">	--------</span>
<span class="sd">	obj</span>
<span class="sd">		Either of the following:</span>
<span class="sd">			* `numpy.ndarray` with the time evolved states as rows. </span>
<span class="sd">			* `generator` which generates time-dependent states one by one.</span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">psi</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">psi</span><span class="p">))</span>


	<span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;V&#39; must be a square matrix&quot;</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Number of eigenstates in &#39;V&#39; must equal number of eigenvalues in &#39;E&#39;!&quot;</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">psi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Variables &#39;psi&#39; and &#39;E&#39; must have the same dimension!&quot;</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">psi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">psi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">psi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mixed states must be square!&quot;</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">psi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;psi must be 1 or 2 dimension array.&quot;</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
		<span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Variable &#39;times&#39; must be a array or iter like object!&quot;</span><span class="p">)</span>

	<span class="n">times</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
	

	<span class="c1"># define generator of time-evolved state in basis V2</span>
	<span class="k">def</span> <span class="nf">pure_t_iter</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">psi</span><span class="p">,</span><span class="n">times</span><span class="p">):</span>
		<span class="c1"># a_n: probability amplitudes</span>
		<span class="c1"># times: time vector</span>
		<span class="n">a_n</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
			<span class="k">yield</span> <span class="n">V</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">_np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">a_n</span> <span class="p">)</span>

	<span class="k">def</span> <span class="nf">mixed_t_iter</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">psi</span><span class="p">,</span><span class="n">times</span><span class="p">):</span>
		<span class="c1"># a_n: probability amplitudes</span>
		<span class="c1"># times: time vector</span>
		<span class="n">rho_d</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">))</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
			<span class="n">exp_t</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">E</span><span class="p">)</span>
			<span class="k">yield</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,j,jk,k,lk-&gt;il&quot;</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">exp_t</span><span class="p">,</span><span class="n">rho_d</span><span class="p">,</span><span class="n">exp_t</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">V</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>


	<span class="k">if</span> <span class="n">psi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">iterate</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">pure_t_iter</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">psi</span><span class="p">,</span><span class="n">times</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">c_n</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>

			<span class="n">Ntime</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
			<span class="n">Ns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>

			<span class="c1"># generate [[-1j*times[0], ..., -1j*times[0]], ..., [-1j*times[-1], ..., -1j*times[01]]</span>
			<span class="n">psi_t</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">times</span><span class="p">,(</span><span class="n">Ns</span><span class="p">,</span><span class="n">Ntime</span><span class="p">))</span><span class="o">.</span><span class="n">T</span> 
			<span class="c1"># [[-1j*E[0]*times[0], ..., -1j*E[-1]*times[0]], ..., [-1j*E[0]*times[-1], ..., -1j*E[-1]*times[-1]]</span>
			<span class="n">psi_t</span> <span class="o">=</span> <span class="n">psi_t</span><span class="o">*</span><span class="n">E</span>
			<span class="c1"># [[exp(-1j*E[0]*times[0]), ..., exp(-1j*E[-1]*times[0])], ..., [exp(-1j*E[0]*times[-1]), ..., exp(-1j*E[01]*times[01])]</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">psi_t</span><span class="p">,</span><span class="n">psi_t</span><span class="p">)</span>

			<span class="c1"># [[c_n[0]exp(-1j*E[0]*times[0]), ..., c_n[-1]*exp(-1j*E[-1]*times[0])], ..., [c_n[0]*exp(-1j*E[0]*times[-1]), ...,c_n[o]*exp(-1j*E[01]*times[01])]</span>
			<span class="n">psi_t</span> <span class="o">*=</span> <span class="n">c_n</span> 

			<span class="c1"># for each vector trasform back to original basis</span>
			<span class="n">psi_t</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">psi_t</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> 

			<span class="k">return</span> <span class="n">psi_t</span> <span class="c1"># [ psi(times[0]), ...,psi(times[-1]) ]</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">iterate</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">mixed_t_iter</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">psi</span><span class="p">,</span><span class="n">times</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">Ntime</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
			<span class="n">Ns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>

			<span class="n">rho_d</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V</span><span class="p">))</span>

			<span class="c1"># generate [[-1j*times[0], ..., -1j*times[0]], ..., [-1j*times[-1], ..., -1j*times[01]]</span>
			<span class="n">exp_t</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">times</span><span class="p">,(</span><span class="n">Ns</span><span class="p">,</span><span class="n">Ntime</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
			<span class="c1"># [[-1j*E[0]*times[0], ..., -1j*E[-1]*times[0]], ..., [-1j*E[0]*times[-1], ..., -1j*E[-1]*times[-1]]</span>
			<span class="n">exp_t</span> <span class="o">=</span> <span class="n">exp_t</span><span class="o">*</span><span class="n">E</span>
			<span class="c1"># [[exp(-1j*E[0]*times[0]), ..., exp(-1j*E[-1]*times[0])], ..., [exp(-1j*E[0]*times[-1]), ..., exp(-1j*E[01]*times[01])]</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">exp_t</span><span class="p">,</span><span class="n">exp_t</span><span class="p">)</span>
			
			<span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,tj,jk,tk,lk-&gt;ilt&quot;</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">exp_t</span><span class="p">,</span><span class="n">rho_d</span><span class="p">,</span><span class="n">exp_t</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">V</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span></div>

<div class="viewcode-block" id="project_op"><a class="viewcode-back" href="../../../generated/quspin.tools.measurements.project_op.html#quspin.tools.measurements.project_op">[docs]</a><span class="k">def</span> <span class="nf">project_op</span><span class="p">(</span><span class="n">Obs</span><span class="p">,</span><span class="n">proj</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">complex128</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Projects observable onto symmetry-reduced subspace.</span>

<span class="sd">	This function takes an observable `Obs` and a reduced basis or a projector `proj`, and projects `Obs`</span>
<span class="sd">	onto that reduced basis.</span>

<span class="sd">	Examples</span>
<span class="sd">	--------</span>

<span class="sd">	The following example shows how to project an operator :math:`H_1=\\sum_j hS^x_j + g S^z_j` from the</span>
<span class="sd">	symmetry-reduced basis to the full basis.</span>
<span class="sd">	</span>
<span class="sd">	.. literalinclude:: ../../doc_examples/project_op-example.py</span>
<span class="sd">		:linenos:</span>
<span class="sd">		:language: python</span>
<span class="sd">		:lines: 7-</span>

<span class="sd">	Parameters</span>
<span class="sd">	-----------</span>
<span class="sd">	Obs : :obj:</span>
<span class="sd">		Operator to be projected, either a `numpy.ndarray` or a `hamiltonian` object.</span>
<span class="sd">	proj : :obj:</span>
<span class="sd">		Either one of the following:</span>

<span class="sd">		* `basis` object with the basis of the Hilbert space after the projection.</span>
<span class="sd">		* numpy.ndarray: a matrix which contains the projector.</span>

<span class="sd">		Projectors can be calculated conveniently using the function method `basis.get_proj()`.</span>
<span class="sd">	dtype : type, optional</span>
<span class="sd">		Data type of output. Default is `numpy.complex128`.</span>

<span class="sd">	Returns</span>
<span class="sd">	-------- </span>
<span class="sd">	dict</span>
<span class="sd">		Dictionary with keys</span>

<span class="sd">		* &quot;Proj_Obs&quot;: projected observable `Obs`.</span>

<span class="sd">	&quot;&quot;&quot;</span>

	<span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Proj_Obs&quot;</span><span class="p">]</span>

	<span class="k">if</span> <span class="n">isbasis</span><span class="p">(</span><span class="n">proj</span><span class="p">):</span>
		<span class="n">proj</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">get_proj</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
	<span class="k">elif</span> <span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">__class__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">matrix</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">_sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">proj</span><span class="p">)):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting either matrix/array or basis object for proj argument.&quot;</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">_ishamiltonian</span><span class="p">(</span><span class="n">Obs</span><span class="p">):</span>

		<span class="k">if</span> <span class="n">Obs</span><span class="o">.</span><span class="n">Ns</span> <span class="o">!=</span> <span class="n">proj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
			<span class="k">if</span> <span class="n">Obs</span><span class="o">.</span><span class="n">Ns</span> <span class="o">!=</span> <span class="n">proj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dimension mismatch Obs:</span><span class="si">{0}</span><span class="s2"> proj</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Obs</span><span class="o">.</span><span class="n">get_shape</span><span class="p">,</span><span class="n">proj</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c1"># projecting from a smaller to larger H-space</span>
				<span class="n">proj_down</span><span class="o">=</span><span class="kc">False</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c1"># projecting from larger to smaller H-space</span>
			<span class="n">proj_down</span><span class="o">=</span><span class="kc">True</span>

		<span class="k">if</span> <span class="n">proj_down</span><span class="p">:</span>
			<span class="n">Proj_Obs</span> <span class="o">=</span> <span class="n">Obs</span><span class="o">.</span><span class="n">project_to</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>		
		<span class="k">else</span><span class="p">:</span>
			<span class="n">Proj_Obs</span> <span class="o">=</span> <span class="n">Obs</span><span class="o">.</span><span class="n">project_to</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>

	<span class="k">else</span><span class="p">:</span>

		<span class="k">if</span> <span class="n">Obs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting Obs to be a 2 dimensional array.&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">Obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting Obs to be a square array.&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">Obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">proj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
			<span class="k">if</span> <span class="n">Obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">proj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dimension mismatch Obs:</span><span class="si">{0}</span><span class="s2"> proj</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Obs</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">proj</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">proj_down</span><span class="o">=</span><span class="kc">False</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">proj_down</span><span class="o">=</span><span class="kc">True</span>

		<span class="k">if</span> <span class="n">proj_down</span><span class="p">:</span>
			<span class="n">Proj_Obs</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Obs</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">proj</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">Proj_Obs</span> <span class="o">=</span> <span class="n">proj</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Obs</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()))</span>

	<span class="c1"># define dictionary with outputs</span>
	<span class="n">return_dict</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)):</span>
		<span class="n">return_dict</span><span class="p">[</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

	<span class="k">return</span> <span class="n">return_dict</span></div>

<div class="viewcode-block" id="KL_div"><a class="viewcode-back" href="../../../generated/quspin.tools.measurements.KL_div.html#quspin.tools.measurements.KL_div">[docs]</a><span class="k">def</span> <span class="nf">KL_div</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Calculates Kullback-Leibler divergence of two discrete probability distributions.</span>

<span class="sd">	.. math::</span>
<span class="sd">		\\mathrm{KL}(p_1||p_2) = \\sum_n p_1(n)\\log\\frac{p_1(n)}{p_2(n)}</span>

<span class="sd">	Parameters</span>
<span class="sd">	----------- </span>
<span class="sd">	p1 : numpy.ndarray</span>
<span class="sd">		Dscrete probability distribution.</span>
<span class="sd">	p2 : numpy.ndarray</span>
<span class="sd">		Discrete probability distribution.</span>

<span class="sd">	Returns</span>
<span class="sd">	--------</span>
<span class="sd">	numpy.ndarray</span>
<span class="sd">		Kullback-Leibler divergence of `p1` and `p2`.</span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">p1</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
	<span class="n">p2</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>


	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p2</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting the probability distributions &#39;p1&#39; and &#39;p2&#39; to have same size!&quot;</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">p2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting the probability distributions &#39;p1&#39; and &#39;p2&#39; to have linear dimension!&quot;</span><span class="p">)</span>


	<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p1</span><span class="o">&lt;=</span><span class="mf">0.0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p2</span><span class="o">&lt;=</span><span class="mf">0.0</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting all entries of the probability distributions &#39;p1&#39; and &#39;p2&#39; to be non-negative!&quot;</span><span class="p">)</span>
	
	<span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="n">E</span><span class="o">-</span><span class="mi">13</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting &#39;p1&#39; to be normalised!&quot;</span><span class="p">)</span>

	<span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="n">E</span><span class="o">-</span><span class="mi">13</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting &#39;p2&#39; to be normalised!&quot;</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p1</span><span class="o">==</span><span class="mf">0.0</span><span class="p">):</span>

		<span class="n">inds</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

		<span class="n">p1</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">inds</span><span class="p">)</span>
		<span class="n">p2</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="n">inds</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span> <span class="n">p1</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span> <span class="n">_np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>

<div class="viewcode-block" id="mean_level_spacing"><a class="viewcode-back" href="../../../generated/quspin.tools.measurements.mean_level_spacing.html#quspin.tools.measurements.mean_level_spacing">[docs]</a><span class="k">def</span> <span class="nf">mean_level_spacing</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Calculates the mean-level spacing of an energy spectrum.</span>

<span class="sd">	See mean level spacing, :math:`\\langle\\tilde r_\mathrm{W}\\rangle`, in </span>
<span class="sd">	`arXiv:1212.5611 &lt;https://arxiv.org/pdf/1212.5611.pdf/&gt;`_ for more details.</span>

<span class="sd">	For Wigner-Dyson statistics, we have :math:`\\langle\\tilde r_\mathrm{W}\\rangle\\approx 0.53`, while</span>
<span class="sd">	for Poisson statistics: :math:`\\langle\\tilde r_\mathrm{W}\\rangle\\approx 0.38`.</span>

<span class="sd">	Examples</span>
<span class="sd">	--------</span>

<span class="sd">	The following example shows how to calculate the mean level spacing :math:`\\langle\\tilde r_\mathrm{W}\\rangle` for the</span>
<span class="sd">	spectrum of the ergodic Hamiltonian :math:`H_1=\\sum_jJ S^z_{j+1}S^z + hS^x_j + g S^z_j`.</span>
<span class="sd">	</span>
<span class="sd">	.. literalinclude:: ../../doc_examples/mean_level_spacing-example.py</span>
<span class="sd">		:linenos:</span>
<span class="sd">		:language: python</span>
<span class="sd">		:lines: 7-</span>

<span class="sd">	Parameters</span>
<span class="sd">	-----------</span>
<span class="sd">	E : numpy.ndarray</span>
<span class="sd">		Ordered list of ascending, NONdegenerate energies.</span>

<span class="sd">	Returns</span>
<span class="sd">	-------- </span>
<span class="sd">	float</span>
<span class="sd">		mean-level spacing.</span>

<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
		<span class="n">E</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">!=</span><span class="n">E</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting a sorted list of ascending, nondegenerate eigenenergies &#39;E&#39;.&quot;</span><span class="p">)</span>

	<span class="c1"># compute consecutive E-differences</span>
	<span class="n">sn</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
	<span class="c1"># check for degeneracies</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">E</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Degeneracies found in spectrum &#39;E&#39;!&quot;</span><span class="p">)</span>
	<span class="c1"># calculate the ratios of consecutive spacings</span>
	<span class="n">aux</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

	<span class="n">aux</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sn</span>
	<span class="n">aux</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span> <span class="n">aux</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">aux</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span></div>


<span class="c1">##### below are the routines for arbitary user-defimed time evolution.</span>

<div class="viewcode-block" id="evolve"><a class="viewcode-back" href="../../../generated/quspin.tools.measurements.evolve.html#quspin.tools.measurements.evolve">[docs]</a><span class="k">def</span> <span class="nf">evolve</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">solver_name</span><span class="o">=</span><span class="s2">&quot;dop853&quot;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">stack_state</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">imag_time</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">iterate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">f_params</span><span class="o">=</span><span class="p">(),</span><span class="o">**</span><span class="n">solver_args</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Implements (imaginary) time evolution for a user-defined first-order ODE.</span>

<span class="sd">	The function can be used to study nonlinear semiclassical dynamics. It can also serve as a pre-configured </span>
<span class="sd">	ODE solver in python, without any relation to other QuSpin objects.</span>

<span class="sd">	Examples</span>
<span class="sd">	--------</span>

<span class="sd">	The following example shows how to use the`evolve()` function to solve the periodically-driven </span>
<span class="sd">	Gross-Pitaevskii equation (GPE) on a one-imensional lattice. The GPE has a linear part, comprising the</span>
<span class="sd">	kinetic energy and the external potentials (e.g. a harmonic trap), and a nonlinear part which describes</span>
<span class="sd">	the interactions.</span>

<span class="sd">	Below, in a few steps we show how to use the functionality of the `evolve()` function to solve the GPE </span>
<span class="sd">	on a one-dimensional lattice for periodically-driven particles in a harmonic trap:</span>

<span class="sd">	.. math::</span>
<span class="sd">		i\\dot\\varphi_j(t) = -J\\left( e^{-iA\\sin\\Omega t}\\varphi_{j-1}(t) + e^{+iA\\sin\\Omega t}\\varphi_{j+1}(t) \\right) + \\kappa_\\mathrm{trap}\\varphi_j(t) + U|\\varphi_j(t)|^2\\varphi_j(t)</span>

<span class="sd">	where :math:`j` labels the lattice sites, :math:`J` is the lattice hopping amplitude, :math:`\\kappa_\\mathrm{trap}` is</span>
<span class="sd">	the strength of the harmonic trap, and :math:`U` -- the mean-field interaction.</span>

<span class="sd">	Let us start by defining the single-particle Hamiltonian :math:`H(t)`.</span>


<span class="sd">	.. literalinclude:: ../../doc_examples/evolve-example.py</span>
<span class="sd">		:linenos:</span>
<span class="sd">		:language: python</span>
<span class="sd">		:lines: 7-47</span>

<span class="sd">	Next, we define the GPE </span>

<span class="sd">	.. math::</span>
<span class="sd">		-i\\dot\\varphi(t) = H(t)\\varphi(t) + U |\\varphi(t)|^2 \\varphi(t)</span>

<span class="sd">	and solve it using `evolve()`:</span>

<span class="sd">	.. literalinclude:: ../../doc_examples/evolve-example.py</span>
<span class="sd">		:linenos:</span>
<span class="sd">		:language: python</span>
<span class="sd">		:lines: 49-61</span>
<span class="sd">		:lineno-start: 43</span>

<span class="sd">	Since the GPE is a complex-valued equation, the above code requires the use of a complex-valued ODE solver </span>
<span class="sd">	[which is done by `evolve()` under the hood, so long as no solver is explicitly specified].</span>

<span class="sd">	An alternative way </span>
<span class="sd">	to solve the GPE using a real-valued solver might be useful to speed-up the computation. This can be achieved </span>
<span class="sd">	by decomposing the condensate wave function into a real and imaginary part, and proceeds as follows:</span>
<span class="sd">	</span>
<span class="sd">	The goal is to solve: </span>
<span class="sd">	</span>
<span class="sd">	.. math::</span>
<span class="sd">		-i\\dot\\varphi(t) = H(t)\\varphi(t) + U |\\varphi(t)|^2 \\varphi(t)</span>
<span class="sd">	</span>
<span class="sd">	for the complex-valued :math:`\\varphi(t)` by re-writing it as a real-valued vector `phi=[u,v]` where </span>
<span class="sd">	:math:`\\varphi(t) = u(t) + iv(t)`. The real and imaginary parts, :math:`u(t)` and :math:`v(t)`, have the same dimension as </span>
<span class="sd">	:math:`\phi(t)`.</span>
<span class="sd">	</span>
<span class="sd">	In the most general form, the single-particle Hamiltonian can be decomposed as </span>
<span class="sd">	:math:`H(t)= H_{stat} + f(t)H_{dyn}`, with a complex-valued driving function :math:`f(t)`. Then, the GPE can be cast in </span>
<span class="sd">	the following real-valued form:</span>
<span class="sd">	</span>
<span class="sd">	.. math::</span>
<span class="sd">		\\dot u(t) = +\\left[H_{stat} + U\\left(|u(t)|^2 + |v(t)|^2\\right) \\right]v(t) + Re[f(t)]H_{dyn}v(t) + Im[f(t)]H_{dyn}u(t)</span>
<span class="sd">	.. math::	</span>
<span class="sd">		\\dot v(t) = -\\left[H_{stat} + U\\left(|u(t)|^2 + |v(t)|^2\\right) \\right]u(t) - Re[f(t)]H_{dyn}u(t) + Im[f(t)]H_{dyn}v(t)</span>


<span class="sd">	.. literalinclude:: ../../doc_examples/evolve-example.py</span>
<span class="sd">		:linenos:</span>
<span class="sd">		:language: python</span>
<span class="sd">		:lines: 63-</span>
<span class="sd">		:lineno-start: 59</span>

<span class="sd">	The flag `stack_state=True` is required for `evolve()` to handle the complex-valued initial condition properly,</span>
<span class="sd">	as well as to put together the output solution as a complex-valued vector in the end. Since the real-valued ODE solver </span>
<span class="sd">	allows to parse ODE parameters, we can include them in the user-defined ODE function and use the </span>
<span class="sd">	flag `f_params`. Notice the elegant way python allows one to circumvent the usage of this variable in the </span>
<span class="sd">	complex-valued example above. </span>

<span class="sd">	Parameters</span>
<span class="sd">	-----------</span>
<span class="sd">	v0 : numpy.ndarray</span>
<span class="sd">		Initial state.</span>
<span class="sd">	t0 : float</span>
<span class="sd">		Initial time.</span>
<span class="sd">	times : numpy.ndarray</span>
<span class="sd">		Vector of times to compute the time-evolved state at.</span>
<span class="sd">	f : :obj:`function`</span>
<span class="sd">		User-defined function to solve first-order ODE (see Examples):</span>

<span class="sd">		.. math::</span>
<span class="sd">			v&#39;(t) = f(v(t),t)\\qquad v(t_0)=v_0</span>
<span class="sd">	f_params : tuple, optional</span>
<span class="sd">		A tuple to pass all parameters of the function `f` to ODE solver. Default is `f_params=()`.</span>
<span class="sd">	iterate : bool, optional</span>
<span class="sd">		If set to `True`, creates a generator object for the time-evolved the state. Default is `False`.</span>
<span class="sd">	solver_name : str, optional</span>
<span class="sd">		Scipy solver integrator name. Default is `dop853`. </span>

<span class="sd">		See `scipy integrator (solver) &lt;https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.integrate.ode.html/&gt;`_ for other options.</span>
<span class="sd">	solver_args : dict, optional</span>
<span class="sd">		Dictionary with additional `scipy integrator (solver) &lt;https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.integrate.ode.html/&gt;`_ arguments.	</span>
<span class="sd">	real : bool, optional </span>
<span class="sd">		Flag to determine if `f` is real or complex-valued. Default is `False`.</span>
<span class="sd">	imag_time : bool, optional</span>
<span class="sd">		Must be set to `True` when `f` defines imaginary-time evolution, in order to normalise the state </span>
<span class="sd">		at each time in `times`. Default is `False`.</span>
<span class="sd">	stack_state : bool, optional</span>
<span class="sd">		If `f` is written to take care of real and imaginary parts separately (see Examples), this flag </span>
<span class="sd">		will return a single complex-valued solution instead of the real and imaginary parts separately.</span>
<span class="sd">		Default is `False`.</span>
<span class="sd">	verbose : bool, optional</span>
<span class="sd">		If set to `True`, prints normalisation of state at teach time in `times`.</span>

<span class="sd">	Returns</span>
<span class="sd">	--------</span>
<span class="sd">	obj</span>
<span class="sd">		Can be either one of the following:</span>
<span class="sd">			* numpy.ndarray containing evolved state against time.</span>
<span class="sd">			* generator object for time-evolved state (requires `iterate = True`).</span>
<span class="sd">		</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="k">import</span> <span class="n">complex_ode</span>
	<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="k">import</span> <span class="n">ode</span>

	<span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;state mush have ndim &lt; 3.&quot;</span><span class="p">)</span>

	<span class="n">shape0</span> <span class="o">=</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span>

	<span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
			<span class="n">v0</span> <span class="o">=</span> <span class="n">v0</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
	 
	
	<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;times must be real number(s).&quot;</span><span class="p">)</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span> <span class="c1"># needed for imaginary time to preserve the proper norm of the state. </span>

	<span class="k">if</span> <span class="n">stack_state</span><span class="p">:</span>
		<span class="n">v1</span> <span class="o">=</span> <span class="n">v0</span>
		<span class="n">v0</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">shape0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">v1</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
		<span class="n">v0</span><span class="p">[:</span><span class="n">shape0</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">v1</span><span class="o">.</span><span class="n">real</span>
		<span class="n">v0</span><span class="p">[</span><span class="n">shape0</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">v1</span><span class="o">.</span><span class="n">imag</span>

		<span class="n">solver</span> <span class="o">=</span> <span class="n">ode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="c1"># y_f = f(t,y,*args)</span>
	<span class="k">elif</span> <span class="n">real</span><span class="p">:</span>
		<span class="n">solver</span> <span class="o">=</span> <span class="n">ode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="c1"># y_f = f(t,y,*args)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">solver</span> <span class="o">=</span> <span class="n">complex_ode</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="c1"># y_f = f(t,y,*args)</span>

	<span class="k">if</span> <span class="n">solver_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;dop853&quot;</span><span class="p">,</span><span class="s2">&quot;dopri5&quot;</span><span class="p">]:</span>
		<span class="k">if</span> <span class="n">solver_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nsteps&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">solver_args</span><span class="p">[</span><span class="s2">&quot;nsteps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
		<span class="k">if</span> <span class="n">solver_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rtol&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">solver_args</span><span class="p">[</span><span class="s2">&quot;rtol&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="n">E</span><span class="o">-</span><span class="mi">9</span>
		<span class="k">if</span> <span class="n">solver_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;atol&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">solver_args</span><span class="p">[</span><span class="s2">&quot;atol&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="n">E</span><span class="o">-</span><span class="mi">9</span>


	<span class="n">solver</span><span class="o">.</span><span class="n">set_integrator</span><span class="p">(</span><span class="n">solver_name</span><span class="p">,</span><span class="o">**</span><span class="n">solver_args</span><span class="p">)</span>
	<span class="n">solver</span><span class="o">.</span><span class="n">set_f_params</span><span class="p">(</span><span class="o">*</span><span class="n">f_params</span><span class="p">)</span>
	<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_value</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
		<span class="k">return</span> <span class="n">_evolve_scalar</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">stack_state</span><span class="p">,</span><span class="n">imag_time</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">shape0</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">iterate</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">_evolve_iter</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">verbose</span><span class="p">,</span><span class="n">stack_state</span><span class="p">,</span><span class="n">imag_time</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">shape0</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">_evolve_list</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">verbose</span><span class="p">,</span><span class="n">stack_state</span><span class="p">,</span><span class="n">imag_time</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">shape0</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_evolve_scalar</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">stack_state</span><span class="p">,</span><span class="n">imag_time</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">shape0</span><span class="p">):</span>
	<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="k">import</span> <span class="n">norm</span>
	<span class="n">Ns</span><span class="o">=</span><span class="n">shape0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

	<span class="k">if</span> <span class="n">time</span> <span class="o">==</span> <span class="n">t0</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">stack_state</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">v0</span><span class="p">[:</span><span class="n">Ns</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">v0</span><span class="p">[</span><span class="n">Ns</span><span class="p">:])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>

	<span class="n">solver</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="n">successful</span><span class="p">():</span>
		<span class="k">if</span> <span class="n">imag_time</span><span class="p">:</span> <span class="n">solver</span><span class="o">.</span><span class="n">_y</span> <span class="o">/=</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">stack_state</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">y</span><span class="p">[:</span><span class="n">Ns</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">solver</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">Ns</span><span class="p">:])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;failed to evolve to time </span><span class="si">{0}</span><span class="s2">, nsteps might be too small&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>	

<span class="k">def</span> <span class="nf">_evolve_list</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">verbose</span><span class="p">,</span><span class="n">stack_state</span><span class="p">,</span><span class="n">imag_time</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">shape0</span><span class="p">):</span>
	<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="k">import</span> <span class="n">norm</span>

	<span class="n">Ns</span><span class="o">=</span><span class="n">shape0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape0</span><span class="o">+</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
	
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>

		<span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">t0</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;evolved to time </span><span class="si">{0}</span><span class="s2">, norm of state </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">y</span><span class="p">)))</span>
			<span class="k">if</span> <span class="n">stack_state</span><span class="p">:</span>
				<span class="n">v</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v0</span><span class="p">[:</span><span class="n">Ns</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">v0</span><span class="p">[</span><span class="n">Ns</span><span class="p">:])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">v</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>
			<span class="k">continue</span>

		<span class="n">solver</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="n">successful</span><span class="p">():</span>
			<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;evolved to time </span><span class="si">{0}</span><span class="s2">, norm of state </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">y</span><span class="p">)))</span>
			<span class="k">if</span> <span class="n">imag_time</span><span class="p">:</span> <span class="n">solver</span><span class="o">.</span><span class="n">_y</span> <span class="o">/=</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">stack_state</span><span class="p">:</span>
				<span class="n">v</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">y</span><span class="p">[:</span><span class="n">Ns</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">solver</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">Ns</span><span class="p">:])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">v</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;failed to evolve to time </span><span class="si">{0}</span><span class="s2">, nsteps might be too small&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
			

	<span class="k">return</span> <span class="n">v</span>

<span class="k">def</span> <span class="nf">_evolve_iter</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">verbose</span><span class="p">,</span><span class="n">stack_state</span><span class="p">,</span><span class="n">imag_time</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">shape0</span><span class="p">):</span>
	<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="k">import</span> <span class="n">norm</span>
	<span class="n">Ns</span><span class="o">=</span><span class="n">shape0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


	<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">t0</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;evolved to time </span><span class="si">{0}</span><span class="s2">, norm of state </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">y</span><span class="p">)))</span>
			<span class="k">if</span> <span class="n">stack_state</span><span class="p">:</span>
				<span class="k">yield</span> <span class="p">(</span><span class="n">v0</span><span class="p">[:</span><span class="n">Ns</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">v0</span><span class="p">[</span><span class="n">Ns</span><span class="p">:])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">yield</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>
			<span class="k">continue</span>
			

		<span class="n">solver</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="n">successful</span><span class="p">():</span>
			<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;evolved to time </span><span class="si">{0}</span><span class="s2">, norm of state </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">y</span><span class="p">)))</span>
			<span class="k">if</span> <span class="n">imag_time</span><span class="p">:</span> <span class="n">solver</span><span class="o">.</span><span class="n">_y</span> <span class="o">/=</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">stack_state</span><span class="p">:</span>
				<span class="k">yield</span> <span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">y</span><span class="p">[:</span><span class="n">Ns</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">solver</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">Ns</span><span class="p">:])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">yield</span> <span class="n">solver</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;failed to evolve to time </span><span class="si">{0}</span><span class="s2">, nsteps might be too small&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

<span class="c1">##### private functions</span>

<span class="k">def</span> <span class="nf">_ent_entropy</span><span class="p">(</span><span class="n">system_state</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">chain_subsys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">density</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">subsys_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">DM</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">svd_return_vec</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span><span class="kc">False</span><span class="p">,</span><span class="kc">False</span><span class="p">]):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This function calculates the entanglement entropy of a lattice quantum subsystem based on the Singular Value Decomposition (svd). The entanglement entropy is NORMALISED by the size of the</span>
<span class="sd">	reduced subsystem. </span>

<span class="sd">	RETURNS:	dictionary with keys:</span>

<span class="sd">	&#39;Sent&#39;: entanglement entropy.</span>

<span class="sd">	&#39;DM_chain_subsys&#39;: (optional) reduced density matrix of chain subsystem.</span>

<span class="sd">	&#39;DM_other_subsys&#39;: (optional) reduced density matrix of the complement subsystem.</span>

<span class="sd">	&#39;U&#39;: (optional) svd U matrix</span>

<span class="sd">	&#39;V&#39;: (optional) svd V matrix</span>

<span class="sd">	&#39;lmbda&#39;: (optional) svd singular values</span>

<span class="sd">	--- arguments ---</span>

<span class="sd">	system_state: (required) the state of the quantum system. Can be a:</span>

<span class="sd">				-- pure state [numpy array of shape (Ns,)].</span>

<span class="sd">				-- density matrix (DM) [numpy array of shape (Ns,Ns)].</span>

<span class="sd">				-- diagonal DM [dictionary {&#39;V_rho&#39;: V_rho, &#39;rho_d&#39;: rho_d} containing the diagonal DM</span>
<span class="sd">					rho_d [numpy array of shape (Ns,)] and its eigenbasis in the columns of V_rho</span>
<span class="sd">					[numpy arary of shape (Ns,Ns)]. The keys CANNOT be chosen arbitrarily.].</span>

<span class="sd">				-- a collection of states [dictionary {&#39;V_states&#39;:V_states}] containing the states</span>
<span class="sd">					in the columns of V_states [shape (Ns,Nvecs)]</span>

<span class="sd">	basis: (required) the basis used to build &#39;system_state&#39;. Must be an instance of &#39;photon_basis&#39;,</span>
<span class="sd">				&#39;spin_basis_1d&#39;, &#39;fermion_basis_1d&#39;, &#39;boson_basis_1d&#39;. </span>

<span class="sd">	chain_subsys: (optional) a list of lattice sites to specify the chain subsystem. Default is</span>

<span class="sd">				-- [0,1,...,N/2-1,N/2] for &#39;spin_basis_1d&#39;, &#39;fermion_basis_1d&#39;, &#39;boson_basis_1d&#39;.</span>

<span class="sd">				-- [0,1,...,N-1,N] for &#39;photon_basis&#39;.</span>

<span class="sd">	DM: (optional) String to enable the calculation of the reduced density matrix. Available options are</span>

<span class="sd">				-- &#39;chain_subsys&#39;: calculates the reduced DM of the subsystem &#39;chain_subsys&#39; and</span>
<span class="sd">					returns it under the key &#39;DM_chain_subsys&#39;.</span>

<span class="sd">				-- &#39;other_subsys&#39;: calculates the reduced DM of the complement of &#39;chain_subsys&#39; and</span>
<span class="sd">					returns it under the key &#39;DM_other_subsys&#39;.</span>

<span class="sd">				-- &#39;both&#39;: calculates and returns both density matrices as defined above.</span>

<span class="sd">				Default is &#39;False&#39;. 	</span>

<span class="sd">	alpha: (optional) Renyi alpha parameter. Default is &#39;1.0&#39;. When alpha is different from unity,</span>
<span class="sd">				the _entropy keys have attached &#39;_Renyi&#39; to their label.</span>

<span class="sd">	density: (optional) if set to &#39;True&#39;, the entanglement _entropy is normalised by the size of the</span>
<span class="sd">				subsystem [i.e., by the length of &#39;chain_subsys&#39;]. Detault is &#39;False&#39;.</span>

<span class="sd">	subsys_ordering: (optional) if set to &#39;True&#39;, &#39;chain_subsys&#39; is being ordered. Default is &#39;True&#39;.</span>

<span class="sd">	svd_return_vec: (optional) list of three booleans to return Singular Value Decomposition (svd) </span>
<span class="sd">				parameters:</span>

<span class="sd">				-- [True, . , . ] returns the svd matrix &#39;U&#39;.</span>

<span class="sd">				-- [ . ,True, . ] returns the singular values &#39;lmbda&#39;.</span>

<span class="sd">				-- [ . , . ,True] returns the svd matrix &#39;V&#39;.</span>

<span class="sd">				Any combination of the above is possible. Default is [False,False,False].</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="c1"># initiate variables</span>
	<span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Sent&quot;</span><span class="p">]</span>

	<span class="k">if</span> <span class="n">DM</span><span class="o">==</span><span class="s1">&#39;chain_subsys&#39;</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_chain_subsys&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">svd_return_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">DM</span><span class="o">==</span><span class="s1">&#39;other_subsys&#39;</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_other_subsys&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">svd_return_vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">DM</span><span class="o">==</span><span class="s1">&#39;both&#39;</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_chain_subsys&quot;</span><span class="p">)</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DM_other_subsys&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">svd_return_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">svd_return_vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">DM</span> <span class="ow">and</span> <span class="n">DM</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;chain_subsys&#39;</span><span class="p">,</span><span class="s1">&#39;other_subsys&#39;</span><span class="p">,</span><span class="s1">&#39;both&#39;</span><span class="p">]:</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unexpected keyword argument for &#39;DM&#39;!&quot;</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">svd_return_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;lmbda&#39;</span><span class="p">)</span>
	
	

	<span class="c1"># calculate reshaped system_state</span>
	<span class="n">v</span><span class="p">,</span> <span class="n">rho_d</span><span class="p">,</span> <span class="n">N_A</span> <span class="o">=</span> <span class="n">_reshape_as_subsys</span><span class="p">(</span><span class="n">system_state</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">chain_subsys</span><span class="o">=</span><span class="n">chain_subsys</span><span class="p">,</span><span class="n">subsys_ordering</span><span class="o">=</span><span class="n">subsys_ordering</span><span class="p">)</span>
	<span class="k">del</span> <span class="n">system_state</span>
	
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This function has room for improvement: if only DM is requested, it can be obtained by</span>
<span class="sd">	DM_chain_subsys = v[0].dot(v[0].T)</span>
<span class="sd">	DM_other_subsys = v[0].T.dot(v[0])</span>
<span class="sd">	so there&#39;s NO NEED for an SVD!!!</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">if</span> <span class="n">DM</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">rho_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rho_d</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="p">(</span><span class="mi">1</span><span class="p">,):</span> <span class="c1"># need DM for Sent of a mixed system_state</span>
			<span class="n">U</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			<span class="n">DM_chain_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;n,nij,nj,nkj-&gt;ik&#39;</span><span class="p">,</span><span class="n">rho_d</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">U</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="p">)</span>
			<span class="n">DM</span><span class="o">=</span><span class="s1">&#39;chain_subsys&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">lmbda</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">DM</span> <span class="o">==</span> <span class="s1">&#39;chain_subsys&#39;</span><span class="p">:</span>
		<span class="n">U</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">rho_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">DM_chain_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;n,nij,nj,nkj-&gt;ik&#39;</span><span class="p">,</span><span class="n">rho_d</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">U</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">DM_chain_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;nij,nj,nkj-&gt;nik&#39;</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">U</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="p">)</span>
	<span class="k">elif</span> <span class="n">DM</span> <span class="o">==</span> <span class="s1">&#39;other_subsys&#39;</span><span class="p">:</span>
		<span class="n">_</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">rho_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">DM_other_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;n,nji,nj,njk-&gt;ik&#39;</span><span class="p">,</span><span class="n">rho_d</span><span class="p">,</span><span class="n">V</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">V</span> <span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">DM_other_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;nji,nj,njk-&gt;nik&#39;</span><span class="p">,</span><span class="n">V</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">V</span> <span class="p">)</span>
	<span class="k">elif</span> <span class="n">DM</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
		<span class="n">U</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">rho_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">DM_chain_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;n,nij,nj,nkj-&gt;ik&#39;</span><span class="p">,</span><span class="n">rho_d</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">U</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="p">)</span>
			<span class="n">DM_other_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;n,nji,nj,njk-&gt;ik&#39;</span><span class="p">,</span><span class="n">rho_d</span><span class="p">,</span><span class="n">V</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">V</span> <span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">DM_chain_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;nij,nj,nkj-&gt;nik&#39;</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">U</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="p">)</span>
			<span class="n">DM_other_subsys</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;nji,nj,njk-&gt;nik&#39;</span><span class="p">,</span><span class="n">V</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">lmbda</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">V</span> <span class="p">)</span>

	<span class="k">del</span> <span class="n">v</span>

	<span class="c1"># calculate singular values of reduced DM and the corresponding probabilities</span>
	<span class="k">if</span> <span class="n">rho_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rho_d</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
		<span class="c1"># diagonalise reduced DM</span>
		<span class="k">if</span> <span class="n">DM</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;chain_subsys&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">]:</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">DM_chain_subsys</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">DM</span> <span class="o">==</span> <span class="s1">&#39;other_subsys&#39;</span><span class="p">:</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">_npla</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">DM_other_subsys</span><span class="p">)</span>
			
		<span class="k">if</span> <span class="n">svd_return_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># if lmdas requested by user</span>
			<span class="n">lmbda</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
	<span class="k">else</span><span class="p">:</span><span class="c1"># calculate probabilities</span>
		<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">lmbda</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
	
	<span class="c1"># add floating point number to zero elements</span>
	<span class="n">p</span><span class="p">[</span><span class="n">p</span><span class="o">&lt;=</span><span class="mi">1</span><span class="n">E</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
		
	<span class="c1"># calculate entanglement _entropy of &#39;system_state&#39;</span>
	<span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
		<span class="n">Sent</span> <span class="o">=</span> <span class="o">-</span><span class="n">_np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">p</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">Sent</span> <span class="o">=</span>  <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">alpha</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
	
	<span class="k">if</span> <span class="n">density</span><span class="p">:</span>
		<span class="n">Sent</span> <span class="o">/=</span> <span class="n">N_A</span>

	<span class="c1"># store variables to dictionar</span>
	<span class="n">return_dict</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
		<span class="n">return_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span>

	<span class="k">return</span> <span class="n">return_dict</span>

<span class="k">def</span> <span class="nf">_reshape_as_subsys</span><span class="p">(</span><span class="n">system_state</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">chain_subsys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">subsys_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This function reshapes an input state (or matrix with &#39;Nstates&#39; initial states) into an array of</span>
<span class="sd">	the shape (Nstates,Ns_subsys,Ns_other) with &#39;Ns_subsys&#39; and &#39;Ns_other&#39; the Hilbert space dimensions</span>
<span class="sd">	of the subsystem and its complement, respectively.</span>

<span class="sd">	RETURNS:	reshaped state, </span>
<span class="sd">				vector with eigenvalues of the DM associated with the initial state, </span>
<span class="sd">				subsystem size</span>

<span class="sd">	--- arguments ---</span>

<span class="sd">	system_state: (required) the state of the quantum system. Can be a:</span>

<span class="sd">				-- pure state [numpy array of shape (1,) or (,1)].</span>

<span class="sd">				-- density matrix (DM) [numpy array of shape (1,1)].</span>

<span class="sd">				-- diagonal DM [dictionary {&#39;V_rho&#39;: V_rho, &#39;rho_d&#39;: rho_d} containing the diagonal DM</span>
<span class="sd">					rho_d [numpy array of shape (1,) or (,1)] and its eigenbasis in the columns of V_rho</span>
<span class="sd">					[numpy arary of shape (1,1)]. The keys are CANNOT be chosen arbitrarily. &#39;rho_d&#39;</span>
<span class="sd">					can be &#39;None&#39;, but needs to always be passed.</span>

<span class="sd">				-- a collection of states [dictionary {&#39;V_states&#39;:V_states}] containing the states</span>
<span class="sd">					in the columns of V_states [shape (Ns,Nvecs)]</span>

<span class="sd">	basis: (required) the basis used to build &#39;system_state&#39;. Must be an instance of &#39;photon_basis&#39;,</span>
<span class="sd">				&#39;spin_basis_1d&#39;, &#39;fermion_basis_1d&#39;, &#39;boson_basis_1d&#39;. </span>

<span class="sd">	chain_subsys: (optional) a list of lattice sites to specify the chain subsystem. Default is</span>

<span class="sd">				-- [0,1,...,N/2-1,N/2] for &#39;spin_basis_1d&#39;, &#39;fermion_basis_1d&#39;, &#39;boson_basis_1d&#39;.</span>

<span class="sd">				-- [0,1,...,N-1,N] for &#39;photon_basis&#39;. </span>

<span class="sd">	subsys_ordering: (optional) if set to &#39;True&#39;, &#39;chain_subsys&#39; is being ordered. Default is &#39;True&#39;. </span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">try</span><span class="p">:</span>
		<span class="n">N</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">N</span>
	<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
		<span class="n">N</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">particle_N</span>



	<span class="k">if</span> <span class="n">chain_subsys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">chain_subsys</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)]</span>
		<span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting iterable for for &#39;chain_subsys&#39;!&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting a nonempty iterable for &#39;chain_subsys&#39;!&quot;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;subsys&#39; must be contain nonnegative numbers!&quot;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">max</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;subsys&#39; contains sites exceeding the total lattice site number!&quot;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;subsys&#39; cannot contain repeating site indices!&quot;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">_np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">),</span><span class="n">_np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">chain_subsys</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;subsys&#39; must iterable of integers with values in {0,...,L-1}!&quot;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">subsys_ordering</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">))</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span><span class="o">!=</span><span class="n">chain_subsys</span><span class="p">:</span>
				<span class="c1"># if chain subsys is def with unordered sites, order them</span>
				<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;subsys&#39; </span><span class="si">{}</span><span class="s2"> contains non-ordered sites. &#39;subsys&#39; re-ordered! To change default set &#39;subsys_ordering = False&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">),</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
				<span class="n">chain_subsys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span>

	
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">system_state</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
		<span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">system_state</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
		<span class="k">if</span> <span class="n">keys</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;V_rho&#39;</span><span class="p">,</span><span class="s1">&#39;rho_d&#39;</span><span class="p">]):</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;DM&#39;</span>
			<span class="c1"># define initial state</span>
			<span class="n">rho_d</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;rho_d&#39;</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">rho_d</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">,):</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting a 1d array &#39;rho_d&#39; of size </span><span class="si">{}</span><span class="s2">!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">))</span>
			<span class="k">elif</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rho_d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting positive eigenvalues for &#39;rho_d&#39;!&quot;</span><span class="p">)</span>
			<span class="n">psi</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;V_rho&#39;</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">psi</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting a 2d array &#39;V_rho&#39; of size (</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">)!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">))</span>
		<span class="k">elif</span> <span class="n">keys</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;V_states&#39;</span><span class="p">]):</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;pure&#39;</span>
			<span class="n">rho_d</span> <span class="o">=</span> <span class="kc">None</span>
			<span class="n">psi</span> <span class="o">=</span> <span class="n">system_state</span><span class="p">[</span><span class="s1">&#39;V_states&#39;</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting dictionary with keys [&#39;V_rho&#39;,&#39;rho_d&#39;] or [&#39;V_states&#39;]&quot;</span><span class="p">)</span>


		<span class="k">if</span> <span class="n">_sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">system_state</span><span class="p">):</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;ent_entropy function only handles numpy.ndarrays, sparse matrix will be comverted to dense matrix.&quot;</span><span class="p">,</span><span class="ne">UserWarning</span><span class="p">,</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
			<span class="n">system_state</span> <span class="o">=</span> <span class="n">system_state</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">system_state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">system_state</span> <span class="o">=</span> <span class="n">system_state</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

		<span class="k">elif</span> <span class="n">system_state</span><span class="o">.</span><span class="n">__class__</span> <span class="ow">not</span> <span class="ow">in</span>  <span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">matrix</span><span class="p">]:</span>
			<span class="n">system_state</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">system_state</span><span class="p">)</span>


		<span class="k">if</span> <span class="n">psi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting ndim == 2 for V_states.&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">psi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;V_states shape </span><span class="si">{0}</span><span class="s2"> not compatible with basis size: </span><span class="si">{1}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">))</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">_sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">system_state</span><span class="p">):</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;ent_entropy function only handles numpy.ndarrays, sparse matrix will be comverted to dense matrix.&quot;</span><span class="p">,</span><span class="ne">UserWarning</span><span class="p">,</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
			<span class="n">system_state</span> <span class="o">=</span> <span class="n">system_state</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">system_state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">system_state</span> <span class="o">=</span> <span class="n">system_state</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
		<span class="k">elif</span> <span class="n">system_state</span><span class="o">.</span><span class="n">__class__</span> <span class="ow">not</span> <span class="ow">in</span>  <span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">matrix</span><span class="p">]:</span>
			<span class="n">system_state</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">system_state</span><span class="p">)</span>

			


		<span class="k">if</span> <span class="n">system_state</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># pure state</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;pure&#39;</span>
			<span class="c1"># define initial state</span>
			<span class="n">psi</span> <span class="o">=</span> <span class="n">system_state</span>
			<span class="n">rho_d</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,(</span><span class="mi">1</span><span class="p">,))</span>
		<span class="k">elif</span> <span class="n">system_state</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># DM</span>
			<span class="k">if</span> <span class="n">system_state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">system_state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting square array for Density Matrix.&quot;</span><span class="p">)</span>
			<span class="n">istate</span> <span class="o">=</span> <span class="s1">&#39;DM&#39;</span>
			<span class="c1"># diagonalise DM</span>
			<span class="n">rho_d</span><span class="p">,</span> <span class="n">psi</span> <span class="o">=</span> <span class="n">_la</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">system_state</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rho_d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rho_d</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="n">E3</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">rho_d</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting DM to have positive spectrum&quot;</span><span class="p">)</span>
			<span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">_np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rho_d</span><span class="p">)</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="n">E3</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">rho_d</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting eigenvalues of DM to sum to unity!&quot;</span><span class="p">)</span>
			<span class="n">rho_d</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rho_d</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">psi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;V_states shape </span><span class="si">{0}</span><span class="s2"> not compatible with basis size: </span><span class="si">{1}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">))</span>			
			


	<span class="c1"># clear up memory</span>
	<span class="k">del</span> <span class="n">system_state</span>


	<span class="c1"># define number of participating states in &#39;system_state&#39;</span>
	<span class="n">Ns</span> <span class="o">=</span> <span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">,]</span><span class="o">.</span><span class="n">size</span>

	<span class="k">if</span> <span class="n">basis</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">[:</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;spin&#39;</span><span class="p">,</span><span class="s1">&#39;boson&#39;</span><span class="p">,</span><span class="s1">&#39;fermion&#39;</span><span class="p">]:</span>

		<span class="c1"># set chain subsys if not defined</span>
		<span class="k">if</span> <span class="n">chain_subsys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="n">chain_subsys</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span> <span class="p">))</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Subsystem contains sites </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">),</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
		
	
		<span class="c1"># re-write the state in the initial basis</span>
		<span class="k">if</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="o">&lt;</span><span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="n">N</span><span class="p">:</span>
			<span class="n">psi</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">get_vec</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			
		<span class="c1">#calculate H-space dimensions of the subsystem and the system</span>
		<span class="n">N_A</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span>
		<span class="n">Ns_A</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="n">N_A</span>
		<span class="c1"># define lattice indices putting the subsystem to the left</span>
		<span class="n">system</span> <span class="o">=</span> <span class="n">chain_subsys</span><span class="p">[:]</span>
		<span class="p">[</span><span class="n">system</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">chain_subsys</span><span class="p">]</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		the algorithm for the entanglement _entropy of an arbitrary subsystem goes as follows </span>
<span class="sd">		for spin-1/2 and fermions [replace the onsite DOF (=2 below) with # states per site (basis.sps)]:</span>

<span class="sd">		1) the initial state psi has 2^N entries corresponding to the spin-z configs</span>
<span class="sd">		2) reshape psi into a 2x2x2x2x...x2 dimensional array (N products in total). Call this array v.</span>
<span class="sd">		3) v should satisfy the property that v[0,1,0,0,0,1,...,1,0], total of N entries, should give the entry of psi </span>
<span class="sd">		   along the the spin-z basis vector direction (0,1,0,0,0,1,...,1,0). This ensures a correspondence of the v-indices</span>
<span class="sd">		   (and thus the psi-entries) to the N lattice sites.</span>
<span class="sd">		4) fix the lattice sites that define the subsystem N_A, and reshuffle the array v according to this: e.g. if the </span>
<span class="sd">	 	   subsystem consistes of sites (k,l) then v should be reshuffled such that v[(k,l), (all other sites)]</span>
<span class="sd">	 	5) reshape v[(k,l), (all other sites)] into a 2D array of dimension ( N_A x N/N_A ) and proceed with the SVD as below  </span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">chain_subsys</span><span class="o">==</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">))):</span>
			<span class="c1"># chain_subsys sites come in consecutive order</span>
			<span class="c1"># define reshape tuple</span>
			<span class="n">reshape_tuple2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns</span><span class="p">,</span> <span class="n">Ns_A</span><span class="p">,</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="n">N</span><span class="o">//</span><span class="n">Ns_A</span><span class="p">)</span>
			<span class="c1"># reshape states</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">reshape_tuple2</span><span class="p">)</span>
			<span class="k">del</span> <span class="n">psi</span>
		<span class="k">else</span><span class="p">:</span> <span class="c1"># if chain_subsys not consecutive or staring site not [0]</span>
			<span class="c1"># performs 2) and 3)</span>
			<span class="c1"># update reshape tuple</span>
			<span class="n">reshape_tuple1</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">basis</span><span class="o">.</span><span class="n">sps</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>
			<span class="c1"># upadte axes dimensions</span>
			<span class="n">system</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">system</span><span class="p">]</span>
			<span class="n">system</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
			<span class="c1"># reshape states</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">reshape_tuple1</span><span class="p">)</span>
			<span class="k">del</span> <span class="n">psi</span>
			<span class="c1"># performs 4)</span>
			<span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
			<span class="c1"># performs 5)</span>
			<span class="n">reshape_tuple2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns</span><span class="p">,</span> <span class="n">Ns_A</span><span class="p">,</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="n">N</span><span class="o">//</span><span class="n">Ns_A</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">reshape_tuple2</span><span class="p">)</span>
			

	<span class="k">elif</span> <span class="n">basis</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">[:</span><span class="o">-</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;photon&#39;</span><span class="p">:</span>

		<span class="c1"># set chain subsys if not defined; </span>
		<span class="k">if</span> <span class="n">chain_subsys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="n">chain_subsys</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="p">))</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;subsystem set to the entire chain.&quot;</span><span class="p">,</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>


		<span class="c1">#calculate H-space dimensions of the subsystem and the system</span>
		<span class="n">N_A</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">)</span>
		<span class="n">Ns_A</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="n">N_A</span>

		<span class="c1"># define lattice indices putting the subsystem to the left</span>
		<span class="n">system</span> <span class="o">=</span> <span class="n">chain_subsys</span><span class="p">[:]</span>
		<span class="p">[</span><span class="n">system</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">chain_subsys</span><span class="p">]</span>
		
		<span class="c1"># re-write the state in the initial basis</span>
		<span class="k">if</span> <span class="n">basis</span><span class="o">.</span><span class="n">Nph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># no total particle conservation</span>
			<span class="n">Nph</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">Nph</span>
			<span class="k">if</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ns</span> <span class="o">&lt;</span> <span class="n">photon_Hspace_dim</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Ntot</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Nph</span><span class="p">):</span> <span class="c1">#chain symmetries present</span>
				<span class="k">if</span> <span class="n">N_A</span><span class="o">!=</span><span class="n">N</span><span class="p">:</span> <span class="c1"># doesn&#39;t make use of chain symmetries</span>
					<span class="n">psi</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">get_vec</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">full_part</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span> <span class="c1"># makes use of symmetries</span>
					<span class="n">Ns_chain</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">chain_Ns</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns_chain</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="n">N</span>

		<span class="k">elif</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ntot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># total particle-conservation</span>
			<span class="n">Nph</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ntot</span>
			<span class="k">if</span> <span class="n">basis</span><span class="o">.</span><span class="n">Ns</span> <span class="o">&lt;</span> <span class="n">photon_Hspace_dim</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Ntot</span><span class="p">,</span><span class="n">basis</span><span class="o">.</span><span class="n">Nph</span><span class="p">):</span> <span class="c1">#chain symmetries present</span>
				<span class="k">if</span> <span class="n">N_A</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="c1"># make use of symmetries</span>
					<span class="n">psi</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">get_vec</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">full_part</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
					<span class="n">Ns_chain</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">chain_Ns</span>
				<span class="k">else</span><span class="p">:</span> <span class="c1"># doesn&#39;t make use of symmetries</span>
					<span class="n">psi</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">get_vec</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">full_part</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
					<span class="n">Ns_chain</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="n">N</span>
			<span class="k">else</span><span class="p">:</span> <span class="c1"># no chain symmetries present</span>
				<span class="k">if</span> <span class="n">N_A</span><span class="o">==</span><span class="n">N</span><span class="p">:</span>
					<span class="n">psi</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">get_vec</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">full_part</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">psi</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">get_vec</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">full_part</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
				<span class="n">Ns_chain</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">chain_Ns</span>

		<span class="k">if</span> <span class="n">chain_subsys</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chain_subsys</span><span class="p">))):</span> 
			<span class="c1"># chain_subsys sites come in consecutive order or staring site not [0]</span>
			<span class="c1"># define reshape tuple</span>
			<span class="k">if</span> <span class="n">N_A</span><span class="o">==</span><span class="n">N</span><span class="p">:</span> <span class="c1"># chain_subsys equals entire lattice</span>
				<span class="n">reshape_tuple2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns</span><span class="p">,</span> <span class="n">Ns_chain</span><span class="p">,</span><span class="n">Nph</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span> <span class="c1">#chain_subsys is smaller than entire lattice</span>
				<span class="n">reshape_tuple2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns</span><span class="p">,</span> <span class="n">Ns_A</span><span class="p">,</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">N_A</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Nph</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">reshape_tuple2</span><span class="p">)</span>
			<span class="k">del</span> <span class="n">psi</span>
		<span class="k">else</span><span class="p">:</span> <span class="c1"># if chain_subsys not consecutive</span>
			<span class="c1"># performs 2) and 3)	</span>
			<span class="n">reshape_tuple1</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">basis</span><span class="o">.</span><span class="n">sps</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span> <span class="o">+</span> <span class="p">(</span><span class="n">Nph</span><span class="o">+</span><span class="mi">1</span><span class="p">,)</span>
			<span class="c1"># upadte axes dimensions</span>
			<span class="n">system</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">system</span><span class="p">]</span>
			<span class="n">system</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
			<span class="c1"># reshape states</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">reshape_tuple1</span><span class="p">)</span>
			<span class="k">del</span> <span class="n">psi</span>
			<span class="c1"># performs 4)</span>
			<span class="n">system</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">system</span><span class="p">))</span>
			<span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
			<span class="c1"># performs 5)</span>
			<span class="n">reshape_tuple2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ns</span><span class="p">,</span> <span class="n">Ns_A</span><span class="p">,</span> <span class="n">basis</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">N_A</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Nph</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">reshape_tuple2</span><span class="p">)</span>
				
	<span class="k">else</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;basis&#39; class </span><span class="si">{}</span><span class="s2"> not supported!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>

	<span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="n">rho_d</span><span class="p">,</span> <span class="n">N_A</span>

<span class="k">def</span> <span class="nf">_inf_time_obs</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">istate</span><span class="p">,</span><span class="n">Obs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">delta_t_Obs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">delta_q_Obs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">Sd_Renyi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">Srdm_Renyi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This function calculates various quantities (observables, fluctuations, entropies) written in the</span>
<span class="sd">	diagonal basis of a density matrix &#39;rho&#39;. See also documentation of &#39;Diagonal_Ensemble&#39;. The </span>
<span class="sd">	fuction is vectorised, meaning that &#39;rho&#39; can be an array containing the diagonal density matrices</span>
<span class="sd">	in the columns.</span>

<span class="sd">	RETURNS:	dictionary with keys corresponding to the observables</span>

<span class="sd">	--- variables --- </span>

<span class="sd">	istate: (required) type of initial state. Allowed strings are &#39;pure&#39;, &#39;DM&#39;, &#39;mixed&#39;, &#39;thermal&#39;.</span>

<span class="sd">	Obs: (optional) array of shape (,1) with the diagonal matrix elements of an observable in the basis</span>
<span class="sd">			where the density matrix &#39;rho&#39; is diagonal.</span>

<span class="sd">	delta_t_Obs: (optional) array of shape (1,1) containing the off-diagonal matrix elements of the </span>
<span class="sd">			square of an observable, to evaluate the infinite-time temporal fluctuations</span>

<span class="sd">	delta_q_Obs: (optional) array containing the diagonal elements (Obs^2)_{nn} - (Obs_{nn})^2 in the </span>
<span class="sd">			basis where the DM &#39;rho&#39; is diagonal. Evaluates the infinite-time quantum fluctuations.</span>

<span class="sd">	Sd_Renyi: (optional) when set to &#39;True&#39;, returns the key with diagonal density matrix of &#39;rho&#39;.</span>

<span class="sd">	Srdm_Renyi: (optional) (i,n) array containing the singular values of the i-th state of the eigenbasis</span>
<span class="sd">			of &#39;rho&#39;. Returns the key with the entanglement _entropy of &#39;rho&#39; reduced to a subsystem of</span>
<span class="sd">			given choice at infinite times.</span>

<span class="sd">	alpha: (optional) Renyi _entropy parameter. </span>
<span class="sd">	&quot;&quot;&quot;</span> 

	<span class="c1"># if Obs or deltaObs: parse V2</span>

	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="nb">complex</span><span class="p">)</span> <span class="ow">or</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Renyi parameter &#39;alpha&#39; must be real-valued and non-negative!&quot;</span><span class="p">)</span>

	<span class="n">istates</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;pure&#39;</span><span class="p">,</span> <span class="s1">&#39;DM&#39;</span><span class="p">,</span><span class="s1">&#39;mixed&#39;</span><span class="p">,</span><span class="s1">&#39;thermal&#39;</span><span class="p">]</span>
	<span class="k">if</span> <span class="n">istate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">istates</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Uknown type &#39;istate&#39; encountered! Try </span><span class="si">{}</span><span class="s2">!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">istates</span><span class="p">))</span>

	<span class="c1"># initiate observables dict</span>
	<span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>


	<span class="k">if</span> <span class="n">Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Obs_&quot;</span><span class="o">+</span><span class="n">istate</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">delta_t_Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;delta_t_Obs_&quot;</span><span class="o">+</span><span class="n">istate</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">delta_q_Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
		<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;delta_q_Obs_&quot;</span><span class="o">+</span><span class="n">istate</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">Sd_Renyi</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Sd_&quot;</span><span class="o">+</span><span class="n">istate</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Sd_Renyi_&quot;</span><span class="o">+</span><span class="n">istate</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">Srdm_Renyi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Srdm_&quot;</span><span class="o">+</span><span class="n">istate</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Srdm_Renyi_&quot;</span><span class="o">+</span><span class="n">istate</span><span class="p">)</span>


	<span class="c1">#################################################################</span>
	<span class="c1"># calculate diag ens value of Obs</span>
	<span class="k">if</span> <span class="n">Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
		<span class="n">Obs_d</span> <span class="o">=</span> <span class="n">Obs</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>


	<span class="c1"># calculate diag ens value of Obs fluctuations</span>
	<span class="k">if</span> <span class="n">delta_t_Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
		<span class="n">delta_t_Obs_d</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;j...,jk,k...-&gt;...&#39;</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">delta_t_Obs</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

		<span class="c1"># calculate diag ens value of Obs fluctuations</span>
		<span class="k">if</span> <span class="n">delta_q_Obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
			<span class="n">delta_q_Obs_d</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">_np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;j...,j-&gt;...&#39;</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">delta_q_Obs</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">delta_t_Obs_d</span> <span class="o">-</span> <span class="n">Obs_d</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>

		<span class="n">delta_t_Obs_d</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">delta_t_Obs_d</span> <span class="p">)</span>

		
	<span class="c1"># calculate Shannon _entropy for the distribution p</span>
	<span class="k">def</span> <span class="nf">_entropy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">alpha</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; </span>
<span class="sd">		This function calculates the Renyi _entropy of the distribution p with parameter alpha.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
			<span class="c1">#warnings.warn(&quot;Renyi _entropy equals von Neumann _entropy.&quot;, UserWarning,stacklevel=4)</span>
			<span class="n">S</span> <span class="o">=</span> <span class="o">-</span> <span class="n">_np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">S</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="n">alpha</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
			
		<span class="k">return</span> <span class="n">S</span>

	<span class="c1"># calculate diag ens ent _entropy in post-quench basis</span>
	<span class="k">if</span> <span class="n">Srdm_Renyi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
		<span class="c1"># calculate effective diagonal singular values, \lambda_i^{(n)} = Srdm_Renyi</span>
		<span class="c1">#rho_ent = (Srdm_Renyi**2).dot(rho) # has components (i,psi)</span>
		<span class="n">rho_ent</span> <span class="o">=</span> <span class="n">Srdm_Renyi</span> <span class="c1"># has components (i,psi)</span>
		<span class="n">Srdm_Renyi_d</span> <span class="o">=</span> <span class="n">_entropy</span><span class="p">(</span><span class="n">rho_ent</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>

		
	<span class="c1"># calculate diag ens _entropy in post-quench basis</span>
	<span class="k">if</span> <span class="n">Sd_Renyi</span><span class="p">:</span>
		<span class="n">Sd_Renyi_d</span> <span class="o">=</span> <span class="n">_entropy</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">alpha</span><span class="p">)</span>
		

	<span class="c1"># define return dict</span>
	<span class="n">return_dict</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>

		<span class="n">j</span><span class="o">=</span><span class="n">i</span>
		<span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;Srdm&quot;</span> <span class="ow">in</span> <span class="n">i</span> <span class="ow">or</span> <span class="s1">&#39;Sd&#39;</span> <span class="ow">in</span> <span class="n">i</span><span class="p">):</span>
			<span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">istate</span><span class="p">,</span><span class="s1">&#39;Renyi_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">istate</span><span class="p">))</span>

		<span class="n">return_dict</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">i</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">istate</span><span class="p">)]</span><span class="o">+</span><span class="s1">&#39;d&#39;</span><span class="p">]</span>
	

	<span class="k">return</span> <span class="n">return_dict</span>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">QuSpin 0.2.5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Phillip Weinberg and Marin Bukov.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.
    </div>
  </body>
</html>