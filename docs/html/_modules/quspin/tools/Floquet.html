
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>quspin.tools.Floquet &#8212; QuSpin 0.2.5 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.2.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">QuSpin 0.2.5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for quspin.tools.Floquet</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">..operators</span> <span class="k">import</span> <span class="n">hamiltonian</span><span class="p">,</span><span class="n">ishamiltonian</span>


<span class="c1"># need linear algebra packages</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span> <span class="k">as</span> <span class="nn">_sla</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">_la</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">_sp</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np</span>

<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="k">import</span> <span class="n">complex_ode</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="k">import</span> <span class="n">delayed</span><span class="p">,</span><span class="n">Parallel</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">vstack</span> 

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Floquet_t_vec&#39;</span><span class="p">,</span><span class="s1">&#39;Floquet_t_vec&#39;</span><span class="p">]</span>

<span class="c1">#warnings.warn(&quot;Floquet Package has not been fully tested yet, please report bugs to: https://github.com/weinbe58/qspin/issues.&quot;,UserWarning,stacklevel=3)</span>



<span class="k">def</span> <span class="nf">_range_iter</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">stop</span><span class="p">,</span><span class="n">step</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;&#39;xrange&#39; is replaced with &#39;range&#39; in python 3. If python 2 is being used, range will cause memory overflow.</span>
<span class="sd">	This function is a work around to get the functionality of &#39;xrange&#39; for both python 2 and 3 simultaineously. </span>
<span class="sd">	</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">count</span>
	<span class="n">counter</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">step</span><span class="p">)</span>
	<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
		<span class="n">i</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
			<span class="k">yield</span> <span class="n">i</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">break</span>

<span class="k">def</span> <span class="nf">_evolve_cont</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">atol</span><span class="o">=</span><span class="mi">1</span><span class="n">E</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span><span class="n">rtol</span><span class="o">=</span><span class="mi">1</span><span class="n">E</span><span class="o">-</span><span class="mi">9</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;This function evolves the i-th local basis state under the Hamiltonian H up to period T. </span>
<span class="sd">	It is used to construct the stroboscpoic evolution operator.</span>
<span class="sd">	</span>
<span class="sd">	&quot;&quot;&quot;</span>
	
	<span class="n">nsteps</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span> <span class="c1"># huge number to make sure solver is successful.</span>
	<span class="n">psi0</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span> 
	<span class="n">psi0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mf">1.0</span>

	<span class="n">solver</span><span class="o">=</span><span class="n">complex_ode</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">_hamiltonian__SO</span><span class="p">)</span>
	<span class="n">solver</span><span class="o">.</span><span class="n">set_integrator</span><span class="p">(</span><span class="s1">&#39;dop853&#39;</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span><span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span><span class="n">nsteps</span><span class="o">=</span><span class="n">nsteps</span><span class="p">)</span> 
	<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_value</span><span class="p">(</span><span class="n">psi0</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
	<span class="n">t_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">]</span>
	<span class="n">nsteps</span> <span class="o">=</span> <span class="mi">1</span>
	<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">t_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
			<span class="n">solver</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="n">successful</span><span class="p">():</span>
				<span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">T</span><span class="p">:</span>
					<span class="k">return</span> <span class="n">solver</span><span class="o">.</span><span class="n">y</span>
				<span class="k">continue</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">break</span>

		<span class="n">nsteps</span> <span class="o">*=</span> <span class="mi">10</span>
		<span class="n">t_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="n">nsteps</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>




<span class="k">def</span> <span class="nf">_evolve_step_1</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">H_list</span><span class="p">,</span><span class="n">dt_list</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;This function calculates the evolved state for Periodic Step (point 2. in def of &#39;evo_dict&#39;). </span>
<span class="sd">	</span>
<span class="sd">	&quot;&quot;&quot;</span>
	
	<span class="n">psi0</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">H_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span> 
	<span class="n">psi0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mf">1.0</span>

	<span class="k">for</span> <span class="n">dt</span><span class="p">,</span><span class="n">H</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dt_list</span><span class="p">,</span><span class="n">H_list</span><span class="p">):</span>
		<span class="n">psi0</span> <span class="o">=</span> <span class="n">_sla</span><span class="o">.</span><span class="n">expm_multiply</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">H</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(),</span><span class="n">psi0</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">psi0</span>

<span class="k">def</span> <span class="nf">_evolve_step_2</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">t_list</span><span class="p">,</span><span class="n">dt_list</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;This function calculates the evolved state for Periodic Step (point 3. in def of &#39;evo_dict&#39;. </span>
<span class="sd">	</span>
<span class="sd">	&quot;&quot;&quot;</span>
	
	<span class="n">psi0</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span> 
	<span class="n">psi0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mf">1.0</span>

	<span class="k">for</span> <span class="n">t</span><span class="p">,</span><span class="n">dt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">t_list</span><span class="p">,</span><span class="n">dt_list</span><span class="p">):</span>
		<span class="n">psi0</span> <span class="o">=</span> <span class="n">_sla</span><span class="o">.</span><span class="n">expm_multiply</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">H</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">psi0</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">psi0</span>
	
	

<span class="c1">### USING JOBLIB ###</span>
<span class="k">def</span> <span class="nf">_get_U_cont</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">n_jobs</span><span class="p">,</span><span class="n">atol</span><span class="o">=</span><span class="mi">1</span><span class="n">E</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span><span class="n">rtol</span><span class="o">=</span><span class="mi">1</span><span class="n">E</span><span class="o">-</span><span class="mi">9</span><span class="p">):</span> 
	
	<span class="n">sols</span><span class="o">=</span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">_evolve_cont</span><span class="p">)(</span><span class="n">i</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">atol</span><span class="p">,</span><span class="n">rtol</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_range_iter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

	<span class="k">return</span> <span class="n">vstack</span><span class="p">(</span><span class="n">sols</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_U_step_1</span><span class="p">(</span><span class="n">H_list</span><span class="p">,</span><span class="n">dt_list</span><span class="p">,</span><span class="n">n_jobs</span><span class="p">):</span> 
	
	<span class="n">sols</span><span class="o">=</span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">_evolve_step_1</span><span class="p">)(</span><span class="n">i</span><span class="p">,</span><span class="n">H_list</span><span class="p">,</span><span class="n">dt_list</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_range_iter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">H_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

	<span class="k">return</span> <span class="n">vstack</span><span class="p">(</span><span class="n">sols</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_U_step_2</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">t_list</span><span class="p">,</span><span class="n">dt_list</span><span class="p">,</span><span class="n">n_jobs</span><span class="p">):</span> 
	
	<span class="n">sols</span><span class="o">=</span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">_evolve_step_2</span><span class="p">)(</span><span class="n">i</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">t_list</span><span class="p">,</span><span class="n">dt_list</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_range_iter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">H</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

	<span class="k">return</span> <span class="n">vstack</span><span class="p">(</span><span class="n">sols</span><span class="p">)</span>



<div class="viewcode-block" id="Floquet"><a class="viewcode-back" href="../../../generated/quspin.tools.Floquet.Floquet.html#quspin.tools.Floquet.Floquet">[docs]</a><span class="k">class</span> <span class="nc">Floquet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Calculates the Floquet spectrum, Floquet Hamiltonian and Floquet states.</span>

<span class="sd">	Loops over the basis states to compute the Floquet unitary :math:`U_F` (evolution operator over one period) for a</span>
<span class="sd">	periodically-driven system governed by the Hamiltonian :math:`H(t)=H(t+T)`:</span>

<span class="sd">	.. math::</span>
<span class="sd">		U_F=U(T,0)=\\mathcal{T}_t\\exp\\left(-i\\int_0^T\\mathrm{d}t H(t) \\right)</span>

<span class="sd">	with :math:`\\mathcal{T}_t\exp` denoting the time-ordered exponential.</span>

<span class="sd">	Examples</span>
<span class="sd">	--------</span>

<span class="sd">	Consider the following periodically driven spin-1/2 Hamiltonian</span>

<span class="sd">	.. math::</span>
<span class="sd">		H(t) = \\left\\{ </span>
<span class="sd">		\\begin{array}{cl} \sum_j J\sigma^z_{j+1}\sigma^z_j + h\sigma^z_j , &amp;  t\\in[-T/4,T/4] \\newline </span>
<span class="sd">		\sum_j g\sigma^x_j, &amp;  t \\in[T/4,3T/4] </span>
<span class="sd">		\\end{array} </span>
<span class="sd">		\\right\\}  \mathrm{mod}\\ T</span>

<span class="sd">	where :math:`T=2\\pi/\\Omega` is the drive period. We choose the starting point of the evolution </span>
<span class="sd">	(or equivalently -- the driving phase) to be :math:`t=0`.</span>

<span class="sd">	The following snippet of code shows how to calculate the Floquet eigenstates and the corresponding quasienergies,</span>
<span class="sd">	using `evo_dict` variable, case ii (see below). </span>

<span class="sd">	.. literalinclude:: ../../doc_examples/Floquet_class-example.py</span>
<span class="sd">		:linenos:</span>
<span class="sd">		:language: python</span>
<span class="sd">		:lines: 7-</span>

<span class="sd">	&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Floquet.__init__"><a class="viewcode-back" href="../../../generated/quspin.tools.Floquet.Floquet.html#quspin.tools.Floquet.Floquet.__init__">[docs]</a>	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">evo_dict</span><span class="p">,</span><span class="n">HF</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">UF</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">thetaF</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">VF</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		evo_dict : dict</span>
<span class="sd">			Dictionary which passes the different types of protocols to calculate the Floquet unitary. </span>
<span class="sd">			Depending on the protocol type, it contains the following keys:</span>

<span class="sd">			i) Periodic continuous protocol from a `hamiltonian` object.</span>
<span class="sd">				* `H` : hamiltonian object to generate the time evolution. </span>
<span class="sd">				* `T` : period of the protocol. </span>
<span class="sd">				* `rtol` : (optional) relative tolerance for the ODE solver. (default = 1E-9)</span>
<span class="sd">				* `atol` : (optional) absolute tolerance for the ODE solver. (default = 1E-9)</span>

<span class="sd">			ii) Periodic step protocol from a `hamiltonian` object. </span>
<span class="sd">				* `H` : single hamiltonian object to generate the hamiltonians at each step. Periodic step drives can be encoded using a single function, e.g. :math:`\\sign(\\cos(\\Omega t))`.</span>
<span class="sd">				* `t_list` : list of times to evaluate the hamiltonian at for each step.</span>
<span class="sd">				* `dt_list` : list of time step durations for each step of the evolution. </span>

<span class="sd">			iii) Periodic step protocol from a list of hamiltonians. </span>
<span class="sd">				* `H_list` : list of matrices to evolve with.</span>
<span class="sd">				* `dt_list` : list of time step durations. Must be the same size as `H_list`.</span>
<span class="sd">		</span>
<span class="sd">		HF : bool</span>
<span class="sd">			Set to `True` to calculate and return Floquet Hamiltonian under attribute `_.HF`. Default is `False`.</span>
<span class="sd">		UF : bool</span>
<span class="sd">			Set to `True` to save evolution operator under attribute `_.UF`. Default is `False`.</span>
<span class="sd">		thetaF : bool</span>
<span class="sd">			Set to `True` to save eigenvalues of the evolution operator (Floquet phases) under attribute `_.thetaF`. Default is `False`.</span>
<span class="sd">		VF : bool</span>
<span class="sd">			Set to `True` to save Floquet states under attribute _.VF. Default is `False`. </span>
<span class="sd">		n_jobs : int, optional</span>
<span class="sd">			Set the number of processors which are used when looping over the basis states to compute the Floquet unitary. Default is `False`. </span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="n">HF</span><span class="p">:</span> <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;HF&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">UF</span><span class="p">:</span> <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;UF&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">VF</span><span class="p">:</span> <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;VF&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">thetaF</span><span class="p">:</span> <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;thetaF&#39;</span><span class="p">)</span>

		
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">evo_dict</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>

			<span class="n">keys</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
			<span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;H&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;H&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;arol&quot;</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;H&quot;</span><span class="p">,</span><span class="s2">&quot;T&quot;</span><span class="p">,</span><span class="s2">&quot;atol&quot;</span><span class="p">,</span><span class="s2">&quot;rtol&quot;</span><span class="p">]):</span>

				<span class="n">H</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">]</span>
				<span class="n">T</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_atol</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;atol&quot;</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_rtol</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rtol&quot;</span><span class="p">)</span>

				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_atol</span><span class="o">=</span><span class="mi">1</span><span class="n">E</span><span class="o">-</span><span class="mi">12</span>
				<span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_atol</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">float</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting float for &#39;atol&#39;.&quot;</span><span class="p">)</span>

				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rtol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_rtol</span><span class="o">=</span><span class="mi">1</span><span class="n">E</span><span class="o">-</span><span class="mi">12</span>
				<span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rtol</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">float</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting float for &#39;rtol&#39;.&quot;</span><span class="p">)</span>
				

				<span class="k">if</span> <span class="ow">not</span> <span class="n">ishamiltonian</span><span class="p">(</span><span class="n">H</span><span class="p">):</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting hamiltonian object for &#39;H&#39;.&quot;</span><span class="p">)</span>

				<span class="k">if</span> <span class="ow">not</span> <span class="n">_np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting scalar object for &#39;T&#39;.&quot;</span><span class="p">)</span>

				<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting real value for &#39;T&#39;.&quot;</span><span class="p">)</span>


				<span class="c1">### check if H is periodic with period T</span>
				<span class="c1"># define arbitrarily complicated weird-ass number</span>

				<span class="n">t</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span> <span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">_np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">**</span><span class="p">(</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">_np</span><span class="o">.</span><span class="n">euler_gamma</span> <span class="p">)</span> <span class="p">)</span>

				<span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">H</span><span class="o">.</span><span class="n">dynamic</span><span class="p">:</span>
					<span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">T</span><span class="p">)</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="n">E3</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
						<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Hamiltonian &#39;H&#39; must be periodic with period &#39;T&#39;!&quot;</span><span class="p">)</span>

				<span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
					<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expecting integer value for optional variable &#39;n_jobs&#39;!&quot;</span><span class="p">)</span>



				<span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">=</span> <span class="n">T</span>

				<span class="c1"># calculate evolution operator</span>
				<span class="n">UF</span> <span class="o">=</span> <span class="n">_get_U_cont</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">n_jobs</span><span class="p">,</span><span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_atol</span><span class="p">,</span><span class="n">rtol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rtol</span><span class="p">)</span>

			<span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;H&quot;</span><span class="p">,</span><span class="s2">&quot;t_list&quot;</span><span class="p">,</span><span class="s2">&quot;dt_list&quot;</span><span class="p">]):</span>
				<span class="n">H</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">]</span>
				<span class="n">t_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;t_list&quot;</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
				<span class="n">dt_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;dt_list&quot;</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

				<span class="k">if</span> <span class="n">t_list</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;t_list must be 1d array.&quot;</span><span class="p">)</span>

				<span class="k">if</span> <span class="n">dt_list</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dt_list must be 1d array.&quot;</span><span class="p">)</span>

				<span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">=</span> <span class="n">dt_list</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

				<span class="k">if</span> <span class="ow">not</span> <span class="n">ishamiltonian</span><span class="p">(</span><span class="n">H</span><span class="p">):</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting hamiltonian object for &#39;H&#39;.&quot;</span><span class="p">)</span>

				<span class="c1"># calculate evolution operator</span>
				<span class="n">UF</span> <span class="o">=</span> <span class="n">_get_U_step_2</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">t_list</span><span class="p">,</span><span class="n">dt_list</span><span class="p">,</span><span class="n">n_jobs</span><span class="p">)</span>



			<span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;H_list&quot;</span><span class="p">,</span><span class="s2">&quot;dt_list&quot;</span><span class="p">]):</span>
				<span class="n">H_list</span> <span class="o">=</span> <span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;H_list&quot;</span><span class="p">]</span>
				<span class="n">dt_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">evo_dict</span><span class="p">[</span><span class="s2">&quot;dt_list&quot;</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>


				<span class="k">if</span> <span class="n">dt_list</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dt_list must be 1d array.&quot;</span><span class="p">)</span>

				<span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">=</span> <span class="n">dt_list</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
				
				<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">H_list</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting list/tuple for H_list.&quot;</span><span class="p">)</span>

				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">H_list</span><span class="p">):</span>
					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting arguments &#39;H_list&#39; and &#39;dt_list&#39; to have the same length!&quot;</span><span class="p">)</span>


				<span class="c1"># calculate evolution operator</span>
				<span class="n">UF</span> <span class="o">=</span> <span class="n">_get_U_step_1</span><span class="p">(</span><span class="n">H_list</span><span class="p">,</span><span class="n">dt_list</span><span class="p">,</span><span class="n">n_jobs</span><span class="p">)</span>
				
			<span class="k">else</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;evo_dict=</span><span class="si">{0}</span><span class="s2"> is not correct format.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">evo_dict</span><span class="p">))</span>	
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;evo_dict=</span><span class="si">{0}</span><span class="s2"> is not correct format.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">evo_dict</span><span class="p">))</span>

		<span class="k">if</span> <span class="s1">&#39;UF&#39;</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_UF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">UF</span><span class="p">)</span>

		<span class="k">if</span> <span class="s1">&#39;HF&#39;</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_HF</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_T</span><span class="o">*</span><span class="n">_la</span><span class="o">.</span><span class="n">logm</span><span class="p">(</span><span class="n">UF</span><span class="p">)</span>

		<span class="c1"># find Floquet states and phases</span>
		<span class="k">if</span> <span class="s2">&quot;VF&quot;</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
			<span class="n">thetaF</span><span class="p">,</span> <span class="n">VF</span> <span class="o">=</span> <span class="n">_la</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">UF</span><span class="p">,</span><span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
			<span class="c1"># check and orthogonalise VF in degenerate subspaces</span>
			<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span> <span class="n">_np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">thetaF</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">E3</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">thetaF</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>
				<span class="n">VF</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">_la</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">VF</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
			<span class="c1"># calculate and order q&#39;energies</span>
			<span class="n">EF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">thetaF</span><span class="p">)</span> <span class="p">)</span>
			<span class="c1"># sort and order</span>
			<span class="n">ind_EF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">EF</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_EF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">EF</span><span class="p">[</span><span class="n">ind_EF</span><span class="p">])</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_VF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">VF</span><span class="p">[:,</span><span class="n">ind_EF</span><span class="p">])</span>
			<span class="c1"># clear up junk</span>
			<span class="k">del</span> <span class="n">VF</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">thetaF</span> <span class="o">=</span> <span class="n">_la</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">UF</span><span class="p">,</span><span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
			<span class="c1"># calculate and order q&#39;energies</span>
			<span class="n">EF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">thetaF</span><span class="p">)</span> <span class="p">)</span>
			<span class="n">ind_EF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">EF</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_EF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">EF</span><span class="p">[</span><span class="n">ind_EF</span><span class="p">])</span>

		<span class="k">if</span> <span class="s1">&#39;thetaF&#39;</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
			<span class="c1"># sort phases</span>
			<span class="n">thetaF</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">thetaF</span><span class="p">[</span><span class="n">ind_EF</span><span class="p">])</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_thetaF</span> <span class="o">=</span> <span class="n">thetaF</span></div>


	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;float: drive period.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_T</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">EF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;numpy.ndarray(float): ordered Floquet quasi-energies in interval :math:`[-\\Omega,\\Omega]`.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EF</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">HF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;numpy.ndarray(float): Floquet Hamiltonian.</span>
<span class="sd">		</span>
<span class="sd">		Requires __init__ argument HF=True.	</span>
<span class="sd">		</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;_HF&quot;</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HF</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;missing atrribute &#39;HF&#39;.&quot;</span><span class="p">)</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">UF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;numpy.ndarray(float): Floquet unitary.</span>
<span class="sd">		</span>
<span class="sd">		Requires __init__ argument UF=True.	</span>
<span class="sd">		</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;_UF&quot;</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_UF</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;missing atrribute &#39;UF&#39;.&quot;</span><span class="p">)</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">thetaF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;numpy.ndarray(float): Floquet eigenphases.</span>
<span class="sd">		</span>
<span class="sd">		Requires __init__ argument thetaF=True.	</span>
<span class="sd">		</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;_thetaF&quot;</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thetaF</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;missing atrribute &#39;thetaF&#39;.&quot;</span><span class="p">)</span>


	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">VF</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;numpy.ndarray(float): Floquet eigenbasis (in columns).</span>
<span class="sd">		</span>
<span class="sd">		Requires __init__ argument VF=True.	</span>
<span class="sd">		</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;_VF&quot;</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VF</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;missing atrribute &#39;VF&#39;.&quot;</span><span class="p">)</span></div>
			



<div class="viewcode-block" id="Floquet_t_vec"><a class="viewcode-back" href="../../../generated/quspin.tools.Floquet.Floquet_t_vec.html#quspin.tools.Floquet.Floquet_t_vec">[docs]</a><span class="k">class</span> <span class="nc">Floquet_t_vec</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Creates a Floquet time vector with fixed number of points per period.</span>

<span class="sd">	This time vector hits all stroboscopic times, and has many useful attributes. The time vector </span>
<span class="sd">	can be divided in three parts corresponding to three regimes of periodic evolution: </span>
<span class="sd">	ramp-up, constant and ramp-down.</span>
<span class="sd">	</span>
<span class="sd">	Particularly useful for studying periodically-driven systems.</span>

<span class="sd">	Examples</span>
<span class="sd">	--------</span>

<span class="sd">	The following code shows how to use the `Floquet_t_vec` class.</span>

<span class="sd">	.. literalinclude:: ../../doc_examples/Floquet_t_vec-example.py</span>
<span class="sd">		:linenos:</span>
<span class="sd">		:language: python</span>
<span class="sd">		:lines: 7-</span>
<span class="sd">	</span>
<span class="sd">	&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Floquet_t_vec.__init__"><a class="viewcode-back" href="../../../generated/quspin.tools.Floquet.Floquet_t_vec.html#quspin.tools.Floquet.Floquet_t_vec.__init__">[docs]</a>	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Omega</span><span class="p">,</span> <span class="n">N_const</span><span class="p">,</span> <span class="n">len_T</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">N_up</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_down</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		Omega : float</span>
<span class="sd">			Drive frequency.</span>
<span class="sd">		N_const : int</span>
<span class="sd">			Number of time periods in the constant part (period) of the time vector.</span>
<span class="sd">		len_T : int</span>
<span class="sd">			Number of time points within a single period. N.B. the last period interval is assumed </span>
<span class="sd">			open on the right, i.e. [0,T) and the point T is NOT counted towards &#39;len_T&#39;.</span>
<span class="sd">		N_up : int, optional</span>
<span class="sd">			Number of time periods in the up-part (period) of time vector.</span>
<span class="sd">		N_down : int, optional</span>
<span class="sd">			Number of time periods in the down-part (period) of time vector.</span>
<span class="sd">		</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="c1"># total number of periods</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="n">N_up</span><span class="o">+</span><span class="n">N_const</span><span class="o">+</span><span class="n">N_down</span>
		<span class="c1"># total length of a period </span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_len_T</span> <span class="o">=</span> <span class="n">len_T</span>
		<span class="c1"># driving period T</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">Omega</span> 


		<span class="c1"># define time vector</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">N_up</span><span class="p">,</span> <span class="n">N_const</span><span class="o">+</span><span class="n">N_down</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">*</span><span class="n">len_T</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">n</span>
		<span class="c1"># total length of time vector</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">size</span>
		<span class="c1"># time step</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">len_T</span>
		<span class="c1"># define index of period -N_up</span>
		<span class="n">ind0</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#int( _np.squeeze( (n==-N_up).nonzero() ) )</span>

		<span class="c1"># calculate stroboscopic times</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_strobo</span> <span class="o">=</span> <span class="n">_strobo_times</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span><span class="n">ind0</span><span class="p">)</span>

		<span class="c1"># define initial and final times and total duration</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_tot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i</span>

		<span class="c1"># if ramp is on, define more attributes</span>
		<span class="k">if</span> <span class="n">N_up</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">N_down</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">t_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span><span class="p">]]</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_up</span> <span class="o">=</span> <span class="n">_periodic_ramp</span><span class="p">(</span><span class="n">N_up</span><span class="p">,</span><span class="n">t_up</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span><span class="n">ind0</span><span class="p">)</span>

			<span class="n">t_const</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span><span class="o">+</span><span class="n">N_const</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">ind0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">len_T</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_const</span> <span class="o">=</span> <span class="n">_periodic_ramp</span><span class="p">(</span><span class="n">N_const</span><span class="p">,</span><span class="n">t_const</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span><span class="n">ind0</span><span class="p">)</span>

			<span class="n">t_down</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span><span class="o">+</span><span class="n">N_const</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">ind0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">len_T</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_down</span> <span class="o">=</span> <span class="n">_periodic_ramp</span><span class="p">(</span><span class="n">N_down</span><span class="p">,</span><span class="n">t_down</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span><span class="n">ind0</span><span class="p">)</span>

		<span class="k">elif</span> <span class="n">N_up</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">t_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span><span class="p">]]</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_up</span> <span class="o">=</span> <span class="n">_periodic_ramp</span><span class="p">(</span><span class="n">N_up</span><span class="p">,</span><span class="n">t_up</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span><span class="n">ind0</span><span class="p">)</span>

			<span class="n">t_const</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span><span class="o">+</span><span class="n">N_const</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">ind0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">len_T</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_const</span> <span class="o">=</span> <span class="n">_periodic_ramp</span><span class="p">(</span><span class="n">N_const</span><span class="p">,</span><span class="n">t_const</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span><span class="n">ind0</span><span class="p">)</span>

		<span class="k">elif</span> <span class="n">N_down</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">t_const</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span><span class="o">+</span><span class="n">N_const</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_const</span> <span class="o">=</span> <span class="n">_periodic_ramp</span><span class="p">(</span><span class="n">N_const</span><span class="p">,</span><span class="n">t_const</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span><span class="n">ind0</span><span class="p">)</span>

			<span class="n">t_down</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="n">N_up</span><span class="o">+</span><span class="n">N_const</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">ind0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="o">.</span><span class="n">strobo</span><span class="o">.</span><span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">len_T</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_down</span> <span class="o">=</span> <span class="n">_periodic_ramp</span><span class="p">(</span><span class="n">N_down</span><span class="p">,</span><span class="n">t_down</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">len_T</span><span class="p">,</span><span class="n">ind0</span><span class="p">)</span></div>


	<span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

	<span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="o">.</span><span class="n">__len__</span><span class="p">()</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">N</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;int: total number of periods.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">len_T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;int: number of time points within one period, assumed half-open; [0,T).&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len_T</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;float: drive period.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_T</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">vals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;np.ndarray(float): time vector values.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;int: length of time vector.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">dt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;float: time vector step size.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">i</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;float: initial time value.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;foat: final time value.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span>


	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">tot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;float: total time duration; `_.f - _.i` .&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tot</span>


	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">strobo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;obj: calculates stroboscopic times in time vector with period length `len_T` and assigns them as</span>
<span class="sd">		attributes:</span>

<span class="sd">		_.strobo.inds : numpy.ndarray(int)</span>
<span class="sd">			indices of stroboscopic times (full periods).</span>

<span class="sd">		_.strobo.vals : numpy.ndarray(float)</span>
<span class="sd">			values of stroboscopic times (full periods).</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strobo</span>


	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;obj: refers to time vector of up-part (regime).</span>

<span class="sd">		Inherits all attributes (e.g. `_.up.strobo.inds`) except `_.T`, `_.dt`, and `_.lenT`.</span>

<span class="sd">		Requires optional `__init___` parameter `N_up` to be specified.</span>
<span class="sd">		</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;_up&quot;</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_up</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;missing attribute &#39;up&#39;&quot;</span><span class="p">)</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">const</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;obj: refers to time vector of const-part (regime).</span>

<span class="sd">		Inherits all attributes (e.g. `_.const.strobo.inds`) except `_.T`, `_.dt`, and `_.lenT`.</span>
<span class="sd">		</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;_const&quot;</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_up</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;missing attribute &#39;const&#39;&quot;</span><span class="p">)</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">down</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;obj: refers to time vector of down-part (regime).</span>

<span class="sd">		Inherits all attributes (e.g. `_.down.strobo.inds`) except `_.T`, `_.dt`, and `_.lenT`.</span>

<span class="sd">		Requires optional __init___ parameter N_down to be specified.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;_down&quot;</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_up</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;missing attribute &#39;down&#39;&quot;</span><span class="p">)</span></div>


	





<span class="k">class</span> <span class="nc">_strobo_times</span><span class="p">():</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">len_T</span><span class="p">,</span><span class="n">ind0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Calculates stroboscopic times in time vector t with period length len_T and assigns them as</span>
<span class="sd">		attributes.</span>
<span class="sd">		</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1"># indices of strobo times</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_inds</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="n">len_T</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
		<span class="c1">#discrete stroboscopic t_vecs</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inds</span><span class="p">)</span>
		<span class="c1"># update strobo indices to match shifted (ramped) ones</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_inds</span> <span class="o">+=</span> <span class="n">ind0</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">inds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inds</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">vals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span>
	
		 


<span class="k">class</span> <span class="nc">_periodic_ramp</span><span class="p">():</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">len_T</span><span class="p">,</span><span class="n">ind0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Defines time vector attributes of each regime.</span>
<span class="sd">		</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="o">=</span><span class="n">N</span> <span class="c1"># total # periods</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_vals</span> <span class="o">=</span> <span class="n">t</span> <span class="c1"># time values</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># initial value</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># final value</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_tot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="o">*</span><span class="n">T</span> <span class="c1"># total duration</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="o">.</span><span class="n">size</span> <span class="c1"># total length</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_strobo</span> <span class="o">=</span> <span class="n">_strobo_times</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="p">,</span><span class="n">len_T</span><span class="p">,</span><span class="n">ind0</span><span class="p">)</span> <span class="c1"># strobo attributes</span>

	<span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

	<span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span><span class="o">.</span><span class="n">__len__</span><span class="p">()</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">N</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>
	
	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">vals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vals</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">i</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">tot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tot</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">strobo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strobo</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">QuSpin 0.2.5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Phillip Weinberg and Marin Bukov.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.
    </div>
  </body>
</html>