
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-110543543-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>quspin.basis.user_basis &#8212; QuSpin 0.3.3 documentation</title>
    <link rel="stylesheet" href="../static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuSpin 0.3.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../basis.html" accesskey="U">Basis module (<code class="docutils literal notranslate"><span class="pre">quspin.basis</span></code>)</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="quspin-basis-user-basis">
<h1>quspin.basis.user_basis<a class="headerlink" href="#quspin-basis-user-basis" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="quspin.basis.user_basis">
<em class="property">class </em><code class="descclassname">quspin.basis.</code><code class="descname">user_basis</code><span class="sig-paren">(</span><em>basis_dtype</em>, <em>N</em>, <em>op_dict</em>, <em>sps=2</em>, <em>pcon_dict=None</em>, <em>pre_check_state=None</em>, <em>allowed_ops=None</em>, <em>Ns_block_est=None</em>, <em>_make_basis=True</em>, <em>block_order=None</em>, <em>_Np=None</em>, <em>**blocks</em><span class="sig-paren">)</span><a class="reference internal" href="../modules/quspin/basis/basis_general/base_user.html#user_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quspin.basis.user_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs basis for USER-DEFINED functionality of a basis object.</p>
<p>The <cite>user_basis</cite> unveils the inner workings of QuSpin. This is the most advanced usage of the package, and requires some understanding of python,
the <cite>numba</cite> package used to interface QuSpin’s underlying cpp code with python, and some experience with bitwise operations to manipulate integers.</p>
<p>Since we believe that the users will benefit from a more detailed discussion on how the <cite>user_basis</cite> is intended to work, we also provide a detailed 
tutorial: <a class="reference internal" href="../user_basis.html#user-basis-label"><span class="std std-ref">A tutorial on QuSpin’s user_basis</span></a>, which covers the general concepts and provides six complete examples of various complexity.</p>
<p class="rubric">Examples</p>
<p>The following example shows how to use the <cite>user_basis</cite> class to construct the Hamiltonian</p>
<div class="math notranslate nohighlight">
\[H = \sum_j P_{j-1}\sigma^x_j P_{j+1},\quad P_j = |\downarrow_j\rangle\langle\downarrow_j|\]</div>
<p>using translation and reflection symmetry. The projector operator <span class="math notranslate nohighlight">\(P_j\)</span>, which only allows a spin-up state in the basis to be preceded and succeeded by a spin-down,
is incorporated by constructing the corresponding <cite>user_basis</cite> object. One can then just build the Hamiltonian <span class="math notranslate nohighlight">\(H=\sum_j\sigma^x_j\)</span> in the
constrained Hilbert space.</p>
<p>More examples (including explanations of the class methods and attributes) can be found at: <a class="reference internal" href="../user_basis.html#user-basis-label"><span class="std std-ref">A tutorial on QuSpin’s user_basis</span></a>.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">quspin.operators</span> <span class="kn">import</span> <span class="n">hamiltonian</span>
<span class="kn">from</span> <span class="nn">quspin.basis.user</span> <span class="kn">import</span> <span class="n">user_basis</span> <span class="c1"># Hilbert space user basis</span>
<span class="kn">from</span> <span class="nn">quspin.basis.user</span> <span class="kn">import</span> <span class="n">next_state_sig_32</span><span class="p">,</span><span class="n">pre_check_state_sig_32</span><span class="p">,</span><span class="n">op_sig_32</span><span class="p">,</span><span class="n">map_sig_32</span> <span class="c1"># user_basis dtypes</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">carray</span><span class="p">,</span><span class="n">cfunc</span> <span class="c1"># numba helper functions</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">uint32</span><span class="p">,</span><span class="n">int32</span> <span class="c1"># numba data types</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="c1">#</span>
<span class="n">N</span><span class="o">=</span><span class="mi">14</span> <span class="c1"># lattice sites</span>
<span class="c1">#</span>
<span class="c1">######  function to call when applying operators</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">op_sig_32</span><span class="p">,</span> <span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="n">uint32</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="n">op_struct_ptr</span><span class="p">,</span><span class="n">op_str</span><span class="p">,</span><span class="n">ind</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># using struct pointer to pass op_struct_ptr back to C++ see numba Records</span>
    <span class="n">op_struct</span> <span class="o">=</span> <span class="n">carray</span><span class="p">(</span><span class="n">op_struct_ptr</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">ind</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># convention for QuSpin for mapping from bits to sites.</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">(((</span><span class="n">op_struct</span><span class="o">.</span><span class="n">state</span><span class="o">&gt;&gt;</span><span class="n">ind</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">ind</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">120</span><span class="p">:</span> <span class="c1"># &quot;x&quot; is integer value 120 (check with ord(&quot;x&quot;))</span>
        <span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">^=</span> <span class="n">b</span>
    <span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">121</span><span class="p">:</span> <span class="c1"># &quot;y&quot; is integer value 120 (check with ord(&quot;y&quot;))</span>
        <span class="n">op_struct</span><span class="o">.</span><span class="n">state</span> <span class="o">^=</span> <span class="n">b</span>
        <span class="n">op_struct</span><span class="o">.</span><span class="n">matrix_ele</span> <span class="o">*=</span> <span class="mf">1.0j</span><span class="o">*</span><span class="n">s</span>
    <span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">122</span><span class="p">:</span> <span class="c1"># &quot;z&quot; is integer value 120 (check with ord(&quot;z&quot;))</span>
        <span class="n">op_struct</span><span class="o">.</span><span class="n">matrix_ele</span> <span class="o">*=</span> <span class="n">s</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">op_struct</span><span class="o">.</span><span class="n">matrix_ele</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1">#</span>
    <span class="k">return</span> <span class="n">err</span>
<span class="c1">#</span>
<span class="n">op_args</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">######  function to filter states/project states out of the basis</span>
<span class="c1">#</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">pre_check_state_sig_32</span><span class="p">,</span>
    <span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">s_shift_left</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">s_shift_right</span><span class="o">=</span><span class="n">uint32</span><span class="p">),</span> <span class="p">)</span>
<span class="k">def</span> <span class="nf">pre_check_state</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; imposes that that a bit with 1 must be preceded and followed by 0,</span>
<span class="sd">    i.e. a particle on a given site must have empty neighboring sites.</span>
<span class="sd">    #</span>
<span class="sd">    Works only for lattices of up to N=32 sites (otherwise, change mask)</span>
<span class="sd">    #</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0xffffffff</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">N</span><span class="p">))</span> <span class="c1"># works for lattices of up to 32 sites</span>
    <span class="c1"># cycle bits left by 1 periodically</span>
    <span class="n">s_shift_left</span> <span class="o">=</span> <span class="p">(((</span><span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span>
    <span class="c1">#</span>
    <span class="c1"># cycle bits right by 1 periodically</span>
    <span class="n">s_shift_right</span> <span class="o">=</span> <span class="p">(((</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span>
    <span class="c1">#</span>
    <span class="k">return</span> <span class="p">(((</span><span class="n">s_shift_right</span><span class="o">|</span><span class="n">s_shift_left</span><span class="p">)</span><span class="o">&amp;</span><span class="n">s</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span>
<span class="c1">#</span>
<span class="n">pre_check_state_args</span><span class="o">=</span><span class="bp">None</span>
<span class="c1">#</span>
<span class="c1">######  define symmetry maps</span>
<span class="c1">#</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">map_sig_32</span><span class="p">,</span>
    <span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">shift</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">xmax</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">x1</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">x2</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">period</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span><span class="n">l</span><span class="o">=</span><span class="n">int32</span><span class="p">,)</span> <span class="p">)</span>
<span class="k">def</span> <span class="nf">translation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">sign_ptr</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; works for all system sizes N. &quot;&quot;&quot;</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># translate state by shift sites</span>
    <span class="n">period</span> <span class="o">=</span> <span class="n">N</span> <span class="c1"># periodicity/cyclicity of translation</span>
    <span class="n">xmax</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1">#</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">shift</span><span class="o">+</span><span class="n">period</span><span class="p">)</span><span class="o">%</span><span class="n">period</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">period</span> <span class="o">-</span> <span class="n">l</span><span class="p">))</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">l</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">xmax</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x2</span> <span class="o">|</span> <span class="n">x1</span><span class="p">)</span>
<span class="n">T_args</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="c1">#</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">map_sig_32</span><span class="p">,</span>
    <span class="nb">locals</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="n">int32</span><span class="p">,)</span> <span class="p">)</span>
<span class="k">def</span> <span class="nf">parity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">sign_ptr</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; works for all system sizes N. &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span> 
    <span class="n">s</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># N-1</span>
    <span class="c1">#</span>
    <span class="n">out</span> <span class="o">^=</span> <span class="p">(</span><span class="n">x</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
    <span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
        <span class="n">out</span> <span class="o">^=</span> <span class="p">(</span><span class="n">x</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="n">s</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="c1">#</span>
    <span class="n">out</span> <span class="o">&lt;&lt;=</span> <span class="n">s</span>
    <span class="k">return</span> <span class="n">out</span>
<span class="n">P_args</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">######  construct user_basis </span>
<span class="c1"># define maps dict</span>
<span class="n">maps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">T_block</span><span class="o">=</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">T_args</span><span class="p">),</span> <span class="n">P_block</span><span class="o">=</span><span class="p">(</span><span class="n">parity</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">P_args</span><span class="p">),)</span>
<span class="c1"># define particle conservation and op dicts</span>
<span class="n">op_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span><span class="n">op_args</span><span class="o">=</span><span class="n">op_args</span><span class="p">)</span>
<span class="c1"># define pre_check_state</span>
<span class="n">pre_check_state</span><span class="o">=</span><span class="p">(</span><span class="n">pre_check_state</span><span class="p">,</span><span class="n">pre_check_state_args</span><span class="p">)</span> <span class="c1"># None gives a null pinter to args</span>
<span class="c1"># create user basis</span>
<span class="n">basis</span> <span class="o">=</span> <span class="n">user_basis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">op_dict</span><span class="p">,</span><span class="n">allowed_ops</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">),</span><span class="n">sps</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="n">pre_check_state</span><span class="o">=</span><span class="n">pre_check_state</span><span class="p">,</span><span class="n">Ns_block_est</span><span class="o">=</span><span class="mi">300000</span><span class="p">,</span><span class="o">**</span><span class="n">maps</span><span class="p">)</span>
<span class="c1"># print basis</span>
<span class="k">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">###### construct Hamiltonian</span>
<span class="c1"># site-coupling lists</span>
<span class="n">h_list</span>  <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="c1"># operator string lists</span>
<span class="n">static</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span><span class="n">h_list</span><span class="p">],]</span>
<span class="c1"># compute Hamiltonian, no checks have been implemented</span>
<span class="n">no_checks</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">check_symm</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">check_pcon</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">check_herm</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">hamiltonian</span><span class="p">(</span><span class="n">static</span><span class="p">,[],</span><span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span><span class="o">**</span><span class="n">no_checks</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#quspin.basis.user_basis.N" title="quspin.basis.user_basis.N"><code class="xref py py-obj docutils literal notranslate"><span class="pre">N</span></code></a></dt>
<dd><p class="first last">int: number of sites the basis is constructed with.</p>
</dd>
<dt><a class="reference internal" href="#quspin.basis.user_basis.Ns" title="quspin.basis.user_basis.Ns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ns</span></code></a></dt>
<dd><p class="first last">int: number of states in the Hilbert space.</p>
</dd>
<dt><a class="reference internal" href="#quspin.basis.user_basis.blocks" title="quspin.basis.user_basis.blocks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">blocks</span></code></a></dt>
<dd><p class="first last">dict: contains the quantum numbers (blocks) for the symmetry sectors.</p>
</dd>
<dt><a class="reference internal" href="#quspin.basis.user_basis.description" title="quspin.basis.user_basis.description"><code class="xref py py-obj docutils literal notranslate"><span class="pre">description</span></code></a></dt>
<dd><p class="first last">str: information about <cite>basis</cite> object.</p>
</dd>
<dt><strong>dtype</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#quspin.basis.user_basis.operators" title="quspin.basis.user_basis.operators"><code class="xref py py-obj docutils literal notranslate"><span class="pre">operators</span></code></a></dt>
<dd><p class="first last">set: set of available operator strings.</p>
</dd>
<dt><a class="reference internal" href="#quspin.basis.user_basis.sps" title="quspin.basis.user_basis.sps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sps</span></code></a></dt>
<dd><p class="first last">int: number of states per site (i.e. the on-site Hilbert space dimension).</p>
</dd>
<dt><a class="reference internal" href="#quspin.basis.user_basis.states" title="quspin.basis.user_basis.states"><code class="xref py py-obj docutils literal notranslate"><span class="pre">states</span></code></a></dt>
<dd><p class="first last">numpy.ndarray(int): basis states stored in their integer representation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.Op" title="quspin.basis.user_basis.Op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Op</span></code></a>(opstr,&nbsp;indx,&nbsp;J,&nbsp;dtype)</td>
<td>Constructs operator from a site-coupling list and an operator string in a lattice basis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.Op_bra_ket" title="quspin.basis.user_basis.Op_bra_ket"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Op_bra_ket</span></code></a>(opstr,&nbsp;indx,&nbsp;J,&nbsp;dtype,&nbsp;ket_states)</td>
<td>Finds bra states which connect given ket states by operator from a site-coupling list and an operator string.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.check_hermitian" title="quspin.basis.user_basis.check_hermitian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_hermitian</span></code></a>(static,&nbsp;dynamic)</td>
<td>Checks operator string lists for hermiticity of the combined operator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.check_pcon" title="quspin.basis.user_basis.check_pcon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_pcon</span></code></a>(static,&nbsp;dynamic)</td>
<td>Checks operator string lists for particle number (magnetisation) conservartion of the combined operator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.check_symm" title="quspin.basis.user_basis.check_symm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_symm</span></code></a>(static,&nbsp;dynamic)</td>
<td>Checks operator string lists for the required symmetries of the combined operator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.ent_entropy" title="quspin.basis.user_basis.ent_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ent_entropy</span></code></a>(state[,&nbsp;sub_sys_A,&nbsp;density,&nbsp;…])</td>
<td>Calculates entanglement entropy of subsystem A and the corresponding reduced density matrix</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.expanded_form" title="quspin.basis.user_basis.expanded_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expanded_form</span></code></a>([static,&nbsp;dynamic])</td>
<td>Splits up operator strings containing “x” and “y” into operator combinations of “+” and “-“.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.get_amp" title="quspin.basis.user_basis.get_amp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_amp</span></code></a>(states[,&nbsp;out,&nbsp;amps,&nbsp;mode])</td>
<td>Computes the rescale factor of state amplitudes between the symmetry-reduced and full basis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.get_proj" title="quspin.basis.user_basis.get_proj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_proj</span></code></a>(dtype[,&nbsp;pcon])</td>
<td>Calculates transformation/projector from symmetry-reduced basis to full (symmetry-free) basis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.get_vec" title="quspin.basis.user_basis.get_vec"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_vec</span></code></a>(v0[,&nbsp;sparse,&nbsp;pcon])</td>
<td>Transforms state from symmetry-reduced basis to full (symmetry-free) basis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.index" title="quspin.basis.user_basis.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a>(s)</td>
<td>Finds the index of user-defined Fock state in any lattice basis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.inplace_Op" title="quspin.basis.user_basis.inplace_Op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inplace_Op</span></code></a>(v_in,&nbsp;opstr,&nbsp;indx,&nbsp;J,&nbsp;dtype[,&nbsp;…])</td>
<td>Calculates the action of an operator on a state.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.int_to_state" title="quspin.basis.user_basis.int_to_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int_to_state</span></code></a>(state[,&nbsp;bracket_notation])</td>
<td>Finds string representation of a state defined in integer representation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.make" title="quspin.basis.user_basis.make"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make</span></code></a>([Ns_block_est])</td>
<td>Creates the entire basis by calling the basis constructor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.normalization" title="quspin.basis.user_basis.normalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalization</span></code></a>(states[,&nbsp;out])</td>
<td>Computes normalization of <cite>basis</cite> states.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.partial_trace" title="quspin.basis.user_basis.partial_trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partial_trace</span></code></a>(state[,&nbsp;sub_sys_A,&nbsp;…])</td>
<td>Calculates reduced density matrix, through a partial trace of a quantum state in a lattice <cite>basis</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.representative" title="quspin.basis.user_basis.representative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">representative</span></code></a>(states[,&nbsp;out,&nbsp;return_g,&nbsp;…])</td>
<td>Maps states to their representatives under the <cite>basis</cite> symmetries.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.state_to_int" title="quspin.basis.user_basis.state_to_int"><code class="xref py py-obj docutils literal notranslate"><span class="pre">state_to_int</span></code></a>(state)</td>
<td>Finds integer representation of a state defined in string format.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="quspin.basis.user_basis.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>basis_dtype</em>, <em>N</em>, <em>op_dict</em>, <em>sps=2</em>, <em>pcon_dict=None</em>, <em>pre_check_state=None</em>, <em>allowed_ops=None</em>, <em>Ns_block_est=None</em>, <em>_make_basis=True</em>, <em>block_order=None</em>, <em>_Np=None</em>, <em>**blocks</em><span class="sig-paren">)</span><a class="reference internal" href="../modules/quspin/basis/basis_general/base_user.html#user_basis.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quspin.basis.user_basis.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Intializes the <cite>user_basis_general</cite> object (basis for user defined ED calculations).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>basis_dtype: numpy.dtype object</strong></dt>
<dd><p class="first last">the data type used to represent the states in the basis: must be either uint32 or uint64.</p>
</dd>
<dt><strong>N: int</strong></dt>
<dd><p class="first last">Number of sites.</p>
</dd>
<dt><strong>op_dict: dict</strong></dt>
<dd><dl class="first last docutils">
<dt>used to define the <cite>basis.Op</cite> function; the dictionary contais the following items:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt><strong>op(op_struct_ptr,op_str,site_ind,N,args): numba.CFunc object</strong></dt>
<dd>This is a numba-compiled function (CFunc) which calculates the matrix elements <span class="math notranslate nohighlight">\(\mathrm{me}\)</span> given a state <span class="math notranslate nohighlight">\(|s\rangle\)</span> together with a character to
represent the operator, an integer <cite>site_ind</cite> specifying the site of that local operator, the total number of sites <cite>N</cite>, and a set of optional <cite>uint</cite>-dtype arguments <cite>args</cite>. See the above example for how
one would use this for spin-1/2 system.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>op_args: np.ndarray[basis_dtype]</strong></dt>
<dd>used to pass the arguments <cite>args</cite> to the CFunc <cite>op(…,args)</cite>. The corresponding key must be a <cite>np.ndarray[basis_dtype]</cite>.</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>pcon_dict: dict, optional</strong></dt>
<dd><dl class="first last docutils">
<dt>This dictionary contains the following items which are required to use particle conservation in this basis:</dt>
<dd><dl class="first last docutils">
<dt><em>minimum requirements</em>:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt><strong>Np: tuple/int, list(tuple/int)</strong>            </dt>
<dd>specifies the particle sector(s).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>next_state(s,counter,N,args): numba.CFunc object</strong></dt>
<dd>given a quantum state <span class="math notranslate nohighlight">\(|s\rangle\)</span> in the integer-representation <cite>s</cite>, this CFunc generates the next lexicographically ordered particle conservation state. 
<cite>counter</cite> is an intrinsic variable which increments by unity every time the function is called, <cite>N</cite> is the total number of lattice sites, and <cite>args</cite> holds any optional arguments stored in a <cite>np.ndarray[basis_dtype]</cite>.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>next_state_args: np.ndarray(basis_dtype)</strong></dt>
<dd>optional arguments for <cite>next_state(…,args)</cite>.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>get_Ns_pcon(N,Np): python function</strong></dt>
<dd>when called as get_Ns_pcon(N,Np), this python function returns the size of the symmetery-free particle conservation basis, given the <cite>N</cite> lattice sites and <cite>Np</cite> (see above).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>get_s0_pcon(N,Np): python function</strong></dt>
<dd>when called as get_s0_pcon(N,Np), this python function returns the starting state to generate the whole particle conservation basis by repeatedly calling <cite>next_state()</cite>.</dd>
</dl>
</li>
</ul>
</dd>
<dt><em>advanced requirements</em> to access <cite>basis.Op_bra_ket()</cite> functionality (on top of the minimum requirements):</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt><strong>n_sectors: int, list(int)</strong></dt>
<dd>number of integers which parameterize the particle sectors, e.g. with spinful fermions there is a particle number for both the up and the down sectors, and hence <cite>n_sectors=2</cite>.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>count_particles(s,p_number_ptr,args): numba.CFunc object</strong></dt>
<dd>For a quantum state <cite>s</cite> in the integer representation, this CFunc counts the number of particles in each particle sector and places them into a pointer <cite>p_number_ptr</cite> (<cite>count_particles</cite> does <strong>not</strong> return any output). The pointer provided will have <cite>n_sector</cite> slots of memory allocated. The components of the pointer <cite>p_number_ptr</cite> must correspond to the ordering of <cite>Np</cite>. The integer <cite>s</cite> cannot be changed.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>count_particles_args: np.ndarray(int)</strong></dt>
<dd>compulsory arguments for <cite>count_particles(…,args)</cite> (whenever used).</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><strong>pre_check_state(s,N,args): numba.CFunc object or tuple(numba.CFunc object,ndarray(C-contiguous,dtype=basis_dtype)), optional</strong></dt>
<dd><p class="first last">This CFunc allows the user to specify a boolean criterion used to discard/filter states from the basis. In the low-level code, this function is applied before checking if a given state is
representative state (i.e. belogs to a given symmetry sector) or not. This allows the user to, e.g., enforce a local Hilbert-space constraint 
(e.g. for a spinful fermion basis to never have a doubly occupied site). One can pass additional arguments <cite>args</cite> using a <cite>np.ndarray[basis_dtype]</cite>.</p>
</dd>
<dt><strong>allowed_ops: list/set, optional</strong></dt>
<dd><p class="first last">A list of allowed characters, each of which is to be passed in to the <cite>op</cite> in the form of <cite>op_str</cite> (see above).</p>
</dd>
<dt><strong>sps: int, optional</strong></dt>
<dd><p class="first last">The number of states per site (i.e. the local on-site Hilbert space dimension).</p>
</dd>
<dt><strong>Ns_block_est: int, optional</strong></dt>
<dd><p class="first last">An estimate for the size of the symmetry reduced block, QuSpin does a simple estimate which is not always correct.</p>
</dd>
<dt><strong>block_order: tuple/list, optional</strong></dt>
<dd><p class="first last">A list of strings containing the names of the symmetry blocks which specifies the order in which the symmetries will be applied to the state when calculating the basis. The first element in the list is applied to the state first followed by the second element, etc. If the list is not specificed the ordering is such that the symmetry with the largest cycle is the first, followed by the second largest, etc.</p>
</dd>
<dt><strong>**blocks: optional</strong></dt>
<dd><p class="first">keyword arguments which pass the symmetry generator arrays. For instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="p">(</span><span class="o">...</span><span class="p">,</span><span class="n">kxblock</span><span class="o">=</span><span class="p">(</span><span class="n">CFunc</span><span class="p">,</span><span class="n">m_Q</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">args</span><span class="p">),</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">The key names of the symmetry sector, e.g. <cite>kxblock</cite>, can be defined arbitrarily by the user. The
values are tuples where the first entry contains the numba-CFunc which generates the symmetry transformation <span class="math notranslate nohighlight">\(Q\)</span> 
acting on the state (see class example), the second entry is an integer <span class="math notranslate nohighlight">\(m_Q\)</span> which gives the periodicity
of the symmetry sector (<span class="math notranslate nohighlight">\(Q^{m_Q} = 1\)</span>), and <span class="math notranslate nohighlight">\(q\)</span> is the quantum number for the given sector. Optional arguments can be passed using the`args` argument which is a <cite>np.ndarray[basis_dtype]</cite>. Note that if the periodicity is wrong
the basis will give undefined behavior.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.Op" title="quspin.basis.user_basis.Op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Op</span></code></a>(opstr,&nbsp;indx,&nbsp;J,&nbsp;dtype)</td>
<td>Constructs operator from a site-coupling list and an operator string in a lattice basis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.Op_bra_ket" title="quspin.basis.user_basis.Op_bra_ket"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Op_bra_ket</span></code></a>(opstr,&nbsp;indx,&nbsp;J,&nbsp;dtype,&nbsp;ket_states)</td>
<td>Finds bra states which connect given ket states by operator from a site-coupling list and an operator string.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.__init__" title="quspin.basis.user_basis.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(basis_dtype,&nbsp;N,&nbsp;op_dict[,&nbsp;sps,&nbsp;…])</td>
<td>Intializes the <cite>user_basis_general</cite> object (basis for user defined ED calculations).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.check_hermitian" title="quspin.basis.user_basis.check_hermitian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_hermitian</span></code></a>(static,&nbsp;dynamic)</td>
<td>Checks operator string lists for hermiticity of the combined operator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.check_pcon" title="quspin.basis.user_basis.check_pcon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_pcon</span></code></a>(static,&nbsp;dynamic)</td>
<td>Checks operator string lists for particle number (magnetisation) conservartion of the combined operator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.check_symm" title="quspin.basis.user_basis.check_symm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_symm</span></code></a>(static,&nbsp;dynamic)</td>
<td>Checks operator string lists for the required symmetries of the combined operator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.ent_entropy" title="quspin.basis.user_basis.ent_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ent_entropy</span></code></a>(state[,&nbsp;sub_sys_A,&nbsp;density,&nbsp;…])</td>
<td>Calculates entanglement entropy of subsystem A and the corresponding reduced density matrix</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.expanded_form" title="quspin.basis.user_basis.expanded_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expanded_form</span></code></a>([static,&nbsp;dynamic])</td>
<td>Splits up operator strings containing “x” and “y” into operator combinations of “+” and “-“.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.get_amp" title="quspin.basis.user_basis.get_amp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_amp</span></code></a>(states[,&nbsp;out,&nbsp;amps,&nbsp;mode])</td>
<td>Computes the rescale factor of state amplitudes between the symmetry-reduced and full basis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.get_proj" title="quspin.basis.user_basis.get_proj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_proj</span></code></a>(dtype[,&nbsp;pcon])</td>
<td>Calculates transformation/projector from symmetry-reduced basis to full (symmetry-free) basis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.get_vec" title="quspin.basis.user_basis.get_vec"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_vec</span></code></a>(v0[,&nbsp;sparse,&nbsp;pcon])</td>
<td>Transforms state from symmetry-reduced basis to full (symmetry-free) basis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.index" title="quspin.basis.user_basis.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a>(s)</td>
<td>Finds the index of user-defined Fock state in any lattice basis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.inplace_Op" title="quspin.basis.user_basis.inplace_Op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inplace_Op</span></code></a>(v_in,&nbsp;opstr,&nbsp;indx,&nbsp;J,&nbsp;dtype[,&nbsp;…])</td>
<td>Calculates the action of an operator on a state.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.int_to_state" title="quspin.basis.user_basis.int_to_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int_to_state</span></code></a>(state[,&nbsp;bracket_notation])</td>
<td>Finds string representation of a state defined in integer representation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.make" title="quspin.basis.user_basis.make"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make</span></code></a>([Ns_block_est])</td>
<td>Creates the entire basis by calling the basis constructor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.normalization" title="quspin.basis.user_basis.normalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalization</span></code></a>(states[,&nbsp;out])</td>
<td>Computes normalization of <cite>basis</cite> states.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.partial_trace" title="quspin.basis.user_basis.partial_trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partial_trace</span></code></a>(state[,&nbsp;sub_sys_A,&nbsp;…])</td>
<td>Calculates reduced density matrix, through a partial trace of a quantum state in a lattice <cite>basis</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.representative" title="quspin.basis.user_basis.representative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">representative</span></code></a>(states[,&nbsp;out,&nbsp;return_g,&nbsp;…])</td>
<td>Maps states to their representatives under the <cite>basis</cite> symmetries.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.state_to_int" title="quspin.basis.user_basis.state_to_int"><code class="xref py py-obj docutils literal notranslate"><span class="pre">state_to_int</span></code></a>(state)</td>
<td>Finds integer representation of a state defined in string format.</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.N" title="quspin.basis.user_basis.N"><code class="xref py py-obj docutils literal notranslate"><span class="pre">N</span></code></a></td>
<td>int: number of sites the basis is constructed with.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.Ns" title="quspin.basis.user_basis.Ns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ns</span></code></a></td>
<td>int: number of states in the Hilbert space.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.blocks" title="quspin.basis.user_basis.blocks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">blocks</span></code></a></td>
<td>dict: contains the quantum numbers (blocks) for the symmetry sectors.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.description" title="quspin.basis.user_basis.description"><code class="xref py py-obj docutils literal notranslate"><span class="pre">description</span></code></a></td>
<td>str: information about <cite>basis</cite> object.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.operators" title="quspin.basis.user_basis.operators"><code class="xref py py-obj docutils literal notranslate"><span class="pre">operators</span></code></a></td>
<td>set: set of available operator strings.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quspin.basis.user_basis.sps" title="quspin.basis.user_basis.sps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sps</span></code></a></td>
<td>int: number of states per site (i.e.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quspin.basis.user_basis.states" title="quspin.basis.user_basis.states"><code class="xref py py-obj docutils literal notranslate"><span class="pre">states</span></code></a></td>
<td>numpy.ndarray(int): basis states stored in their integer representation.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="quspin.basis.user_basis.N">
<code class="descname">N</code><a class="headerlink" href="#quspin.basis.user_basis.N" title="Permalink to this definition">¶</a></dt>
<dd><p>int: number of sites the basis is constructed with.</p>
</dd></dl>

<dl class="attribute">
<dt id="quspin.basis.user_basis.Ns">
<code class="descname">Ns</code><a class="headerlink" href="#quspin.basis.user_basis.Ns" title="Permalink to this definition">¶</a></dt>
<dd><p>int: number of states in the Hilbert space.</p>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.Op">
<code class="descname">Op</code><span class="sig-paren">(</span><em>opstr</em>, <em>indx</em>, <em>J</em>, <em>dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.Op" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs operator from a site-coupling list and an operator string in a lattice basis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>opstr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">Operator string in the lattice basis format. For instance:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
</pre></div>
</div>
</dd>
<dt><strong>indx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list(int)</span></dt>
<dd><p class="first">List of integers to designate the sites the lattice basis operator is defined on. For instance:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</dd>
<dt><strong>J</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd><p class="first last">Coupling strength.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘type’</span></dt>
<dd><p class="first last">Data type (e.g. numpy.float64) to construct the operator with.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tuple</strong></dt>
<dd><dl class="first last docutils">
<dt><cite>(ME,row,col)</cite>, where</dt>
<dd><ul class="first last simple">
<li>numpy.ndarray(scalar): <cite>ME</cite>: matrix elements of type <cite>dtype</cite>.</li>
<li><dl class="first docutils">
<dt>numpy.ndarray(int): <cite>row</cite>: row indices of matrix representing the operator in the lattice basis,</dt>
<dd>such that <cite>row[i]</cite> is the row index of <cite>ME[i]</cite>.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>numpy.ndarray(int): <cite>col</cite>: column index of matrix representing the operator in the lattice basis,</dt>
<dd>such that <cite>col[i]</cite> is the column index of <cite>ME[i]</cite>.</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="mf">1.41</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ME</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">Op</span><span class="p">(</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.Op_bra_ket">
<code class="descname">Op_bra_ket</code><span class="sig-paren">(</span><em>opstr</em>, <em>indx</em>, <em>J</em>, <em>dtype</em>, <em>ket_states</em>, <em>reduce_output=True</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.Op_bra_ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds bra states which connect given ket states by operator from a site-coupling list and an operator string.</p>
<p>Given a set of ket states <span class="math notranslate nohighlight">\(|s\rangle\)</span>, the function returns the bra states <span class="math notranslate nohighlight">\(\langle s'|\)</span> which connect to them through an operator, together with the corresponding matrix elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>opstr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">Operator string in the lattice basis format. For instance:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
</pre></div>
</div>
</dd>
<dt><strong>indx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list(int)</span></dt>
<dd><p class="first">List of integers to designate the sites the lattice basis operator is defined on. For instance:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</dd>
<dt><strong>J</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd><p class="first last">Coupling strength.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘type’</span></dt>
<dd><p class="first last">Data type (e.g. numpy.float64) to construct the matrix elements with.</p>
</dd>
<dt><strong>ket_states</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray(int)</span></dt>
<dd><p class="first last">Ket states in integer representation. Must be of same data type as <cite>basis</cite>.</p>
</dd>
<dt><strong>reduce_output: bool, optional</strong></dt>
<dd><p class="first last">If set to <cite>True</cite>, the returned arrays have the same size as <cite>ket_states</cite>; If set to <cite>False</cite> zeros are purged.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tuple</strong></dt>
<dd><dl class="first last docutils">
<dt><cite>(ME,bra,ket)</cite>, where</dt>
<dd><ul class="first last simple">
<li>numpy.ndarray(scalar): <cite>ME</cite>: matrix elements of type <cite>dtype</cite>, which connects the ket and bra states.</li>
<li><dl class="first docutils">
<dt>numpy.ndarray(int): <cite>bra</cite>: bra states, obtained by applying the matrix representing the operator in the lattice basis,</dt>
<dd>to the ket states, such that <cite>bra[i]</cite> corresponds to <cite>ME[i]</cite> and connects to <cite>ket[i]</cite>.</dd>
</dl>
</li>
<li>numpy.ndarray(int): <cite>ket</cite>: ket states, such that <cite>ket[i]</cite> corresponds to <cite>ME[i]</cite> and connects to <cite>bra[i]</cite>.</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ul class="simple">
<li>Similar to <cite>Op</cite> but instead of returning the matrix indices (row,col), it returns the states (bra,ket) in integer representation.</li>
<li>Does NOT require the full basis (see <cite>basis</cite> optional argument <cite>make_basis</cite>).</li>
<li>If a state from <cite>ket_states</cite> does not have a non-zero matrix element, it is removed from the returned list. See otional argument <cite>reduce_output</cite>.</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="mf">1.41</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ME</span><span class="p">,</span> <span class="n">bra</span><span class="p">,</span> <span class="n">ket</span> <span class="o">=</span> <span class="n">Op_bra_ket</span><span class="p">(</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">ket_states</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="quspin.basis.user_basis.blocks">
<code class="descname">blocks</code><a class="headerlink" href="#quspin.basis.user_basis.blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>dict: contains the quantum numbers (blocks) for the symmetry sectors.</p>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.check_hermitian">
<code class="descname">check_hermitian</code><span class="sig-paren">(</span><em>static</em>, <em>dynamic</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.check_hermitian" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks operator string lists for hermiticity of the combined operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>static: list</strong></dt>
<dd><p class="first last">Static operators formatted to be passed into the static argument of the <cite>hamiltonian</cite> class.</p>
</dd>
<dt><strong>dynamic: list</strong></dt>
<dd><p class="first last">Dynamic operators formatted to be passed into the dynamic argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.check_pcon">
<code class="descname">check_pcon</code><span class="sig-paren">(</span><em>static</em>, <em>dynamic</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.check_pcon" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks operator string lists for particle number (magnetisation) conservartion of the combined operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>static: list</strong></dt>
<dd><p class="first last">Static operators formatted to be passed into the static argument of the <cite>hamiltonian</cite> class.</p>
</dd>
<dt><strong>dynamic: list</strong></dt>
<dd><p class="first last">Dynamic operators formatted to be passed into the dynamic argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.check_symm">
<code class="descname">check_symm</code><span class="sig-paren">(</span><em>static</em>, <em>dynamic</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.check_symm" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks operator string lists for the required symmetries of the combined operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>static: list</strong></dt>
<dd><p class="first last">Static operators formatted to be passed into the static argument of the <cite>hamiltonian</cite> class.</p>
</dd>
<dt><strong>dynamic: list</strong></dt>
<dd><p class="first last">Dynamic operators formatted to be passed into the dynamic argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="quspin.basis.user_basis.description">
<code class="descname">description</code><a class="headerlink" href="#quspin.basis.user_basis.description" title="Permalink to this definition">¶</a></dt>
<dd><p>str: information about <cite>basis</cite> object.</p>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.ent_entropy">
<code class="descname">ent_entropy</code><span class="sig-paren">(</span><em>state</em>, <em>sub_sys_A=None</em>, <em>density=True</em>, <em>subsys_ordering=True</em>, <em>return_rdm=None</em>, <em>enforce_pure=False</em>, <em>return_rdm_EVs=False</em>, <em>sparse=False</em>, <em>alpha=1.0</em>, <em>sparse_diag=True</em>, <em>maxiter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.ent_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates entanglement entropy of subsystem A and the corresponding reduced density matrix</p>
<div class="math notranslate nohighlight">
\[S_\mathrm{ent}(\alpha) = \frac{1}{N}\frac{1}{1-\alpha}\log \mathrm{tr}_{A} \left( \mathrm{tr}_{A^c} \vert\psi\rangle\langle\psi\vert \right)^\alpha \]</div>
<p>where the normalization <span class="math notranslate nohighlight">\(N\)</span> can be switched on and off using the optional argument <cite>density</cite>.</p>
<p><strong>Note:</strong> The logarithm used is the natural logarithm (base e).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">obj</span></dt>
<dd><p class="first">State of the quantum system. Can be either one of:</p>
<blockquote class="last">
<div><ul class="simple">
<li>numpy.ndarray [shape (Ns,)]: pure state (default).</li>
<li>numpy.ndarray [shape (Ns,Ns)]: density matrix (DM).</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>sub_sys_A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple/list, optional</span></dt>
<dd><p class="first last">Defines the sites contained in subsystem A [by python convention the first site of the chain is labelled j=0].
Default is <cite>tuple(range(N//2))</cite> with <cite>N</cite> the number of lattice sites.</p>
</dd>
<dt><strong>density</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Toggles whether to return entanglement entropy normalized by the number of sites in the subsystem.</p>
</dd>
<dt><strong>return_rdm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first">Toggles returning the reduced DM. Can be tierh one of:</p>
<blockquote class="last">
<div><ul class="simple">
<li>“A”: returns reduced DM of subsystem A.</li>
<li>“B”: returns reduced DM of subsystem B.</li>
<li>“both”: returns reduced DM of both A and B subsystems.</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>enforce_pure</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether or not to assume <cite>state</cite> is a collection of pure states or a mixed density matrix, if
it is a square array. Default is <cite>False</cite>.</p>
</dd>
<dt><strong>subsys_ordering</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether or not to reorder the sites in <cite>sub_sys_A</cite> in ascending order. Default is <cite>True</cite>.</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether or not to return a sparse DM. Default is <cite>False</cite>.</p>
</dd>
<dt><strong>return_rdm_EVs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether or not to return the eigenvalues of rthe educed DM. If <cite>return_rdm</cite> is specified,
the eigenvalues of the corresponding DM are returned. If <cite>return_rdm</cite> is NOT specified, 
the spectrum of <cite>rdm_A</cite> is returned by default. Default is <cite>False</cite>.</p>
</dd>
<dt><strong>alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Renyi <span class="math notranslate nohighlight">\(\alpha\)</span> parameter for the entanglement entropy. Default is <span class="math notranslate nohighlight">\(\alpha=1\)</span>.</p>
</dd>
<dt><strong>sparse_diag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">When <cite>sparse=True</cite>, this flag enforces the use of
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/generated/scipy.sparse.linalg.eigsh.html">scipy.sparse.linalg.eigsh()</a>
to calculate the eigenvaues of the reduced DM.</p>
</dd>
<dt><strong>maxiter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Specifies the number of iterations for Lanczos diagonalisation. Look up documentation for 
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/generated/scipy.sparse.linalg.eigsh.html">scipy.sparse.linalg.eigsh()</a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dict</strong></dt>
<dd><dl class="first last docutils">
<dt>Dictionary with following keys, depending on input parameters:</dt>
<dd><ul class="first last simple">
<li>“Sent_A”: entanglement entropy of subsystem A (default).</li>
<li>“Sent_B”: entanglement entropy of subsystem B.</li>
<li>“p_A”: singular values of reduced DM of subsystem A (default).</li>
<li>“p_B”: singular values of reduced DM of subsystem B.</li>
<li>“rdm_A”: reduced DM of subsystem A.</li>
<li>“rdm_B”: reduced DM of subsystem B.</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Algorithm is based on both partial tracing and sigular value decomposition (SVD), optimised for speed.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ent_entropy</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">sub_sys_A</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span><span class="n">return_rdm</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="n">enforce_pure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">return_rdm_EVs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                            <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">sparse_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">subsys_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.expanded_form">
<code class="descname">expanded_form</code><span class="sig-paren">(</span><em>static=[]</em>, <em>dynamic=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.expanded_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits up operator strings containing “x” and “y” into operator combinations of “+” and “-“. This function is useful for higher spin hamiltonians where “x” and “y” operators are not appropriate operators.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>static: list</strong></dt>
<dd><p class="first last">Static operators formatted to be passed into the static argument of the <cite>hamiltonian</cite> class.</p>
</dd>
<dt><strong>dynamic: list</strong></dt>
<dd><p class="first last">Dynamic operators formatted to be passed into the dynamic argument of the <cite>hamiltonian</cite> class.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tuple</strong></dt>
<dd><dl class="first last docutils">
<dt><cite>(static, dynamic)</cite>, where</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>list: <cite>static</cite>: operator strings with “x” and “y” expanded into “+” and “-“, formatted to </dt>
<dd>be passed into the static argument of the <cite>hamiltonian</cite> class.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>list: <cite>dynamic</cite>: operator strings with “x” and “y” expanded into “+” and “-“, formatted to </dt>
<dd>be passed into the dynamic argument of the <cite>hamiltonian</cite> class.</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function works with the <cite>tensor_basis</cite> and other basis which use the “|” symbol in the opstr.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">static</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;xx&quot;</span><span class="p">,[[</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]],[</span><span class="s2">&quot;yy&quot;</span><span class="p">,[[</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dynamic</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;y&quot;</span><span class="p">,[[</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">,[]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expanded_form</span><span class="p">(</span><span class="n">static</span><span class="p">,</span><span class="n">dynamic</span><span class="p">)</span>               
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.get_amp">
<code class="descname">get_amp</code><span class="sig-paren">(</span><em>states</em>, <em>out=None</em>, <em>amps=None</em>, <em>mode='representative'</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.get_amp" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the rescale factor of state amplitudes between the symmetry-reduced and full basis.</p>
<p>Given a quantum state <span class="math notranslate nohighlight">\(s\)</span> and a state amplitude in the full basis <span class="math notranslate nohighlight">\(\psi_s\)</span>, its representative (under the symemtries) 
<span class="math notranslate nohighlight">\(r(s)\)</span> with a corresponding amplitude <span class="math notranslate nohighlight">\(\psi^\text{sym}_r\)</span>, the function computes the ratio <span class="math notranslate nohighlight">\(C\)</span>, defined as</p>
<div class="math notranslate nohighlight">
\[\psi_s = C\psi_r^\text{sym} \]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>states</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like(int)</span></dt>
<dd><p class="first last">Fock-basis (z-basis) states to find the amplitude rescale factor <span class="math notranslate nohighlight">\(C\)</span> of. States are stored in integer representations.</p>
</dd>
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray(float), optional</span></dt>
<dd><p class="first last">variable to store the rescale factors <span class="math notranslate nohighlight">\(C\)</span> of the states in. Must be a real or complex-valued <cite>numpy.ndarray</cite> of the same shape as <cite>states</cite>.</p>
</dd>
<dt><strong>amps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray(float), optional</span></dt>
<dd><p class="first last">array of amplitudes to rescale by the amplitude factor <span class="math notranslate nohighlight">\(C\)</span> (see <cite>mode</cite>). Updated in-place. Must be a real or complex-valued <cite>numpy.ndarray</cite> of the same shape as <cite>states</cite>.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string, optional</span></dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>if <cite>mode=’representative’</cite> (default), then the function assumes that</dt>
<dd><ol class="first last lowerroman">
<li><cite>states</cite> already contains representatives (i.e. states in the symmetry-reduced basis);</li>
<li><cite>amps</cite> (if passed) are amplitudes in the symmetry-reduced basis (<span class="math notranslate nohighlight">\(\psi_r^\text{symm}\)</span>). The function will update <cite>amps</cite> in-place to <span class="math notranslate nohighlight">\(\psi_s\)</span>.</li>
</ol>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>if <cite>mode=’full_basis’</cite>, then the function assumes that</dt>
<dd><ol class="first last lowerroman">
<li><cite>states</cite> contains full-basis states (the funciton will compute the corresponding representatives);</li>
<li><dl class="first docutils">
<dt><cite>amps</cite> (if passed) are amplitudes in the full basis (<span class="math notranslate nohighlight">\(\psi_s\)</span>). The function will update <cite>amps</cite> in-place to <span class="math notranslate nohighlight">\(\psi_r^\text{symm}\)</span>;</dt>
<dd><strong>Note</strong>: the function will also update the variable <cite>states</cite> in place with the corresponding representatives.</dd>
</dl>
</li>
</ol>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>array_like(float)</strong></dt>
<dd><p class="first last">amplitude rescale factor <span class="math notranslate nohighlight">\(C\)</span> (see expression above).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ul class="simple">
<li>Particularly useful when a given operation cannot be carried away in the symmetry-reduced basis in a straightforward manner.</li>
<li>To transform an entire state from a symmetry-reduced basis to the full (symmetry-free) basis, use the <cite>basis.get_vec()</cite> function.</li>
<li>Returns zero, if the state passed to the function is not part of the symmetry-reduced basis.</li>
<li>If <cite>amps</cite> is passed, the user has to make sure that the input data in <cite>amps</cite> correspond to the <cite>states</cite>.</li>
<li>The function assumes that <cite>states</cite> comply with the particle conservation symmetry the <cite>basis</cite> was constructed with.</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">get_amp</span><span class="p">(</span><span class="n">states</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">amps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;representative&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.get_proj">
<code class="descname">get_proj</code><span class="sig-paren">(</span><em>dtype</em>, <em>pcon=False</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.get_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates transformation/projector from symmetry-reduced basis to full (symmetry-free) basis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘type’</span></dt>
<dd><p class="first last">Data type (e.g. numpy.float64) to construct the projector with.</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether or not the output should be in sparse format. Default is <cite>True</cite>.</p>
</dd>
<dt><strong>pcon</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether or not to return the projector to the particle number (magnetisation) conserving basis 
(useful in bosonic/single particle systems). Default is <cite>pcon=False</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>scipy.sparse.csc_matrix</strong></dt>
<dd><p class="first last">Transformation/projector between the symmetry-reduced and the full basis.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Particularly useful when a given operation canot be carried away in the symmetry-reduced basis
in a straightforward manner.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">get_proj</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span><span class="n">pcon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.get_vec">
<code class="descname">get_vec</code><span class="sig-paren">(</span><em>v0</em>, <em>sparse=True</em>, <em>pcon=False</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.get_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms state from symmetry-reduced basis to full (symmetry-free) basis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>v0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">Contains in its columns the states in the symmetry-reduced basis.</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether or not the output should be in sparse format. Default is <cite>True</cite>.</p>
</dd>
<dt><strong>pcon</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether or not to return the projector to the particle number (magnetisation) conserving basis 
(useful in bosonic/single particle systems). Default is <cite>pcon=False</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>numpy.ndarray</strong></dt>
<dd><p class="first last">Array containing the state <cite>v0</cite> in the full basis.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Particularly useful when a given operation cannot be carried away in the symmetry-reduced basis
in a straightforward manner.</p>
<p>Supports parallelisation to multiple states listed in the columns.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v_full</span> <span class="o">=</span> <span class="n">get_vec</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">v_full</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.index">
<code class="descname">index</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the index of user-defined Fock state in any lattice basis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>s</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{str, int}</span></dt>
<dd><p class="first last">Defines the Fock state with number of particles (spins) per site in underlying lattice <cite>basis</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>int</strong></dt>
<dd><p class="first last">Position of the Fock state in the lattice basis.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Particularly useful for defining initial Fock states through a unit vector in the direction specified
by <cite>index()</cite>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i0</span> <span class="o">=</span> <span class="n">index</span><span class="p">(</span><span class="s2">&quot;111000&quot;</span><span class="p">)</span> <span class="c1"># pick state from basis set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">Ns</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># define state corresponding to the string &quot;111000&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.inplace_Op">
<code class="descname">inplace_Op</code><span class="sig-paren">(</span><em>v_in</em>, <em>opstr</em>, <em>indx</em>, <em>J</em>, <em>dtype</em>, <em>transposed=False</em>, <em>conjugated=False</em>, <em>v_out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.inplace_Op" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the action of an operator on a state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>v_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">state (or states stored in columns) to act on with the operator.</p>
</dd>
<dt><strong>opstr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">Operator string in the lattice basis format. For instance:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
</pre></div>
</div>
</dd>
<dt><strong>indx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list(int)</span></dt>
<dd><p class="first">List of integers to designate the sites the lattice basis operator is defined on. For instance:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</dd>
<dt><strong>J</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd><p class="first last">Coupling strength.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘type’</span></dt>
<dd><p class="first last">Data type (e.g. <cite>numpy.float64</cite>) to construct the operator with.</p>
</dd>
<dt><strong>transposed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">if <cite>True</cite> this function will act with the trasposed operator.</p>
</dd>
<dt><strong>conjugated</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">if <cite>True</cite> this function will act with the conjugated operator.</p>
</dd>
<dt><strong>v_out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">output array, must be the same shape as <cite>v_in</cite> and must match the type of the output.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>numpy.ndarray</strong></dt>
<dd><ul class="first last simple">
<li>if <cite>v_out</cite> is not <cite>None</cite>, this function modifies <cite>v_out</cite> inplace and returns it.</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function works with the <cite>tensor_basis</cite> and other basis which use the “|” symbol in the opstr.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="mf">1.41</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opstr</span> <span class="o">=</span> <span class="s2">&quot;zz&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ME</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">Op</span><span class="p">(</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.int_to_state">
<code class="descname">int_to_state</code><span class="sig-paren">(</span><em>state</em>, <em>bracket_notation=True</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.int_to_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds string representation of a state defined in integer representation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Defines the Fock state in integer representation in underlying lattice <cite>basis</cite>.</p>
</dd>
<dt><strong>bracket_notation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Toggles whether to return the state in <a href="#id2"><span class="problematic" id="id3">|</span></a>str&gt; notation.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>str</strong></dt>
<dd><p class="first last">String corresponding to the Fock <cite>state</cite> in the lattice basis.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function is the einverse of <cite>state_to_int</cite>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># pick state from basis set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_str</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">int_to_state</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s_str</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.make">
<code class="descname">make</code><span class="sig-paren">(</span><em>Ns_block_est=None</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.make" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the entire basis by calling the basis constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>Ns_block_est: int, optional</strong></dt>
<dd><p class="first last">Overwrites the internal estimate of the size of the reduced Hilbert space for the given symmetries. This can be used to help conserve memory if the exact size of the H-space is known ahead of time.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>int</strong></dt>
<dd><p class="first last">Total number of states in the (symmetry-reduced) Hilbert space.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span><span class="p">,</span> <span class="n">Nup</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">=</span><span class="n">spin_basis_general</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="n">Nup</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">.</span><span class="n">make</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.normalization">
<code class="descname">normalization</code><span class="sig-paren">(</span><em>states</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.normalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes normalization of <cite>basis</cite> states.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>states</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like(int)</span></dt>
<dd><p class="first last">Fock-basis (z-basis) states to find the normalizations of. States are stored in integer representations.</p>
</dd>
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray(unsigned int), optional</span></dt>
<dd><p class="first last">variable to store the normalizations of the states in. Must be a <cite>numpy.ndarray</cite> of datatype <cite>unsigned int</cite> (e.g. <cite>numpy.uint16</cite>), and same shape as <cite>states</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>array_like(int)</strong></dt>
<dd><p class="first last">normalizations of <cite>states</cite> for the given (symmetry-reduced) <cite>basis</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ul class="simple">
<li>Returns zero, if the state is not part of the symmetry-reduced basis.</li>
<li>The normalizations can be used to compute matrix elements in the symmetry-reduced basis.</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">=</span><span class="n">spin_basis_general</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="n">Nup</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="mi">17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">norm_s</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">normalization</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">norm_s</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="quspin.basis.user_basis.operators">
<code class="descname">operators</code><a class="headerlink" href="#quspin.basis.user_basis.operators" title="Permalink to this definition">¶</a></dt>
<dd><p>set: set of available operator strings.</p>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.partial_trace">
<code class="descname">partial_trace</code><span class="sig-paren">(</span><em>state</em>, <em>sub_sys_A=None</em>, <em>subsys_ordering=True</em>, <em>return_rdm='A'</em>, <em>enforce_pure=False</em>, <em>sparse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.partial_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates reduced density matrix, through a partial trace of a quantum state in a lattice <cite>basis</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">obj</span></dt>
<dd><p class="first">State of the quantum system. Can be either one of:</p>
<blockquote class="last">
<div><ul class="simple">
<li>numpy.ndarray [shape (Ns,)]: pure state (default).</li>
<li>numpy.ndarray [shape (Ns,Ns)]: density matrix (DM).</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>sub_sys_A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple/list, optional</span></dt>
<dd><p class="first last">Defines the sites contained in subsystem A [by python convention the first site of the chain is labelled j=0].
Default is <cite>tuple(range(N//2))</cite> with <cite>N</cite> the number of lattice sites.</p>
</dd>
<dt><strong>return_rdm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first">Toggles returning the reduced DM. Can be tierh one of:</p>
<blockquote class="last">
<div><ul class="simple">
<li>“A”: returns reduced DM of subsystem A.</li>
<li>“B”: returns reduced DM of subsystem B.</li>
<li>“both”: returns reduced DM of both A and B subsystems.</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>subsys_ordering</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether or not to reorder the sites in <cite>sub_sys_A</cite> in ascending order. Default is <cite>True</cite>.</p>
</dd>
<dt><strong>enforce_pure</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether or not to assume <cite>state</cite> is a colelction of pure states or a mixed density matrix, if
it is a square array. Default is <cite>False</cite>.</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether or not to return a sparse DM. Default is <cite>False</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>numpy.ndarray</strong></dt>
<dd><p class="first last">Density matrix associated with <cite>state</cite>. Depends on optional arguments.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">partial_trace</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">sub_sys_A</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">),</span><span class="n">return_rdm</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="n">enforce_pure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">subsys_ordering</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.representative">
<code class="descname">representative</code><span class="sig-paren">(</span><em>states</em>, <em>out=None</em>, <em>return_g=False</em>, <em>return_sign=False</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.representative" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps states to their representatives under the <cite>basis</cite> symmetries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>states</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like(int)</span></dt>
<dd><p class="first last">Fock-basis (z-basis) states to find the representatives of. States are stored in integer representations.</p>
</dd>
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray(int), optional</span></dt>
<dd><p class="first last">variable to store the representative states in. Must be a <cite>numpy.ndarray</cite> of same datatype as <cite>basis</cite>, and same shape as <cite>states</cite>.</p>
</dd>
<dt><strong>return_g</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">if set to <cite>True</cite>, the function also returns the integer <cite>g</cite> corresponding to the number of times each basis symmetry needs to be applied to a given state to obtain its representative.</p>
</dd>
<dt><strong>return_sign</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">if set to <cite>True</cite>, the function returns the <cite>sign</cite> of the representative relative to the original state (nontrivial only for fermionic bases).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tuple</strong></dt>
<dd><p class="first last">( representatives, g_array, sign_array )
* array_like(int): <cite>representatives</cite>: Representatives under <cite>basis</cite> symmetries, corresponding to <cite>states</cite>.
* array_like(int): <cite>g_array</cite> of size (number of states, number of symmetries). Requires <cite>return_g=True</cite>. Contains integers corresponding to the number of times each basis symmetry needs to be applied to a given state to obtain its representative.
* array_like(int): <cite>sign_array</cite> of size (number of states,). Requires <cite>return_sign=True</cite>. Contains <cite>sign</cite> of the representative relative to the original state (nontrivial only for fermionic bases).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="o">=</span><span class="n">spin_basis_general</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="n">Nup</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="mi">17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">representative</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="quspin.basis.user_basis.sps">
<code class="descname">sps</code><a class="headerlink" href="#quspin.basis.user_basis.sps" title="Permalink to this definition">¶</a></dt>
<dd><p>int: number of states per site (i.e. the on-site Hilbert space dimension).</p>
</dd></dl>

<dl class="method">
<dt id="quspin.basis.user_basis.state_to_int">
<code class="descname">state_to_int</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#quspin.basis.user_basis.state_to_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds integer representation of a state defined in string format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Defines the Fock state with number of particles (spins) per site in underlying lattice <cite>basis</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>int</strong></dt>
<dd><p class="first last">Integer corresponding to the Fock <cite>state</cite> in the lattice basis.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function is the einverse of <cite>int_to_state</cite>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s_str</span> <span class="o">=</span> <span class="s2">&quot;111000&quot;</span> <span class="c1"># pick state from basis set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">state_to_int</span><span class="p">(</span><span class="n">s_str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="quspin.basis.user_basis.states">
<code class="descname">states</code><a class="headerlink" href="#quspin.basis.user_basis.states" title="Permalink to this definition">¶</a></dt>
<dd><p>numpy.ndarray(int): basis states stored in their integer representation.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../sources/generated/quspin.basis.user_basis.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuSpin 0.3.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../basis.html" >Basis module (<code class="docutils literal notranslate"><span class="pre">quspin.basis</span></code>)</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Phillip Weinberg and Marin Bukov.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>