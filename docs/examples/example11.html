
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-110543543-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>Sampling Expectation Values of Obsevables &#8212; QuSpin 0.3.2 documentation</title>
    <link rel="stylesheet" href="../static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuSpin 0.3.2 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="sampling-expectation-values-of-obsevables">
<span id="example11-label"></span><h1>Sampling Expectation Values of Obsevables<a class="headerlink" href="#sampling-expectation-values-of-obsevables" title="Permalink to this headline">¶</a></h1>
<p><a class="reference download internal" download="" href="../downloads/3db50b5758a7052d72549f2d8cda07ff/example11.py"><code class="xref download docutils literal notranslate"><span class="pre">download</span> <span class="pre">script</span></code></a></p>
<p>The example below demonstrates how to use the <cite>*_basis_general</cite> methods <cite>Op_bra_ket()</cite> and <cite>representative()</cite> which do not require computing all basis states.</p>
</div>
<div class="section" id="physics-setup">
<h1>Physics Setup<a class="headerlink" href="#physics-setup" title="Permalink to this headline">¶</a></h1>
<p>The expectation value of an operator <span class="math notranslate nohighlight">\(H\)</span> in a state <span class="math notranslate nohighlight">\(\psi\)</span> can be written as</p>
<div class="math notranslate nohighlight">
\[\langle\psi|H|\psi\rangle = \sum_{s,s'} \psi_s^\ast H_{ss'}\psi_{s'} = \sum_s |\psi_s|^2 E_{s},\qquad E_s = \frac{1}{\psi_s}\sum_{s'}H_{ss'}\psi_{s'},\]</div>
<p>where <span class="math notranslate nohighlight">\(\{|s\rangle\}_s\)</span> can be any basis, in particular the Fock (<span class="math notranslate nohighlight">\(z\)</span>-) basis used in QuSpin.</p>
<p>The above expression suggests that one can use sampling methods, such as Monte Carlo, to estimate the expectation value of <span class="math notranslate nohighlight">\(\langle\psi|H|\psi\rangle\)</span> using the quantity <span class="math notranslate nohighlight">\(E_s\)</span> (sometimes referred to as local energy) evaluated in samples drawn from the probability distribution <span class="math notranslate nohighlight">\(p_s=|\psi_s|^2\)</span>. If we have: (i) a function <span class="math notranslate nohighlight">\(s\mapsto\psi_s\)</span> which compues the amplitudes for every spin configuration <span class="math notranslate nohighlight">\(s\)</span>, and (ii) the matrix elements <span class="math notranslate nohighlight">\(H_{ss'}\)</span>, then</p>
<div class="math notranslate nohighlight">
\[\langle\psi|H|\psi\rangle \approx \frac{1}{N}\sum_{s\in\mathcal{S}} E_s,\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> contains <span class="math notranslate nohighlight">\(N\)</span> spin configurations sampled from <span class="math notranslate nohighlight">\(p_s=|\psi_s|^2\)</span>.</p>
<p>Since this procedure does not require the the state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> to be normalized, ideas along these lines allow to look for variational approximations to the wavefunction <span class="math notranslate nohighlight">\(\psi_s\)</span> in large system sizes, for instance with the help of restricted Boltzmann machines [<a class="reference external" href="https://arxiv.org/abs/1606.02318">arXiv:1606.02318</a>].</p>
<p>In the example below, we assume that we already have a quantum state <span class="math notranslate nohighlight">\(\psi_s\)</span> in the Fock basis, and we sample the expectation value of an operator <cite>H</cite> using the <cite>*_basis_general</cite> methods <cite>Op_bra_ket()</cite> and <cite>representative()</cite> [cf. code lines 120, 139, 167 below]. These methods do not require to compute the full basis, and thus allow to develop techniques for reaching system sizes beyond exact diagonalization.</p>
</div>
<div class="section" id="script">
<h1>Script<a class="headerlink" href="#script" title="Permalink to this headline">¶</a></h1>
<p><a class="reference download internal" download="" href="../downloads/3db50b5758a7052d72549f2d8cda07ff/example11.py"><code class="xref download docutils literal notranslate"><span class="pre">download</span> <span class="pre">script</span></code></a></p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span><span class="nn">os</span>
<span class="c1"># line 4 and line 5 below are for development purposes and can be removed</span>
<span class="n">qspin_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span><span class="s2">&quot;../../&quot;</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">qspin_path</span><span class="p">)</span>
<span class="c1">###########################################################################</span>
<span class="c1">#                            example 11                                   #</span>
<span class="c1">#  In this script we demonstrate how to use QuSpin&#39;s methods of           #</span>
<span class="c1">#  the general_basis class which do not require explicit calculation      #</span>
<span class="c1">#  of the basis itself. Using the J1-J2 model on a square lattice, we     #</span>
<span class="c1">#  show how  to estimate the energy of a state using Monte-Carlo sampling.#</span>
<span class="c1">###########################################################################</span>
<span class="kn">from</span> <span class="nn">quspin.operators</span> <span class="kn">import</span> <span class="n">hamiltonian</span>
<span class="kn">from</span> <span class="nn">quspin.basis</span> <span class="kn">import</span> <span class="n">spin_basis_general</span>
<span class="kn">from</span> <span class="nn">quspin.operators._make_hamiltonian</span> <span class="kn">import</span> <span class="n">_consolidate_static</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">comb</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#fixes seed of rng</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span> <span class="c1"># timing package</span>
<span class="c1">#</span>
<span class="n">ti</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span> <span class="c1"># start timer</span>
<span class="c1">###### define model parameters ######</span>
<span class="n">J1</span><span class="o">=</span><span class="mf">1.0</span> <span class="c1"># spin=spin interaction</span>
<span class="n">J2</span><span class="o">=</span><span class="mf">0.5</span> <span class="c1"># magnetic field strength</span>
<span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span> <span class="c1"># linear dimension of spin 1 2d lattice</span>
<span class="n">N_2d</span> <span class="o">=</span> <span class="n">Lx</span><span class="o">*</span><span class="n">Ly</span> <span class="c1"># number of sites for spin 1</span>
<span class="c1">#</span>
<span class="c1">###### setting up user-defined symmetry transformations for 2d lattice ######</span>
<span class="n">sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N_2d</span><span class="p">)</span> <span class="c1"># sites [0,1,2,....]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">sites</span><span class="o">%</span><span class="n">Lx</span> <span class="c1"># x positions for sites</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">sites</span><span class="o">//</span><span class="n">Lx</span> <span class="c1"># y positions for sites</span>
<span class="c1">#</span>
<span class="n">T_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">Lx</span><span class="o">*</span><span class="n">y</span> <span class="c1"># translation along x-direction</span>
<span class="n">T_y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span><span class="n">Lx</span><span class="o">*</span><span class="p">((</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Ly</span><span class="p">)</span> <span class="c1"># translation along y-direction</span>
<span class="c1">#</span>
<span class="n">T_a</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">Lx</span><span class="o">*</span><span class="p">((</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Ly</span><span class="p">)</span> <span class="c1"># translation along anti-diagonal</span>
<span class="n">T_d</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Lx</span> <span class="o">+</span> <span class="n">Lx</span><span class="o">*</span><span class="p">((</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">Ly</span><span class="p">)</span> <span class="c1"># translation along diagonal</span>
<span class="c1">#</span>
<span class="n">Z</span>   <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">sites</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># spin inversion</span>
<span class="c1">#</span>
<span class="c1">###### setting up operator string for Hamiltonian matrix elements H_{ss&#39;} ######</span>
<span class="c1"># setting up site-coupling lists</span>
<span class="n">J1_list</span><span class="o">=</span><span class="p">[[</span><span class="n">J1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">T_x</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[[</span><span class="n">J1</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">T_y</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="p">)]</span>
<span class="n">J2_list</span><span class="o">=</span><span class="p">[[</span><span class="n">J2</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">T_d</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[[</span><span class="n">J2</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">T_a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="p">)]</span>
<span class="c1"># setting up opstr list</span>
<span class="n">static</span><span class="o">=</span><span class="p">[[</span><span class="s2">&quot;xx&quot;</span><span class="p">,</span><span class="n">J1_list</span><span class="p">],[</span><span class="s2">&quot;yy&quot;</span><span class="p">,</span><span class="n">J1_list</span><span class="p">],[</span><span class="s2">&quot;zz&quot;</span><span class="p">,</span><span class="n">J1_list</span><span class="p">],</span>  <span class="p">[</span><span class="s2">&quot;xx&quot;</span><span class="p">,</span><span class="n">J2_list</span><span class="p">],[</span><span class="s2">&quot;yy&quot;</span><span class="p">,</span><span class="n">J2_list</span><span class="p">],[</span><span class="s2">&quot;zz&quot;</span><span class="p">,</span><span class="n">J2_list</span><span class="p">]]</span>
<span class="c1"># convert static list to format which is easy to use with the basis_general.Op and basis_general.Op_bra_ket methods. </span>
<span class="n">static_formatted</span> <span class="o">=</span> <span class="n">_consolidate_static</span><span class="p">(</span><span class="n">static</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">###### setting up basis object without computing the basis ######</span>
<span class="c1"># Z-symmetry allowed in sampling since it commutes with the swap operation which proposes new configurations in MC</span>
<span class="n">basis</span> <span class="o">=</span> <span class="n">spin_basis_general</span><span class="p">(</span><span class="n">N_2d</span><span class="p">,</span> <span class="n">pauli</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">make_basis</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="n">N_2d</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="n">zblock</span><span class="o">=</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="c1"># examine basis: contains a single element because it is not calculated due to make_basis=False argument above.</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;basis is empty [note argument make_basis=False]&#39;</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">###### define quantum state to compute the energy of using Monte-Carlo sampling ######</span>
<span class="c1">#</span>
<span class="n">Ns</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">comb</span><span class="p">(</span><span class="n">N_2d</span><span class="p">,</span><span class="n">N_2d</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># number of states in Hilbert space </span>
<span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">Ns</span><span class="p">)</span> <span class="c1"># need NOT be normalized</span>
<span class="c1">#</span>
<span class="c1">##### define proposal function #####</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">swap_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot; Swap bits i, j in integer s.</span>

<span class="sd">	Parameters</span>
<span class="sd">	-----------</span>
<span class="sd">	s: array_like(int)</span>
<span class="sd">		array of spin configurations stored in their bit representation.</span>
<span class="sd">	i: array_like(int)</span>
<span class="sd">		array of positions to be swapped with the corresponding pair in j.</span>
<span class="sd">	j: array_like(int)</span>
<span class="sd">		array of positions to be swapped with the corresponding pair in i.</span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">right_shift</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">right_shift</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="p">)</span> <span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
<span class="c1">#</span>
<span class="c1">##### define function to compute the amplitude `psi_s` for every spin configuration `s` #####</span>
<span class="c1">#</span>
<span class="n">aux_basis</span> <span class="o">=</span> <span class="n">spin_basis_general</span><span class="p">(</span><span class="n">N_2d</span><span class="p">,</span><span class="n">make_basis</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">Nup</span><span class="o">=</span><span class="n">N_2d</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="n">zblock</span><span class="o">=</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span> <span class="c1"># auxiliary basis, only needed for probability_amplitude()</span>
<span class="n">basis_state_inds_dict</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">aux_basis</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
	<span class="n">basis_state_inds_dict</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_basis</span><span class="o">.</span><span class="n">states</span><span class="o">==</span><span class="n">s</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">probability_amplitude</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">psi</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39; Computes probability amplitude `psi_s` of quantum state `psi` in z-basis state `s`.</span>

<span class="sd">	Parameters</span>
<span class="sd">	----------</span>
<span class="sd">	s: array_like(int)</span>
<span class="sd">		array of spin configurations [stored in their bit representation] to compute their local energies `E_s`.</span>
<span class="sd">	psi_s: array</span>
<span class="sd">		(unnormalized) probability amplitude values, corresponding to the states `s`. </span>

<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">return</span> <span class="n">psi</span><span class="p">[[</span><span class="n">basis_state_inds_dict</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]]</span>
<span class="c1">#</span>
<span class="c1">##### define function to compute local energy `E_s` #####</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">compute_local_energy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">psi_s</span><span class="p">,</span><span class="n">psi</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Computes local energy E_s for a spin configuration s.</span>

<span class="sd">	Parameters</span>
<span class="sd">	----------</span>
<span class="sd">	s: array_like(int)</span>
<span class="sd">		array of spin configurations [stored in their bit representation] to compute their local energies `E_s`.</span>
<span class="sd">	psi_s: array</span>
<span class="sd">		(unnormalized) probability amplitude values, corresponding to the states `s`. </span>
<span class="sd">	psi: array</span>
<span class="sd">		(unnormalized) state which encodes the mapping $s \\to \\psi_s$.</span>
<span class="sd">		</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1"># preallocate variable</span>
	<span class="n">E_s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
	<span class="c1">#</span>
	<span class="c1"># to compute local energy `E_s` we need matrix elements `H_{ss&#39;}` for the operator `H`.</span>
	<span class="c1"># These can be computed by looping overthe static list without constructing the operator matrix. </span>
	<span class="k">for</span> <span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span> <span class="ow">in</span> <span class="n">static_formatted</span><span class="p">:</span>
		<span class="c1"># for every state `s`, compute the state it connects to `s&#39;`, and the corresponding matrix element `ME`</span>
		<span class="n">ME</span><span class="p">,</span><span class="n">bras</span><span class="p">,</span><span class="n">kets</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">Op_bra_ket</span><span class="p">(</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">reduce_output</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
		<span class="c1"># performs sum over `s&#39;`</span>
		<span class="n">E_s</span><span class="o">+=</span><span class="n">ME</span> <span class="o">*</span> <span class="n">probability_amplitude</span><span class="p">(</span><span class="n">bras</span><span class="p">,</span><span class="n">psi</span><span class="p">)</span>
	<span class="c1"># normalize by `psi_s`</span>
	<span class="n">E_s</span><span class="o">/=</span><span class="n">psi_s</span>
	<span class="k">return</span> <span class="n">E_s</span> 
<span class="c1">#</span>
<span class="c1">##### perform Monte Carlo sampling from `|psi_s|^2` ##### </span>
<span class="c1">#</span>
<span class="c1"># draw random spin configuratio</span>
<span class="n">s</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_2d</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">s</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">s</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;random initial state in bit representation:&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="c1"># transform state in bit representation</span>
<span class="n">s</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;same random initial state in integer representation:&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="c1"># compute representative of state `s` under basis symmetries (here only Z-symmetry)</span>
<span class="n">s</span><span class="o">=</span><span class="n">basis</span><span class="o">.</span><span class="n">representative</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;representative of random initial state in integer representation:&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="c1"># compute amplitude in state s</span>
<span class="n">psi_s</span><span class="o">=</span><span class="n">probability_amplitude</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">psi</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1"># define MC sampling parameters</span>
<span class="n">equilibration_time</span><span class="o">=</span><span class="mi">200</span>
<span class="c1"># number of MC sampling points</span>
<span class="n">N_MC_points</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="c1">#</span>
<span class="c1">##### run Markov chain MC #####</span>
<span class="c1">#</span>
<span class="c1"># compute all distinct site pairs to swap</span>
<span class="n">site_pairs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sites</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sites</span> <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="n">j</span><span class="p">])</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">site_pairs</span><span class="p">)</span>
<span class="c1"># branch MC chains: allows to run mutiple Markov chains in a vectorized fashion</span>
<span class="n">s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">N_MC_points</span><span class="p">)</span>
<span class="n">psi_s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">psi_s</span><span class="p">,</span><span class="n">N_MC_points</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1"># sample from MC after allowing the equilibration time to pass</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">equilibration_time</span><span class="p">):</span>
	<span class="c1"># draw set of pair of sites to swap their spins </span>
	<span class="n">inds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">site_pairs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">size</span><span class="o">=</span><span class="n">N_MC_points</span><span class="p">)</span>
	<span class="n">inds</span><span class="o">=</span><span class="n">site_pairs</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
	<span class="c1"># swap bits in spin configurations</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">swap_bits</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">inds</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">inds</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
	<span class="c1"># compute representatives or proposed configurations to bring them back to symmetry sector</span>
	<span class="c1"># CAUTION: MC works only with Z-symmetry because it commutes with swap_bits(); other symmetries break detailed balance.</span>
	<span class="n">t</span><span class="o">=</span><span class="n">basis</span><span class="o">.</span><span class="n">representative</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> 
	<span class="c1">### accept/reject new states</span>
	<span class="n">psi_t</span><span class="o">=</span><span class="n">probability_amplitude</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">)</span>
	<span class="n">eps</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="n">N_MC_points</span><span class="p">)</span>
	<span class="c1"># compute mask to determine whether to accept/reject every state</span>
	<span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">eps</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psi_s</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
	<span class="c1"># apply mask to only update accepted states</span>
	<span class="n">s</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
	<span class="n">psi_s</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">=</span><span class="n">psi_t</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
	<span class="c1">#</span>
	<span class="k">print</span><span class="p">(</span><span class="s1">&#39;{0:d}-th MC chain equilibration step complete&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
<span class="c1">#</span>
<span class="c1">##### compute MC-sampled energy #####</span>
<span class="c1"># compute local energy</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;computing local energies E_s...&#39;</span><span class="p">)</span>
<span class="n">E_s</span> <span class="o">=</span> <span class="n">compute_local_energy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">psi_s</span><span class="p">,</span><span class="n">psi</span><span class="p">)</span>
<span class="c1"># compute energy expectation and MC variance</span>
<span class="n">E_mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">E_s</span><span class="p">)</span>
<span class="n">E_var</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">E_s</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N_MC_points</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">#### compute exact expectation value #####</span>
<span class="c1"># compute full basis: required to construct the exact Hamiltonian</span>
<span class="n">basis</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="n">Ns_block_est</span><span class="o">=</span><span class="mi">16000</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="c1"># after the basis is made, printing the basis returns the states</span>
<span class="c1"># build Hamiltonian</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">hamiltonian</span><span class="p">(</span><span class="n">static</span><span class="p">,[],</span><span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">E_exact</span><span class="o">=</span><span class="n">H</span><span class="o">.</span><span class="n">expt_value</span><span class="p">(</span><span class="n">psi</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">psi</span><span class="p">))</span>
<span class="c1"># compare results</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;mean energy: {0:.4f}, MC variance: {1:.4f}, exact energy {2:.4f}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">E_mean</span><span class="p">,</span> <span class="n">E_var</span><span class="p">,</span> <span class="n">E_exact</span><span class="p">)</span> <span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;simulation took {0:.4f} sec&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">ti</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Sampling Expectation Values of Obsevables</a></li>
<li><a class="reference internal" href="#physics-setup">Physics Setup</a></li>
<li><a class="reference internal" href="#script">Script</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../sources/examples/example11.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">QuSpin 0.3.2 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Phillip Weinberg and Marin Bukov.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>
  </body>
</html>