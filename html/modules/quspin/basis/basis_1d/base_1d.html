
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-110543543-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>quspin.basis.basis_1d.base_1d &#8212; QuSpin 0.2.9 documentation</title>
    <link rel="stylesheet" href="../../../../static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '0.2.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../../static/jquery.js"></script>
    <script type="text/javascript" src="../../../../static/underscore.js"></script>
    <script type="text/javascript" src="../../../../static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">QuSpin 0.2.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for quspin.basis.basis_1d.base_1d</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">..lattice</span> <span class="k">import</span> <span class="n">lattice_basis</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_check_1d_symm</span> <span class="k">as</span> <span class="n">_check</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">_sp</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">array</span><span class="p">,</span><span class="n">cos</span><span class="p">,</span><span class="n">sin</span><span class="p">,</span><span class="n">exp</span><span class="p">,</span><span class="n">pi</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="k">import</span> <span class="n">norm</span><span class="p">,</span><span class="n">eigvalsh</span><span class="p">,</span><span class="n">svd</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="k">import</span> <span class="n">eigsh</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">ModuleType</span>

<span class="c1"># this is how we encode which fortran function to call when calculating </span>
<span class="c1"># the action of operator string</span>

<span class="n">_dtypes</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;f&quot;</span><span class="p">:</span><span class="n">_np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span><span class="s2">&quot;d&quot;</span><span class="p">:</span><span class="n">_np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span><span class="s2">&quot;F&quot;</span><span class="p">:</span><span class="n">_np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span><span class="s2">&quot;D&quot;</span><span class="p">:</span><span class="n">_np</span><span class="o">.</span><span class="n">complex128</span><span class="p">}</span>


<span class="n">_basis_op_errors</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="s2">&quot;opstr character not recognized.&quot;</span><span class="p">,</span>
				<span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="s2">&quot;attemping to use real hamiltonian with complex matrix elements.&quot;</span><span class="p">,</span>
				<span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="s2">&quot;index of operator not between 0 &lt;= index &lt;= L-1&quot;</span><span class="p">}</span>

<span class="k">class</span> <span class="nc">OpstrError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
	<span class="c1"># this class defines an exception which can be raised whenever there is some sort of error which we can</span>
	<span class="c1"># see will obviously break the code. </span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">message</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="o">=</span><span class="n">message</span>
	<span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">message</span>

<span class="k">class</span> <span class="nc">bitops</span><span class="p">:</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ops_module</span><span class="p">,</span><span class="o">**</span><span class="n">blocks</span><span class="p">):</span>
		<span class="k">def</span> <span class="nf">try_add</span><span class="p">(</span><span class="n">func_str</span><span class="p">,</span><span class="n">block</span><span class="p">):</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">func_str</span><span class="p">]</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">func_str</span><span class="p">]</span>
			<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;module </span><span class="si">{}</span><span class="s2"> missing implementation of </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span><span class="n">func</span><span class="p">))</span>

		<span class="n">try_add</span><span class="p">(</span><span class="s2">&quot;py_fliplr&quot;</span><span class="p">,</span><span class="s2">&quot;pblock&quot;</span><span class="p">)</span>
		<span class="n">try_add</span><span class="p">(</span><span class="s2">&quot;py_shift&quot;</span><span class="p">,</span><span class="s2">&quot;kblock&quot;</span><span class="p">)</span>
		<span class="n">try_add</span><span class="p">(</span><span class="s2">&quot;py_flip_all&quot;</span><span class="p">,</span><span class="s2">&quot;zblock&quot;</span><span class="p">)</span>
		<span class="n">try_add</span><span class="p">(</span><span class="s2">&quot;py_flip_sublat_A&quot;</span><span class="p">,</span><span class="s2">&quot;zAblock&quot;</span><span class="p">)</span>
		<span class="n">try_add</span><span class="p">(</span><span class="s2">&quot;py_flip_sublat_B&quot;</span><span class="p">,</span><span class="s2">&quot;zBblock&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">basis_1d</span><span class="p">(</span><span class="n">lattice_basis</span><span class="p">):</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">basis_module</span><span class="p">,</span><span class="n">ops_module</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">pars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">count_particles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="o">**</span><span class="n">blocks</span><span class="p">):</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;basis_1d&quot;</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This class is not intended&quot;</span>
							 <span class="s2">&quot; to be instantiated directly.&quot;</span><span class="p">)</span>


		<span class="c1"># getting arguments which are used in basis.</span>
		<span class="n">kblock</span><span class="o">=</span><span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kblock&quot;</span><span class="p">)</span>
		<span class="n">zblock</span><span class="o">=</span><span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zblock&quot;</span><span class="p">)</span>
		<span class="n">zAblock</span><span class="o">=</span><span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zAblock&quot;</span><span class="p">)</span>
		<span class="n">zBblock</span><span class="o">=</span><span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zBblock&quot;</span><span class="p">)</span>
		<span class="n">pblock</span><span class="o">=</span><span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pblock&quot;</span><span class="p">)</span>
		<span class="n">pzblock</span><span class="o">=</span><span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pzblock&quot;</span><span class="p">)</span>
		<span class="n">a</span><span class="o">=</span><span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span> <span class="ow">or</span> <span class="n">L</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;L must be a positive integer&#39;</span><span class="p">)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sps</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid value for sps, sps &gt;= 2.&quot;</span><span class="p">)</span>


		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;a must be integer&#39;</span><span class="p">)</span>

		<span class="c1"># checking if a is compatible with L</span>
		<span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="o">%</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;L must be interger multiple of lattice spacing a&#39;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">pblock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;pblock must be integer&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pblock must be +/- 1&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">zblock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">zblock</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;zblock/sblock must be integer&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">zblock</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;zblock/sblock must be +/- 1&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">zAblock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">zAblock</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;zAblock must be integer&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">zAblock</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;zAblock must be +/- 1&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">zBblock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">zBblock</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;zBblock must be integer&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">zBblock</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;zBblock must be +/- 1&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">pzblock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pzblock</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;pzblock/psblock must be integer&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pzblock</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pzblock/psblock must be +/- 1&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">kblock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">L</span><span class="p">):</span>
			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;kblock must be integer&#39;</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">:</span>
				<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;using momentum with L == a&quot;</span><span class="p">,</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
			<span class="n">kblock</span> <span class="o">=</span> <span class="n">kblock</span> <span class="o">%</span> <span class="p">(</span><span class="n">L</span><span class="o">//</span><span class="n">a</span><span class="p">)</span>
			<span class="n">blocks</span><span class="p">[</span><span class="s2">&quot;kblock&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kblock</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">kblock</span><span class="o">/</span><span class="n">L</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_L</span> <span class="o">=</span> <span class="n">L</span>
		<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">get_Ns</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sps</span><span class="p">,</span><span class="o">**</span><span class="n">blocks</span><span class="p">)</span> <span class="c1"># estimate how many states in H-space to preallocate memory.</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">get_basis_type</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sps</span><span class="p">,</span><span class="o">**</span><span class="n">blocks</span><span class="p">)</span> <span class="c1"># get the size of the integer representation needed for this basis (uint32,uint64,object)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_pars</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_bitops</span> <span class="o">=</span> <span class="n">bitops</span><span class="p">(</span><span class="n">basis_module</span><span class="p">,</span><span class="o">**</span><span class="n">blocks</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_check_pcon</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns_pcon</span> <span class="o">=</span> <span class="kc">None</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_get_proj_pcon</span> <span class="o">=</span> <span class="kc">False</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Np</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;basis_1d expects list for Np&quot;</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns_pcon</span> <span class="o">=</span> <span class="kc">None</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Np</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_Ns_pcon</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">get_Ns</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">sps</span><span class="p">,</span><span class="o">**</span><span class="p">{})</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_check_pcon</span> <span class="o">=</span> <span class="kc">True</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_Nps</span> <span class="o">=</span> <span class="n">Np</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">=</span> <span class="s2">&quot;N&quot;</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_make_n_basis</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_basis</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_get_proj_pcon</span> <span class="o">=</span> <span class="kc">True</span>

		<span class="c1"># shout out if pblock and zA/zB blocks defined simultaneously</span>
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">zAblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zBblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;zA and zB symmetries incompatible with parity symmetry&quot;</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span> <span class="o">=</span> <span class="n">blocks</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_unique_me</span> <span class="o">=</span> <span class="kc">True</span>

		<span class="k">if</span> <span class="n">count_particles</span><span class="p">:</span> 
			<span class="n">Np_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">Np_list</span> <span class="o">=</span> <span class="kc">None</span>

		<span class="n">N</span><span class="p">,</span><span class="n">M</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="kc">None</span>

		<span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot; &amp; T &amp; P &amp; Z&quot;</span>
			<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">=</span> <span class="s2">&quot;T &amp; P &amp; Z&quot;</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="p">[</span><span class="s2">&quot;pzblock&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pblock</span><span class="o">*</span><span class="n">zblock</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_unique_me</span> <span class="o">=</span> <span class="kc">False</span>

			<span class="n">basis</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">t_p_z_op</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span> <span class="o">==</span> <span class="n">_np</span><span class="o">.</span><span class="n">object</span><span class="p">:</span>
				<span class="c1"># if object is basis type then most likely this is for single particle stuff in which case the </span>
				<span class="c1"># normalizations need to be large ~ 1000 or more which won&#39;t fit in int8/int16.</span>
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> 
				<span class="n">M</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span> <span class="c1"># normalisation*sigma</span>
				<span class="n">M</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span> <span class="c1"># m = mp + (L+1)mz + (L+1)^2c; Anders&#39; paper</span>

			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">t_p_z_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">pblock</span><span class="p">,</span><span class="n">zblock</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c1"># arguments get overwritten by ops.-_basis </span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_t_p_z_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="n">pblock</span><span class="p">,</span><span class="n">zblock</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>

		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zAblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zBblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot; &amp; T &amp; ZA &amp; ZB&quot;</span>
			<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">=</span> <span class="s2">&quot;T &amp; ZA &amp; ZB&quot;</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="p">[</span><span class="s2">&quot;zblock&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">zAblock</span><span class="o">*</span><span class="n">zBblock</span>


			<span class="n">basis</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">t_zA_zB_op</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span> <span class="o">==</span> <span class="n">_np</span><span class="o">.</span><span class="n">object</span><span class="p">:</span>
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> 
				<span class="n">M</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
				<span class="n">M</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>

			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">t_zA_zB_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">zAblock</span><span class="p">,</span><span class="n">zBblock</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_t_zA_zB_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="n">zAblock</span><span class="p">,</span><span class="n">zBblock</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>				
				
			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>

		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pzblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot; &amp; T &amp; PZ&quot;</span>
			<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">=</span> <span class="s2">&quot;T &amp; PZ&quot;</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_unique_me</span> <span class="o">=</span> <span class="kc">False</span>

			<span class="n">basis</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">t_pz_op</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span> <span class="o">==</span> <span class="n">_np</span><span class="o">.</span><span class="n">object</span><span class="p">:</span>
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> 
				<span class="n">M</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>			
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
				<span class="n">M</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="c1">#mpz</span>

			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">t_pz_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">pzblock</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_t_pz_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="n">pzblock</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>
				
			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>

		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot; &amp; T &amp; P&quot;</span>
			<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">=</span> <span class="s2">&quot;T &amp; P&quot;</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_unique_me</span> <span class="o">=</span> <span class="kc">False</span>

			<span class="n">basis</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">t_p_op</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span> <span class="o">==</span> <span class="n">_np</span><span class="o">.</span><span class="n">object</span><span class="p">:</span>
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> 
				<span class="n">M</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>			
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
				<span class="n">M</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">t_p_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">pblock</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_t_p_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="n">pblock</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>

		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot; &amp; T &amp; Z&quot;</span>
			<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">=</span> <span class="s2">&quot;T &amp; Z&quot;</span>
			<span class="n">basis</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">t_z_op</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span> <span class="o">==</span> <span class="n">_np</span><span class="o">.</span><span class="n">object</span><span class="p">:</span>
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> 
				<span class="n">M</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
				<span class="n">M</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">t_z_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">zblock</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_t_z_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="n">zblock</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>				
				
			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>

		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zAblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot; &amp; T &amp; ZA&quot;</span>
			<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">=</span> <span class="s2">&quot;T &amp; ZA&quot;</span>
			<span class="n">basis</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">t_zA_op</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span> <span class="o">==</span> <span class="n">_np</span><span class="o">.</span><span class="n">object</span><span class="p">:</span>
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> 
				<span class="n">M</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>			
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
				<span class="n">M</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">t_zA_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">zAblock</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_t_zA_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="n">zAblock</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>				
				
			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>

		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zBblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot; &amp; T &amp; ZB&quot;</span>
			<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">=</span> <span class="s2">&quot;T &amp; ZB&quot;</span>
			<span class="n">basis</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">t_zB_op</span>

			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span> <span class="o">==</span> <span class="n">_np</span><span class="o">.</span><span class="n">object</span><span class="p">:</span>
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> 
				<span class="n">M</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>			
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
				<span class="n">M</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">t_zB_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">zBblock</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_t_zB_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="n">zBblock</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>
			
			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>

		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot; &amp; P &amp; Z&quot;</span>
			<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot;P &amp; Z&quot;</span>
			<span class="n">basis</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">p_z_op</span>
			
			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">p_z_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">pblock</span><span class="p">,</span><span class="n">zblock</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_p_z_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="n">pblock</span><span class="p">,</span><span class="n">zblock</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>

		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zAblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zBblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot; &amp; ZA &amp; ZB&quot;</span>
			<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot;ZA &amp; ZB&quot;</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">zA_zB_op</span>

			<span class="n">basis</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">zA_zB_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">zAblock</span><span class="p">,</span><span class="n">zBblock</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_zA_zB_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="n">zAblock</span><span class="p">,</span><span class="n">zBblock</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>

		<span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot; &amp; P&quot;</span>
			<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">=</span> <span class="s2">&quot;P&quot;</span>
			<span class="n">basis</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">p_op</span>

			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">p_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">pblock</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_p_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="n">pblock</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>

		<span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">zblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot; &amp; Z&quot;</span>
			<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot;Z&quot;</span>
			<span class="n">basis</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">z_op</span>

			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">z_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">zblock</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_z_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="n">zblock</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>

		<span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">zAblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot; &amp; ZA&quot;</span>
			<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot;ZA&quot;</span>
			<span class="n">basis</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">zA_op</span>

			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">zA_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">zAblock</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_zA_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="n">zAblock</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>

		<span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">zBblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot; &amp; ZB&quot;</span>
			<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot;ZB&quot;</span>
			<span class="n">basis</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">zB_op</span>

			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">zB_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">zBblock</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_zB_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="n">zBblock</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>
			
		<span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">pzblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot; &amp; PZ&quot;</span>
			<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot;PZ&quot;</span>
			<span class="n">basis</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">pz_op</span>

			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">pz_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">pzblock</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_pz_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="n">pzblock</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>
	
		<span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">+=</span> <span class="s2">&quot; &amp; T&quot;</span>
			<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span>
			<span class="n">basis</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">t_op</span>
			
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span> <span class="o">==</span> <span class="n">_np</span><span class="o">.</span><span class="n">object</span><span class="p">:</span>
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> 
			<span class="k">else</span><span class="p">:</span>			
				<span class="n">N</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">t_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">Ns</span> <span class="o">=</span> <span class="n">basis_module</span><span class="o">.</span><span class="n">n_t_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="n">kblock</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>

		<span class="k">else</span><span class="p">:</span> 
			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">op</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Ns</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">ops_module</span><span class="o">.</span><span class="n">n_op</span>
				<span class="n">basis</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ns</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
				<span class="n">basis_module</span><span class="o">.</span><span class="n">n_basis</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">Np</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">Np_list</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">=</span> <span class="n">Ns</span>

		<span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">M</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">Np</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">Ns</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">Ns</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_M</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">Ns</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[</span><span class="n">Ns</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
					<span class="k">if</span> <span class="n">Np_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Np_list</span> <span class="o">=</span> <span class="n">Np_list</span><span class="p">[</span><span class="n">Ns</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">N</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_M</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">basis</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
					<span class="k">if</span> <span class="n">Np_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Np_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">Np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_me</span><span class="p">:</span>
					<span class="n">arg</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">basis</span><span class="p">[:</span><span class="n">Ns</span><span class="p">],</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;heapsort&quot;</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">arg</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">basis</span><span class="p">[:</span><span class="n">Ns</span><span class="p">],</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

				<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_M</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_Np_list</span> <span class="o">=</span> <span class="n">Np_list</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_op_args</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">]</span>

		<span class="k">elif</span> <span class="n">N</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">Np</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">Ns</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">Ns</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[</span><span class="n">Ns</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
					<span class="k">if</span> <span class="n">Np_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Np_list</span> <span class="o">=</span> <span class="n">Np_list</span><span class="p">[</span><span class="n">Ns</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">N</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">basis</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
					<span class="k">if</span> <span class="n">Np_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Np_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">Np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">arg</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">basis</span><span class="p">[:</span><span class="n">Ns</span><span class="p">],</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;heapsort&quot;</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

				<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_Np_list</span> <span class="o">=</span> <span class="n">Np_list</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="k">if</span> <span class="n">Np_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Np_list</span> <span class="o">=</span> <span class="n">Np_list</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_op_args</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">]</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">Np</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
				<span class="k">pass</span>
			<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">Np</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[</span><span class="n">Ns</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="k">if</span> <span class="n">Np_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Np_list</span> <span class="o">=</span> <span class="n">Np_list</span><span class="p">[</span><span class="n">Ns</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">arg</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">basis</span><span class="p">[:</span><span class="n">Ns</span><span class="p">],</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;heapsort&quot;</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

				<span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="n">basis</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="k">if</span> <span class="n">Np_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Np_list</span> <span class="o">=</span> <span class="n">Np_list</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

			<span class="bp">self</span><span class="o">.</span><span class="n">_op_args</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">]</span>




	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">L</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;int: length of lattice.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_L</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">N</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;int: number of sites the basis is constructed with.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_L</span>



	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;str: information about `basis` object.&quot;&quot;&quot;</span>
		<span class="n">blocks</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
		<span class="n">lat_space</span> <span class="o">=</span> <span class="s2">&quot;lattice spacing: a = </span><span class="si">{a}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)</span>

		<span class="k">for</span> <span class="n">symm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">symm</span> <span class="o">!=</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
				<span class="n">blocks</span> <span class="o">+=</span> <span class="n">symm</span><span class="o">+</span><span class="s2">&quot; = {&quot;</span><span class="o">+</span><span class="n">symm</span><span class="o">+</span><span class="s2">&quot;}, &quot;</span>

		<span class="n">blocks</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conserved</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">symm</span> <span class="o">=</span> <span class="s2">&quot;no symmetry&quot;</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conserved</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">symm</span> <span class="o">=</span> <span class="s2">&quot;symmetry&quot;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">symm</span> <span class="o">=</span> <span class="s2">&quot;symmetries&quot;</span>

		<span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;1d basis for chain of L = </span><span class="si">{0}</span><span class="s2"> containing </span><span class="si">{5}</span><span class="s2"> states </span><span class="se">\n\t</span><span class="si">{1}</span><span class="s2">: </span><span class="si">{2}</span><span class="s2"> </span><span class="se">\n\t</span><span class="s2">quantum numbers: </span><span class="si">{4}</span><span class="s2"> </span><span class="se">\n\t</span><span class="si">{3}</span><span class="s2"> </span><span class="se">\n\n</span><span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">,</span><span class="n">symm</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_conserved</span><span class="p">,</span><span class="n">lat_space</span><span class="p">,</span><span class="n">blocks</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">)</span>
		<span class="n">string</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span>
		<span class="k">return</span> <span class="n">string</span> 

	<span class="k">def</span> <span class="nf">_Op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="p">):</span>

		<span class="n">indx</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
		
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opstr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indx</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;length of opstr does not match length of indx&#39;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;values in indx falls outside of system&#39;</span><span class="p">)</span>

		<span class="n">extra_ops</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">opstr</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allowed_ops</span>
		<span class="k">if</span> <span class="n">extra_ops</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unrecognized characters </span><span class="si">{}</span><span class="s2"> in operator string.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">extra_ops</span><span class="p">))</span>


		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">[],[],[]</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_me</span><span class="p">:</span>
			<span class="n">N_op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">N_op</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">Ns</span>

		<span class="n">col</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_op</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
		<span class="n">row</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_op</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
		<span class="n">ME</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_op</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">,</span><span class="n">ME</span><span class="p">,</span><span class="n">opstr</span><span class="p">,</span><span class="n">indx</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_op_args</span><span class="p">,</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="n">OpstrError</span><span class="p">(</span><span class="n">_basis_op_errors</span><span class="p">[</span><span class="n">error</span><span class="p">])</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ME</span><span class="p">),</span><span class="n">_np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ME</span><span class="p">)</span><span class="o">==</span><span class="mf">0.0</span><span class="p">))</span>
		<span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
		<span class="n">row</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
		<span class="n">ME</span> <span class="o">=</span> <span class="n">ME</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

		<span class="k">return</span> <span class="n">ME</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span>		

	<span class="k">def</span> <span class="nf">get_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Transforms state from symmetry-reduced basis to full (symmetry-free) basis.</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		Particularly useful when a given operation canot be carried away in the symmetry-reduced basis</span>
<span class="sd">		in a straightforward manner.</span>

<span class="sd">		Supports parallelisation to multiple states listed in the columns.</span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		v0 : numpy.ndarray</span>
<span class="sd">			Contains in its columns the states in the symmetry-reduced basis.</span>
<span class="sd">		sparse : bool, optional</span>
<span class="sd">			Whether or not the output should be in sparse format. Default is `True`.</span>
<span class="sd">		</span>
<span class="sd">		Returns</span>
<span class="sd">		--------</span>
<span class="sd">		numpy.ndarray</span>
<span class="sd">			Array containing the state `v0` in the full basis.</span>

<span class="sd">		Examples</span>
<span class="sd">		--------</span>

<span class="sd">		&gt;&gt;&gt; v_full = get_vec(v0)</span>
<span class="sd">		&gt;&gt;&gt; print(v_full.shape, v0.shape)</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span><span class="s2">&quot;shape&quot;</span><span class="p">):</span>
			<span class="n">v0</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>

		<span class="n">squeeze</span> <span class="o">=</span> <span class="kc">False</span>

		<span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sps</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">v0</span> <span class="o">=</span> <span class="n">v0</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
			<span class="n">squeeze</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="k">elif</span> <span class="n">v0</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
			<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sps</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">,</span><span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;excpecting v0 to have ndim at most 2&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(([],([],[])),</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sps</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_sps</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;v0 shape </span><span class="si">{0}</span><span class="s2"> not compatible with Ns=</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">))</span>

		<span class="k">if</span> <span class="n">_sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">v0</span><span class="p">):</span> <span class="c1"># current work around for sparse states.</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_proj</span><span class="p">(</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>

		<span class="n">norms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_norms</span><span class="p">(</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

		<span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
		<span class="n">kblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kblock&quot;</span><span class="p">)</span>
		<span class="n">pblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pblock&quot;</span><span class="p">)</span>
		<span class="n">zblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zblock&quot;</span><span class="p">)</span>
		<span class="n">zAblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zAblock&quot;</span><span class="p">)</span>
		<span class="n">zBblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zBblock&quot;</span><span class="p">)</span>
		<span class="n">pzblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pzblock&quot;</span><span class="p">)</span>


		<span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pzblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)):</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ind_neg</span><span class="p">,</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ind_pos</span><span class="p">,</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
			<span class="k">del</span> <span class="n">mask</span>
			<span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">):</span>
				<span class="n">c</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">dtype</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">r</span><span class="p">))</span>
				<span class="n">c</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">dtype</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">r</span><span class="p">))</span>
				<span class="n">_np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">ind_pos</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">count</span><span class="o">=</span><span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
			<span class="n">ind_neg</span> <span class="o">=</span> <span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
			<span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
					<span class="n">c</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1.0</span>
				<span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">pi</span><span class="p">:</span>
					<span class="n">c</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">**</span><span class="n">r</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">c</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">dtype</span><span class="p">(</span><span class="mf">1.0</span><span class="n">j</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">r</span><span class="p">))</span>
				<span class="n">_np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">_get_vec_sparse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bitops</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">,</span><span class="n">shape</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">,</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">squeeze</span><span class="p">:</span>
				<span class="k">return</span>  <span class="n">_np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">_get_vec_dense</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bitops</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">,</span><span class="n">shape</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">,</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="p">))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">_get_vec_dense</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bitops</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">,</span><span class="n">shape</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">,</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">get_proj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">pcon</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Calculates transformation/projector from symmetry-reduced basis to full (symmetry-free) basis.</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		Particularly useful when a given operation canot be carried away in the symmetry-reduced basis</span>
<span class="sd">		in a straightforward manner.</span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		dtype : &#39;type&#39;</span>
<span class="sd">			Data type (e.g. numpy.float64) to construct the projector with.</span>
<span class="sd">		sparse : bool, optional</span>
<span class="sd">			Whether or not the output should be in sparse format. Default is `True`.</span>
<span class="sd">		pcon : bool, optional</span>
<span class="sd">			Whether or not to return the projector to the particle number (magnetisation) conserving basis </span>
<span class="sd">			(useful in bosonic/single particle systems). Default is `pcon=False`.</span>
<span class="sd">		</span>
<span class="sd">		Returns</span>
<span class="sd">		--------</span>
<span class="sd">		scipy.sparse.csr_matrix</span>
<span class="sd">			Transformation/projector between the symmetry-reduced and the full basis.</span>

<span class="sd">		Examples</span>
<span class="sd">		--------</span>

<span class="sd">		&gt;&gt;&gt; P = get_proj(np.float64,pcon=False)</span>
<span class="sd">		&gt;&gt;&gt; print(P.shape)</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">norms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_norms</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

		<span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
		<span class="n">kblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kblock&quot;</span><span class="p">)</span>
		<span class="n">pblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pblock&quot;</span><span class="p">)</span>
		<span class="n">zblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zblock&quot;</span><span class="p">)</span>
		<span class="n">zAblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zAblock&quot;</span><span class="p">)</span>
		<span class="n">zBblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zBblock&quot;</span><span class="p">)</span>
		<span class="n">pzblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pzblock&quot;</span><span class="p">)</span>

		

		<span class="k">if</span> <span class="n">pcon</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_proj_pcon</span><span class="p">:</span>
			<span class="n">basis_pcon</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns_pcon</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis_type</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_make_n_basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_Nps</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="n">basis_pcon</span><span class="p">)</span>
			<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns_pcon</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">pcon</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_proj_pcon</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;pcon=True only works for basis of a single particle number sector.&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sps</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">)</span>
			<span class="n">basis_pcon</span> <span class="o">=</span> <span class="kc">None</span>

		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(([],([],[])),</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>


		<span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pzblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)):</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ind_neg</span><span class="p">,</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ind_pos</span><span class="p">,</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
			<span class="k">del</span> <span class="n">mask</span>
			<span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">):</span>
				<span class="n">c</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">dtype</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">r</span><span class="p">))</span>
				<span class="n">c</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">dtype</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">r</span><span class="p">))</span>
				<span class="n">_np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
				<span class="k">if</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">kblock</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_L</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">dtype</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)):</span>
					<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;symmetries give complex vector, requested dtype is not complex&quot;</span><span class="p">)</span>

			<span class="n">ind_pos</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_Ns</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">ind_neg</span> <span class="o">=</span> <span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
			<span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
					<span class="n">c</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1.0</span>
				<span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">pi</span><span class="p">:</span>
					<span class="n">c</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">**</span><span class="n">r</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">c</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">dtype</span><span class="p">(</span><span class="mf">1.0</span><span class="n">j</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">r</span><span class="p">))</span>
				<span class="n">_np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>





		<span class="k">return</span> <span class="n">_get_proj_sparse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bitops</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_pars</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="p">,</span><span class="n">basis_pcon</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">shape</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">,</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_get_norms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dtype</span><span class="p">):</span>
		<span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
		<span class="n">kblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kblock&quot;</span><span class="p">)</span>
		<span class="n">pblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pblock&quot;</span><span class="p">)</span>
		<span class="n">zblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zblock&quot;</span><span class="p">)</span>
		<span class="n">zAblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zAblock&quot;</span><span class="p">)</span>
		<span class="n">zBblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zBblock&quot;</span><span class="p">)</span>
		<span class="n">pzblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pzblock&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="n">nn</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
			<span class="n">mm</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
			<span class="n">sign</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

			<span class="n">_np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">sign</span><span class="p">)</span>			
			
			<span class="n">_np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">nn</span><span class="p">)</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">nn</span><span class="p">)</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">mm</span><span class="p">)</span>
			
			<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">:</span>
				<span class="n">norm</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">norm</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

				
			<span class="n">norm</span> <span class="o">*=</span> <span class="n">sign</span>
			<span class="n">norm</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>

			<span class="n">mask</span> <span class="o">=</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">1</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">sign</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="n">pblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">mm</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">sign</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="n">pblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">mm</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">zblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">nn</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>	
			<span class="n">_np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">zblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">nn</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>	
			<span class="n">_np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">sign</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="n">pzblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">mm</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>	
			<span class="n">_np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">sign</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="n">pzblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">mm</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>	
			<span class="n">_np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">sign</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="n">pblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">mm</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">zblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">nn</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>	
			<span class="n">_np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">sign</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="n">pblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">mm</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">zblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">nn</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>	
			<span class="n">_np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">sign</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="n">pblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">mm</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">zblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">nn</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>	
			<span class="n">_np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">sign</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="n">pblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">mm</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">zblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">nn</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>	
			<span class="k">del</span> <span class="n">mask</span>
		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zAblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zBblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="n">mm</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">c</span><span class="p">)</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">mm</span><span class="p">)</span>
			<span class="n">norm</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">norm</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">zAblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">mm</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">zBblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">mm</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>	
			<span class="n">_np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">zblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">mm</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>	
			<span class="k">del</span> <span class="n">mask</span>
		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">:</span>
				<span class="n">norm</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">norm</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">norm</span> <span class="o">*=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">)</span>
			<span class="n">norm</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">min_scalar_type</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
			<span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
				<span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
			<span class="n">m</span> <span class="o">-=</span> <span class="mi">1</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">sign</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="p">[</span><span class="n">mask</span><span class="p">],(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">out</span><span class="o">=</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">sign</span> <span class="o">*=</span> <span class="mi">2</span>
			<span class="n">sign</span> <span class="o">-=</span> <span class="mi">1</span>
			<span class="n">sign</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">sign</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">sign</span><span class="o">*</span><span class="n">pblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
			<span class="k">del</span> <span class="n">mask</span>
		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pzblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="p">:</span>
				<span class="n">norm</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">norm</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">norm</span> <span class="o">*=</span> <span class="n">_np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">)</span>
			<span class="n">norm</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>
			<span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
			<span class="n">m</span> <span class="o">-=</span> <span class="mi">1</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

			<span class="n">sign</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="p">[</span><span class="n">mask</span><span class="p">],(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">out</span><span class="o">=</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">sign</span> <span class="o">*=</span> <span class="mi">2</span>
			<span class="n">sign</span> <span class="o">-=</span> <span class="mi">1</span>
			<span class="n">sign</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">sign</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">sign</span><span class="p">)</span>

			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">sign</span><span class="o">*</span><span class="n">pzblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
			<span class="k">del</span> <span class="n">mask</span>
		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="n">norm</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">norm</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>
			
			<span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
			<span class="n">m</span> <span class="o">-=</span> <span class="mi">1</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

			<span class="n">sign</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="p">[</span><span class="n">mask</span><span class="p">],(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">out</span><span class="o">=</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">sign</span> <span class="o">*=</span> <span class="mi">2</span>
			<span class="n">sign</span> <span class="o">-=</span> <span class="mi">1</span>

			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">sign</span><span class="o">*</span><span class="n">zblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
			<span class="k">del</span> <span class="n">mask</span>
		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zAblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="n">norm</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">norm</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">zAblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
			<span class="k">del</span> <span class="n">mask</span>
		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zBblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="n">norm</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">norm</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
			<span class="n">_np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_M</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
			<span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">zBblock</span><span class="o">*</span><span class="n">_np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
			<span class="k">del</span> <span class="n">mask</span>
		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="n">norm</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zAblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zBblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="n">norm</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="n">norm</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pzblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="n">norm</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="n">norm</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zAblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="n">norm</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">zBblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="n">norm</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
		<span class="k">elif</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
			<span class="n">norm</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">_L</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">norm</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">norm</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

		<span class="n">_np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span><span class="n">norm</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">norm</span>

	<span class="c1">##### provate methods</span>

	<span class="k">def</span> <span class="nf">_check_symm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">static</span><span class="p">,</span><span class="n">dynamic</span><span class="p">,</span><span class="n">photon_basis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="n">kblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kblock&quot;</span><span class="p">)</span>
		<span class="n">pblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pblock&quot;</span><span class="p">)</span>
		<span class="n">zblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zblock&quot;</span><span class="p">)</span>
		<span class="n">pzblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pzblock&quot;</span><span class="p">)</span>
		<span class="n">zAblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zAblock&quot;</span><span class="p">)</span>
		<span class="n">zBblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zBblock&quot;</span><span class="p">)</span>
		<span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_1d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
		<span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>

		<span class="k">if</span> <span class="n">photon_basis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">basis_sort_opstr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_opstr</span>
			<span class="n">static_list</span><span class="p">,</span><span class="n">dynamic_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_local_lists</span><span class="p">(</span><span class="n">static</span><span class="p">,</span><span class="n">dynamic</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">basis_sort_opstr</span> <span class="o">=</span> <span class="n">photon_basis</span><span class="o">.</span><span class="n">_sort_opstr</span>
			<span class="n">static_list</span><span class="p">,</span><span class="n">dynamic_list</span> <span class="o">=</span> <span class="n">photon_basis</span><span class="o">.</span><span class="n">_get_local_lists</span><span class="p">(</span><span class="n">static</span><span class="p">,</span><span class="n">dynamic</span><span class="p">)</span>


		<span class="n">static_blocks</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="n">dynamic_blocks</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="k">if</span> <span class="n">kblock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">missingops</span> <span class="o">=</span> <span class="n">_check</span><span class="o">.</span><span class="n">check_T</span><span class="p">(</span><span class="n">basis_sort_opstr</span><span class="p">,</span><span class="n">static_list</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">missingops</span><span class="p">:</span>	<span class="n">static_blocks</span><span class="p">[</span><span class="s2">&quot;T symm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missingops</span><span class="p">),)</span>

			<span class="n">missingops</span> <span class="o">=</span> <span class="n">_check</span><span class="o">.</span><span class="n">check_T</span><span class="p">(</span><span class="n">basis_sort_opstr</span><span class="p">,</span><span class="n">dynamic_list</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">missingops</span><span class="p">:</span>	<span class="n">dynamic_blocks</span><span class="p">[</span><span class="s2">&quot;T symm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missingops</span><span class="p">),)</span>

		<span class="k">if</span> <span class="n">pblock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">missingops</span> <span class="o">=</span> <span class="n">_check</span><span class="o">.</span><span class="n">check_P</span><span class="p">(</span><span class="n">basis_sort_opstr</span><span class="p">,</span><span class="n">static_list</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">missingops</span><span class="p">:</span>	<span class="n">static_blocks</span><span class="p">[</span><span class="s2">&quot;P symm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missingops</span><span class="p">),)</span>

			<span class="n">missingops</span> <span class="o">=</span> <span class="n">_check</span><span class="o">.</span><span class="n">check_P</span><span class="p">(</span><span class="n">basis_sort_opstr</span><span class="p">,</span><span class="n">dynamic_list</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">missingops</span><span class="p">:</span>	<span class="n">dynamic_blocks</span><span class="p">[</span><span class="s2">&quot;P symm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missingops</span><span class="p">),)</span>

		<span class="k">if</span> <span class="n">zblock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">oddops</span><span class="p">,</span><span class="n">missingops</span> <span class="o">=</span> <span class="n">_check</span><span class="o">.</span><span class="n">check_Z</span><span class="p">(</span><span class="n">basis_sort_opstr</span><span class="p">,</span><span class="n">static_list</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">missingops</span> <span class="ow">or</span> <span class="n">oddops</span><span class="p">:</span>
				<span class="n">static_blocks</span><span class="p">[</span><span class="s2">&quot;Z/C symm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">oddops</span><span class="p">),</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missingops</span><span class="p">))</span>

			<span class="n">oddops</span><span class="p">,</span><span class="n">missingops</span> <span class="o">=</span> <span class="n">_check</span><span class="o">.</span><span class="n">check_Z</span><span class="p">(</span><span class="n">basis_sort_opstr</span><span class="p">,</span><span class="n">dynamic_list</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">missingops</span> <span class="ow">or</span> <span class="n">oddops</span><span class="p">:</span>
				<span class="n">dynamic_blocks</span><span class="p">[</span><span class="s2">&quot;Z/C symm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">oddops</span><span class="p">),</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missingops</span><span class="p">))</span>

		<span class="k">if</span> <span class="n">zAblock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">oddops</span><span class="p">,</span><span class="n">missingops</span> <span class="o">=</span> <span class="n">_check</span><span class="o">.</span><span class="n">check_ZA</span><span class="p">(</span><span class="n">basis_sort_opstr</span><span class="p">,</span><span class="n">static_list</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">missingops</span> <span class="ow">or</span> <span class="n">oddops</span><span class="p">:</span>
				<span class="n">static_blocks</span><span class="p">[</span><span class="s2">&quot;ZA/CA symm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">oddops</span><span class="p">),</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missingops</span><span class="p">))</span>

			<span class="n">oddops</span><span class="p">,</span><span class="n">missingops</span> <span class="o">=</span> <span class="n">_check</span><span class="o">.</span><span class="n">check_ZA</span><span class="p">(</span><span class="n">basis_sort_opstr</span><span class="p">,</span><span class="n">dynamic_list</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">missingops</span> <span class="ow">or</span> <span class="n">oddops</span><span class="p">:</span>
				<span class="n">dynamic_blocks</span><span class="p">[</span><span class="s2">&quot;ZA/CA symm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">oddops</span><span class="p">),</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missingops</span><span class="p">))</span>

		<span class="k">if</span> <span class="n">zBblock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">oddops</span><span class="p">,</span><span class="n">missingops</span> <span class="o">=</span> <span class="n">_check</span><span class="o">.</span><span class="n">check_ZB</span><span class="p">(</span><span class="n">basis_sort_opstr</span><span class="p">,</span><span class="n">static_list</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">missingops</span> <span class="ow">or</span> <span class="n">oddops</span><span class="p">:</span>
				<span class="n">static_blocks</span><span class="p">[</span><span class="s2">&quot;ZB/CB symm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">oddops</span><span class="p">),</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missingops</span><span class="p">))</span>

			<span class="n">oddops</span><span class="p">,</span><span class="n">missingops</span> <span class="o">=</span> <span class="n">_check</span><span class="o">.</span><span class="n">check_ZB</span><span class="p">(</span><span class="n">basis_sort_opstr</span><span class="p">,</span><span class="n">dynamic_list</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">missingops</span> <span class="ow">or</span> <span class="n">oddops</span><span class="p">:</span>
				<span class="n">dynamic_blocks</span><span class="p">[</span><span class="s2">&quot;ZB/CB symm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">oddops</span><span class="p">),</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missingops</span><span class="p">))</span>

		<span class="k">if</span> <span class="n">pzblock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">missingops</span> <span class="o">=</span> <span class="n">_check</span><span class="o">.</span><span class="n">check_PZ</span><span class="p">(</span><span class="n">basis_sort_opstr</span><span class="p">,</span><span class="n">static_list</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">missingops</span><span class="p">:</span>	<span class="n">static_blocks</span><span class="p">[</span><span class="s2">&quot;PZ/PC symm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missingops</span><span class="p">),)</span>

			<span class="n">missingops</span> <span class="o">=</span> <span class="n">_check</span><span class="o">.</span><span class="n">check_PZ</span><span class="p">(</span><span class="n">basis_sort_opstr</span><span class="p">,</span><span class="n">dynamic_list</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">missingops</span><span class="p">:</span>	<span class="n">dynamic_blocks</span><span class="p">[</span><span class="s2">&quot;PZ/PC symm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">missingops</span><span class="p">),)</span>

		<span class="k">return</span> <span class="n">static_blocks</span><span class="p">,</span><span class="n">dynamic_blocks</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">class basis_1d(lattice_basis):</span>
<span class="sd">	def __init__(self,basis_module,ops_module,L,Np=None,_Np=None,pars=None,**blocks):</span>

<span class="sd">		if self.__class__.__name__ == &quot;basis_1d&quot;:</span>
<span class="sd">			raise ValueError(&quot;This class is not intended&quot;</span>
<span class="sd">							 &quot; to be instantiated directly.&quot;)</span>

<span class="sd">		if type(Np) is int:</span>
<span class="sd">			self._check_pcon=True</span>
<span class="sd">			self._get_proj_pcon = True</span>
<span class="sd">			self._make_Np_block(basis_module,ops_module,L,Np=Np,pars=pars,**blocks)</span>
<span class="sd">	</span>
<span class="sd">		elif Np is None: # User hasn&#39;t specified Np,</span>
<span class="sd">			if _Np is not None: # check to see if photon_basis can create the particle sectors.</span>

<span class="sd">				if type(_Np) is not int:</span>
<span class="sd">					raise ValueError(&quot;_Np must be integer&quot;)</span>

<span class="sd">				if _Np == -1: </span>
<span class="sd">					self._make_Np_block(basis_module,ops_module,L,pars=pars,**blocks)</span>
<span class="sd">				elif _Np &gt;= 0:</span>
<span class="sd">					if _Np+1 &gt; L: _Np = L</span>
<span class="sd">					blocks[&quot;count_particles&quot;] = True</span>

<span class="sd">					zblock = blocks.get(&quot;zblock&quot;)</span>
<span class="sd">					zAblock = blocks.get(&quot;zAblock&quot;)</span>
<span class="sd">					zBblock = blocks.get(&quot;zAblock&quot;)</span>
<span class="sd">				</span>
<span class="sd">					if (type(zblock) is int) or (type(zAblock) is int) or (type(zBblock) is int):</span>
<span class="sd">						raise ValueError(&quot;spin inversion symmetry not compatible with particle conserving photon_basis.&quot;)</span>
<span class="sd">					</span>
<span class="sd">					# loop over the first Np particle sectors (use the iterator initialization).</span>
<span class="sd">					Np = list(range(_Np+1))</span>
<span class="sd">					self.__init__(L,Np,**blocks)</span>
<span class="sd">				else:</span>
<span class="sd">					raise ValueError(&quot;_Np == -1 for no particle conservation, _Np &gt;= 0 for particle conservation&quot;)</span>

<span class="sd">			else: # if _Np is None then assume user wants to not specify Magnetization sector</span>
<span class="sd">				self._check_pcon = False</span>
<span class="sd">				self._get_proj_pcon = False</span>
<span class="sd">				self._make_Np_block(basis_module,ops_module,L,pars=pars,**blocks)</span>


<span class="sd">		else: # try to interate over Np </span>
<span class="sd">			try:</span>
<span class="sd">				Nup_iter = iter(Np)</span>
<span class="sd">			except TypeError:</span>
<span class="sd">				raise TypeError(&quot;Np must be integer or iteratable object.&quot;)</span>


<span class="sd">			warnings.warn(&quot;Test for particle conservation not implemented for particle conserving lists&quot;,UserWarning,stacklevel=3)</span>

<span class="sd">			blocks[&quot;check_z_symm&quot;] = False</span>
<span class="sd">			Np = next(Nup_iter)</span>
<span class="sd">			self._check_pcon = False</span>
<span class="sd">			self._get_proj_pcon = False</span>
<span class="sd">			self._make_Np_block(basis_module,ops_module,L,Np=Np,pars=pars,**blocks)</span>
<span class="sd">			for Np in Nup_iter:</span>
<span class="sd">				temp_basis =self.__class__(L,Np,**blocks)</span>
<span class="sd">				self._append(temp_basis)	</span>

<span class="sd">	def _make_Np_block(self,basis_module,ops_module,L,Np=None,pars=None,**blocks):</span>
<span class="sd">		# getting arguments which are used in basis.</span>
<span class="sd">		kblock=blocks.get(&quot;kblock&quot;)</span>
<span class="sd">		zblock=blocks.get(&quot;zblock&quot;)</span>
<span class="sd">		zAblock=blocks.get(&quot;zAblock&quot;)</span>
<span class="sd">		zBblock=blocks.get(&quot;zBblock&quot;)</span>
<span class="sd">		pblock=blocks.get(&quot;pblock&quot;)</span>
<span class="sd">		pzblock=blocks.get(&quot;pzblock&quot;)</span>
<span class="sd">		a=blocks.get(&quot;a&quot;)</span>

<span class="sd">		count_particles = blocks.get(&quot;count_particles&quot;)</span>
<span class="sd">		if count_particles is None:</span>
<span class="sd">			count_particles=False</span>

<span class="sd">		check_z_symm = blocks.get(&quot;check_z_symm&quot;)</span>
<span class="sd">		if check_z_symm is None:</span>
<span class="sd">			check_z_symm=True</span>


<span class="sd">		if type(L) is not int:</span>
<span class="sd">			raise TypeError(&#39;L must be integer&#39;)</span>

<span class="sd">		if self.sps &lt; 2:</span>
<span class="sd">			raise ValueError(&quot;invalid value for sps, sps &gt;= 2.&quot;)</span>


<span class="sd">		if type(a) is not int:</span>
<span class="sd">			raise TypeError(&#39;a must be integer&#39;)</span>

<span class="sd">		# checking if a is compatible with L</span>
<span class="sd">		if(L%a != 0):</span>
<span class="sd">			raise ValueError(&#39;L must be interger multiple of lattice spacing a&#39;)</span>

<span class="sd">		# checking type, and value of blocks</span>
<span class="sd">		if Np is not None:</span>
<span class="sd">			if type(Np) is not int: raise TypeError(&#39;Nup/Nb/Nf must be integer&#39;)</span>
<span class="sd">			if Np &lt; 0 or Np &gt; L*(self.sps-1): raise ValueError(&quot;0 &lt;= Number of particles &lt;= %d&quot; % (L*(self.sps-1)))</span>

<span class="sd">		if pblock is not None:</span>
<span class="sd">			if type(pblock) is not int: raise TypeError(&#39;pblock must be integer&#39;)</span>
<span class="sd">			if abs(pblock) != 1: raise ValueError(&quot;pblock must be +/- 1&quot;)</span>

<span class="sd">		if zblock is not None:</span>
<span class="sd">			if type(zblock) is not int: raise TypeError(&#39;zblock/sblock must be integer&#39;)</span>
<span class="sd">			if abs(zblock) != 1: raise ValueError(&quot;zblock/sblock must be +/- 1&quot;)</span>

<span class="sd">		if zAblock is not None:</span>
<span class="sd">			if type(zAblock) is not int: raise TypeError(&#39;zAblock must be integer&#39;)</span>
<span class="sd">			if abs(zAblock) != 1: raise ValueError(&quot;zAblock must be +/- 1&quot;)</span>

<span class="sd">		if zBblock is not None:</span>
<span class="sd">			if type(zBblock) is not int: raise TypeError(&#39;zBblock must be integer&#39;)</span>
<span class="sd">			if abs(zBblock) != 1: raise ValueError(&quot;zBblock must be +/- 1&quot;)</span>

<span class="sd">		if pzblock is not None:</span>
<span class="sd">			if type(pzblock) is not int: raise TypeError(&#39;pzblock/psblock must be integer&#39;)</span>
<span class="sd">			if abs(pzblock) != 1: raise ValueError(&quot;pzblock/psblock must be +/- 1&quot;)</span>

<span class="sd">		if kblock is not None and (a &lt;= L):</span>
<span class="sd">			if type(kblock) is not int: raise TypeError(&#39;kblock must be integer&#39;)</span>
<span class="sd">			if a == L:</span>
<span class="sd">				warnings.warn(&quot;using momentum with L == a&quot;,stacklevel=5)</span>
<span class="sd">			kblock = kblock % (L//a)</span>
<span class="sd">			blocks[&quot;kblock&quot;] = kblock</span>
<span class="sd">			self._k = 2*pi*a*kblock/L</span>

<span class="sd">		self._L = L</span>
<span class="sd">		Ns = basis_module.get_Ns(L,Np,self.sps,**blocks) # estimate how many states in H-space to preallocate memory.</span>
<span class="sd">		self._basis_type = basis_module.get_basis_type(L,Np,self.sps,**blocks) # get the size of the integer representation needed for this basis (uint32,uint64,object)</span>
<span class="sd">		self._pars = _np.asarray(pars,dtype=self._basis_type)</span>
<span class="sd">		self._bitops = bitops(basis_module,**blocks)</span>

<span class="sd">		if type(Np) is int:</span>
<span class="sd">			self._conserved = &quot;N&quot;</span>
<span class="sd">			self._Ns_pcon = basis_module.get_Ns(L,Np,self.sps,**{})</span>
<span class="sd">			self._Np = Np</span>
<span class="sd">			self._make_n_basis = basis_module.n_basis</span>
<span class="sd">		else:</span>
<span class="sd">			self._conserved = &quot;&quot;</span>
<span class="sd">			self._Ns_pcon = None</span>


<span class="sd">		# shout out if pblock and zA/zB blocks defined simultaneously</span>
<span class="sd">		if type(pblock) is int and ((type(zAblock) is int) or (type(zBblock) is int)):</span>
<span class="sd">			raise ValueError(&quot;zA and zB symmetries incompatible with parity symmetry&quot;)</span>

<span class="sd">		if check_z_symm:</span>
<span class="sd">			blocks[&quot;Np&quot;] = Np</span>
<span class="sd">			# checking if spin inversion is compatible with Np and L</span>
<span class="sd">			if (type(Np) is int) and ((type(zblock) is int) or (type(pzblock) is int)):</span>
<span class="sd">				if (L*(self.sps-1) % 2) != 0:</span>
<span class="sd">					raise ValueError(&quot;spin inversion/particle-hole symmetry with particle/magnetization conservation must be used with chains with 0 magnetization sector or at half filling&quot;)</span>
<span class="sd">				if Np != L*(self.sps-1)//2:</span>
<span class="sd">					raise ValueError(&quot;spin inversion/particle-hole symmetry only reduces the 0 magnetization or half filled particle sector&quot;)</span>

<span class="sd">			if (type(Np) is int) and ((type(zAblock) is int) or (type(zBblock) is int)):</span>
<span class="sd">				raise ValueError(&quot;zA/cA and zB/cB symmetries incompatible with magnetisation/particle symmetry&quot;)</span>

<span class="sd">			# checking if ZA/ZB spin inversion is compatible with unit cell of translation symemtry</span>
<span class="sd">			if (type(kblock) is int) and ((type(zAblock) is int) or (type(zBblock) is int)):</span>
<span class="sd">				if a%2 != 0: # T and ZA (ZB) symemtries do NOT commute</span>
<span class="sd">					raise ValueError(&quot;unit cell size &#39;a&#39; must be even&quot;)</span>




<span class="sd">		self._blocks_1d = blocks</span>
<span class="sd">		self._unique_me = True	</span>
<span class="sd">		</span>
<span class="sd">		if (type(kblock) is int) and (type(pblock) is int) and (type(zblock) is int):</span>
<span class="sd">			if self._conserved: self._conserved += &quot; &amp; T &amp; P &amp; Z&quot;</span>
<span class="sd">			else: self._conserved = &quot;T &amp; P &amp; Z&quot;</span>

<span class="sd">			self._blocks_1d[&quot;pzblock&quot;] = pblock*zblock</span>
<span class="sd">			self._unique_me = False</span>

<span class="sd">			basis=_np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">			self._op = ops_module.t_p_z_op</span>

<span class="sd">			if self._basis_type == _np.object:</span>
<span class="sd">				# if object is basis type then most likely this is for single particle stuff in which case the </span>
<span class="sd">				# normalizations need to be large ~ 1000 or more which won&#39;t fit in int8/int16.</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int32) </span>
<span class="sd">				M=_np.empty(basis.shape,dtype=_np.uint32)</span>
<span class="sd">			else:</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int8) # normalisation*sigma</span>
<span class="sd">				M=_np.empty(basis.shape,dtype=_np.uint16) # m = mp + (L+1)mz + (L+1)^2c; Anders&#39; paper</span>

<span class="sd">			if (type(Np) is int):</span>
<span class="sd">				# arguments get overwritten by ops.-_basis </span>
<span class="sd">				Ns = basis_module.n_t_p_z_basis(L,Np,pblock,zblock,kblock,a,self._pars,N,M,basis)</span>
<span class="sd">			else:</span>
<span class="sd">				Ns = basis_module.t_p_z_basis(L,pblock,zblock,kblock,a,self._pars,N,M,basis)</span>

<span class="sd">			# cut off extra memory for overestimated state number and reverse order</span>
<span class="sd">			if Ns &gt; 0:</span>
<span class="sd">				self._N = N[Ns-1::-1].copy()</span>
<span class="sd">				self._M = M[Ns-1::-1].copy()</span>
<span class="sd">				self._basis = basis[Ns-1::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._N = _np.array([],dtype=N.dtype)</span>
<span class="sd">				self._M = _np.array([],dtype=M.dtype)</span>
<span class="sd">				self._basis = _np.array([],dtype=basis.dtype)</span>
<span class="sd">				</span>
<span class="sd">			self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._N,self._M,self._basis,self._L,self._pars]</span>

<span class="sd">		elif (type(kblock) is int) and (type(zAblock) is int) and (type(zBblock) is int):</span>
<span class="sd">			if self._conserved: self._conserved += &quot; &amp; T &amp; ZA &amp; ZB&quot;</span>
<span class="sd">			else: self._conserved = &quot;T &amp; ZA &amp; ZB&quot;</span>
<span class="sd">			self._blocks_1d[&quot;zblock&quot;] = zAblock*zBblock</span>


<span class="sd">			basis=_np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">			self._op = ops_module.t_zA_zB_op</span>

<span class="sd">			if self._basis_type == _np.object:</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int32) </span>
<span class="sd">				M=_np.empty(basis.shape,dtype=_np.uint32)</span>
<span class="sd">			else:</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int8)</span>
<span class="sd">				M=_np.empty(basis.shape,dtype=_np.uint16)</span>

<span class="sd">			if (type(Np) is int):</span>
<span class="sd">				Ns = basis_module.n_t_zA_zB_basis(L,Np,zAblock,zBblock,kblock,a,self._pars,N,M,basis)</span>
<span class="sd">			else:</span>
<span class="sd">				Ns = basis_module.t_zA_zB_basis(L,zAblock,zBblock,kblock,a,self._pars,N,M,basis)</span>

<span class="sd">			if Ns &gt; 0:</span>
<span class="sd">				self._N = N[Ns-1::-1].copy()</span>
<span class="sd">				self._M = M[Ns-1::-1].copy()</span>
<span class="sd">				self._basis = basis[Ns-1::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._N = _np.array([],dtype=N.dtype)</span>
<span class="sd">				self._M = _np.array([],dtype=M.dtype)</span>
<span class="sd">				self._basis = _np.array([],dtype=basis.dtype)</span>
<span class="sd">				</span>
<span class="sd">			self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._N,self._M,self._basis,self._L,self._pars]</span>

<span class="sd">		elif (type(kblock) is int) and (type(pzblock) is int):</span>
<span class="sd">			if self._conserved: self._conserved += &quot; &amp; T &amp; PZ&quot;</span>
<span class="sd">			else: self._conserved = &quot;T &amp; PZ&quot;</span>
<span class="sd">			self._unique_me = False</span>

<span class="sd">			basis=_np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">			self._op = ops_module.t_pz_op</span>

<span class="sd">			if self._basis_type == _np.object:</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int32) </span>
<span class="sd">				M=_np.empty(basis.shape,dtype=_np.uint32)</span>
<span class="sd">			else:			</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int8)</span>
<span class="sd">				M=_np.empty(basis.shape,dtype=_np.uint8) #mpz</span>

<span class="sd">			if (type(Np) is int):</span>
<span class="sd">				Ns = basis_module.n_t_pz_basis(L,Np,pzblock,kblock,a,self._pars,N,M,basis)</span>
<span class="sd">			else:</span>
<span class="sd">				Ns = basis_module.t_pz_basis(L,pzblock,kblock,a,self._pars,N,M,basis)</span>

<span class="sd">			if Ns &gt; 0:</span>
<span class="sd">				self._N = N[Ns-1::-1].copy()</span>
<span class="sd">				self._M = M[Ns-1::-1].copy()</span>
<span class="sd">				self._basis = basis[Ns-1::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._N = _np.array([],dtype=N.dtype)</span>
<span class="sd">				self._M = _np.array([],dtype=M.dtype)</span>
<span class="sd">				self._basis = _np.array([],dtype=basis.dtype)</span>
<span class="sd">				</span>
<span class="sd">			self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._N,self._M,self._basis,self._L,self._pars]</span>

<span class="sd">		elif (type(kblock) is int) and (type(pblock) is int):</span>
<span class="sd">			if self._conserved: self._conserved += &quot; &amp; T &amp; P&quot;</span>
<span class="sd">			else: self._conserved = &quot;T &amp; P&quot;</span>
<span class="sd">			self._unique_me = False</span>

<span class="sd">			basis=_np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">			self._op = ops_module.t_p_op</span>

<span class="sd">			if self._basis_type == _np.object:</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int32) </span>
<span class="sd">				M=_np.empty(basis.shape,dtype=_np.uint32)</span>
<span class="sd">			else:			</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int8)</span>
<span class="sd">				M=_np.empty(basis.shape,dtype=_np.uint8)</span>

<span class="sd">			if (type(Np) is int):</span>
<span class="sd">				Ns = basis_module.n_t_p_basis(L,Np,pblock,kblock,a,self._pars,N,M,basis)</span>
<span class="sd">			else:</span>
<span class="sd">				Ns = basis_module.t_p_basis(L,pblock,kblock,a,self._pars,N,M,basis)</span>

<span class="sd">			if Ns &gt; 0:</span>
<span class="sd">				self._N = N[Ns-1::-1].copy()</span>
<span class="sd">				self._M = M[Ns-1::-1].copy()</span>
<span class="sd">				self._basis = basis[Ns-1::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._N = _np.array([],dtype=N.dtype)</span>
<span class="sd">				self._M = _np.array([],dtype=M.dtype)</span>
<span class="sd">				self._basis = _np.array([],dtype=basis.dtype)</span>
<span class="sd">			self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._N,self._M,self._basis,self._L,self._pars]</span>

<span class="sd">		elif (type(kblock) is int) and (type(zblock) is int):</span>
<span class="sd">			if self._conserved: self._conserved += &quot; &amp; T &amp; Z&quot;</span>
<span class="sd">			else: self._conserved = &quot;T &amp; Z&quot;</span>
<span class="sd">			basis=_np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">			self._op = ops_module.t_z_op</span>

<span class="sd">			if self._basis_type == _np.object:</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int32) </span>
<span class="sd">				M=_np.empty(basis.shape,dtype=_np.uint32)</span>
<span class="sd">			else:</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int8)</span>
<span class="sd">				M=_np.empty(basis.shape,dtype=_np.uint8)</span>

<span class="sd">			if (type(Np) is int):</span>
<span class="sd">				Ns = basis_module.n_t_z_basis(L,Np,zblock,kblock,a,self._pars,N,M,basis)</span>
<span class="sd">			else:</span>
<span class="sd">				Ns = basis_module.t_z_basis(L,zblock,kblock,a,self._pars,N,M,basis)</span>

<span class="sd">			if Ns &gt; 0:</span>
<span class="sd">				self._N = N[Ns-1::-1].copy()</span>
<span class="sd">				self._M = M[Ns-1::-1].copy()</span>
<span class="sd">				self._basis = basis[Ns-1::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._N = _np.array([],dtype=N.dtype)</span>
<span class="sd">				self._M = _np.array([],dtype=M.dtype)</span>
<span class="sd">				self._basis = _np.array([],dtype=basis.dtype)</span>
<span class="sd">				</span>
<span class="sd">			self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._N,self._M,self._basis,self._L,self._pars]</span>


<span class="sd">		elif (type(kblock) is int) and (type(zAblock) is int):</span>
<span class="sd">			if self._conserved: self._conserved += &quot; &amp; T &amp; ZA&quot;</span>
<span class="sd">			else: self._conserved = &quot;T &amp; ZA&quot;</span>
<span class="sd">			basis=_np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">			self._op = ops_module.t_zA_op</span>

<span class="sd">			if self._basis_type == _np.object:</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int32) </span>
<span class="sd">				M=_np.empty(basis.shape,dtype=_np.uint32)</span>
<span class="sd">			else:			</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int8)</span>
<span class="sd">				M=_np.empty(basis.shape,dtype=_np.uint8)</span>

<span class="sd">			if (type(Np) is int):</span>
<span class="sd">				Ns = basis_module.n_t_zA_basis(L,Np,zAblock,kblock,a,self._pars,N,M,basis)</span>
<span class="sd">			else:</span>
<span class="sd">				Ns = basis_module.t_zA_basis(L,zAblock,kblock,a,self._pars,N,M,basis)</span>

<span class="sd">			if Ns &gt; 0:</span>
<span class="sd">				self._N = N[Ns-1::-1].copy()</span>
<span class="sd">				self._M = M[Ns-1::-1].copy()</span>
<span class="sd">				self._basis = basis[Ns-1::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._N = _np.array([],dtype=N.dtype)</span>
<span class="sd">				self._M = _np.array([],dtype=M.dtype)</span>
<span class="sd">				self._basis = _np.array([],dtype=basis.dtype)</span>
<span class="sd">				</span>
<span class="sd">			self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._N,self._M,self._basis,self._L,self._pars]</span>

<span class="sd">		elif (type(kblock) is int) and (type(zBblock) is int):</span>
<span class="sd">			if self._conserved: self._conserved += &quot; &amp; T &amp; ZB&quot;</span>
<span class="sd">			else: self._conserved = &quot;T &amp; ZB&quot;</span>
<span class="sd">			basis=_np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">			self._op = ops_module.t_zB_op</span>

<span class="sd">			if self._basis_type == _np.object:</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int32) </span>
<span class="sd">				M=_np.empty(basis.shape,dtype=_np.uint32)</span>
<span class="sd">			else:			</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int8)</span>
<span class="sd">				M=_np.empty(basis.shape,dtype=_np.uint8)</span>

<span class="sd">			if (type(Np) is int):</span>
<span class="sd">				Ns = basis_module.n_t_zB_basis(L,Np,zBblock,kblock,a,self._pars,N,M,basis)</span>
<span class="sd">			else:</span>
<span class="sd">				Ns = basis_module.t_zB_basis(L,zBblock,kblock,a,self._pars,N,M,basis)</span>

<span class="sd">			if Ns &gt; 0:</span>
<span class="sd">				self._N = N[Ns-1::-1].copy()</span>
<span class="sd">				self._M = M[Ns-1::-1].copy()</span>
<span class="sd">				self._basis = basis[Ns-1::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._N = _np.array([],dtype=N.dtype)</span>
<span class="sd">				self._M = _np.array([],dtype=M.dtype)</span>
<span class="sd">				self._basis = _np.array([],dtype=basis.dtype)</span>
<span class="sd">			</span>
<span class="sd">			self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._N,self._M,self._basis,self._L,self._pars]</span>

<span class="sd">		elif (type(pblock) is int) and (type(zblock) is int):</span>
<span class="sd">			if self._conserved: self._conserved += &quot; &amp; P &amp; Z&quot;</span>
<span class="sd">			else: self._conserved += &quot;P &amp; Z&quot;</span>
<span class="sd">			basis = _np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">			N=_np.empty((Ns,),dtype=_np.int8)</span>
<span class="sd">			self._op = ops_module.p_z_op</span>
<span class="sd">			</span>
<span class="sd">			if (type(Np) is int):</span>
<span class="sd">				Ns = basis_module.n_p_z_basis(L,Np,pblock,zblock,self._pars,N,basis)</span>
<span class="sd">			else:</span>
<span class="sd">				Ns = basis_module.p_z_basis(L,pblock,zblock,self._pars,N,basis)</span>

<span class="sd">			if Ns &gt; 0:</span>
<span class="sd">				self._N = N[Ns-1::-1].copy()</span>
<span class="sd">				self._basis = basis[Ns-1::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._N = _np.array([],dtype=N.dtype)</span>
<span class="sd">				self._basis = _np.array([],dtype=basis.dtype)</span>
<span class="sd">				</span>
<span class="sd">			self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._N,self._basis,self._L,self._pars]</span>


<span class="sd">		elif (type(zAblock) is int) and (type(zBblock) is int):</span>
<span class="sd">			if self._conserved: self._conserved += &quot; &amp; ZA &amp; ZB&quot;</span>
<span class="sd">			else: self._conserved += &quot;ZA &amp; ZB&quot;</span>

<span class="sd">			self._op = ops_module.zA_zB_op</span>

<span class="sd">			basis = _np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">			N=_np.empty((Ns,),dtype=_np.int8)</span>
<span class="sd">			if (type(Np) is int):</span>
<span class="sd">				Ns = basis_module.n_zA_zB_basis(L,Np,zAblock,zBblock,self._pars,N,basis)</span>
<span class="sd">			else:</span>
<span class="sd">				Ns = basis_module.zA_zB_basis(L,zAblock,zBblock,self._pars,N,basis)</span>

<span class="sd">			if Ns &gt; 0:</span>
<span class="sd">				self._N = N[Ns-1::-1].copy()</span>
<span class="sd">				self._basis = basis[Ns-1::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._N = _np.array([],dtype=N.dtype)</span>
<span class="sd">				self._basis = _np.array([],dtype=basis.dtype)</span>
<span class="sd">				</span>
<span class="sd">			self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._N,self._basis,self._L,self._pars]</span>



<span class="sd">		elif type(pblock) is int:</span>
<span class="sd">			if self._conserved: self._conserved += &quot; &amp; P&quot;</span>
<span class="sd">			else: self._conserved = &quot;P&quot;</span>
<span class="sd">			basis = _np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">			N=_np.empty((Ns,),dtype=_np.int8)</span>
<span class="sd">			self._op = ops_module.p_op</span>

<span class="sd">			if (type(Np) is int):</span>
<span class="sd">				Ns = basis_module.n_p_basis(L,Np,pblock,self._pars,N,basis)</span>
<span class="sd">			else:</span>
<span class="sd">				Ns = basis_module.p_basis(L,pblock,self._pars,N,basis)</span>
<span class="sd">				</span>
<span class="sd">			if Ns &gt; 0:</span>
<span class="sd">				self._N = N[Ns-1::-1].copy()</span>
<span class="sd">				self._basis = basis[Ns-1::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._N = _np.array([],dtype=N.dtype)</span>
<span class="sd">				self._basis = _np.array([],dtype=basis.dtype)</span>
<span class="sd">				</span>
<span class="sd">			self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._N,self._basis,self._L,self._pars]</span>

<span class="sd">		elif type(zblock) is int:</span>
<span class="sd">			if self._conserved: self._conserved += &quot; &amp; Z&quot;</span>
<span class="sd">			else: self._conserved += &quot;Z&quot;</span>
<span class="sd">			basis = _np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">			N=_np.empty((Ns,),dtype=_np.int8)</span>
<span class="sd">			self._op = ops_module.z_op</span>

<span class="sd">			if (type(Np) is int):</span>
<span class="sd">				Ns = basis_module.n_z_basis(L,Np,zblock,self._pars,N,basis)</span>
<span class="sd">			else:</span>
<span class="sd">				Ns = basis_module.z_basis(L,zblock,self._pars,N,basis)</span>

<span class="sd">			if Ns &gt; 0:</span>
<span class="sd">				self._N = N[Ns-1::-1].copy()</span>
<span class="sd">				self._basis = basis[Ns-1::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._N = _np.array([],dtype=N.dtype)</span>
<span class="sd">				self._basis = _np.array([],dtype=basis.dtype)</span>
<span class="sd">				</span>
<span class="sd">			self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._N,self._basis,self._L,self._pars]</span>


<span class="sd">			</span>

<span class="sd">		elif type(zAblock) is int:</span>
<span class="sd">			if self._conserved: self._conserved += &quot; &amp; ZA&quot;</span>
<span class="sd">			else: self._conserved += &quot;ZA&quot;</span>
<span class="sd">			basis = _np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">			N=_np.empty((Ns,),dtype=_np.int8)</span>
<span class="sd">			self._op = ops_module.zA_op</span>

<span class="sd">			if (type(Np) is int):</span>
<span class="sd">				Ns = basis_module.n_zA_basis(L,Np,zAblock,self._pars,N,basis)</span>
<span class="sd">			else:</span>
<span class="sd">				Ns = basis_module.zA_basis(L,zAblock,self._pars,N,basis)</span>

<span class="sd">			if Ns &gt; 0:</span>
<span class="sd">				self._N = N[Ns-1::-1].copy()</span>
<span class="sd">				self._basis = basis[Ns-1::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._N = _np.array([],dtype=N.dtype)</span>
<span class="sd">				self._basis = _np.array([],dtype=basis.dtype)</span>
<span class="sd">				</span>
<span class="sd">			self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._N,self._basis,self._L,self._pars]</span>



<span class="sd">		elif type(zBblock) is int:</span>
<span class="sd">			if self._conserved: self._conserved += &quot; &amp; ZB&quot;</span>
<span class="sd">			else: self._conserved += &quot;ZB&quot;</span>
<span class="sd">			basis = _np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">			N=_np.empty((Ns,),dtype=_np.int8)</span>
<span class="sd">			self._op = ops_module.zB_op</span>

<span class="sd">			if (type(Np) is int):</span>
<span class="sd">				Ns = basis_module.n_zB_basis(L,Np,zBblock,self._pars,N,basis)</span>
<span class="sd">			else:</span>
<span class="sd">				Ns = basis_module.zB_basis(L,zBblock,self._pars,N,basis)</span>


<span class="sd">			if Ns &gt; 0:</span>
<span class="sd">				self._N = N[Ns-1::-1].copy()</span>
<span class="sd">				self._basis = basis[Ns-1::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._N = _np.array([],dtype=N.dtype)</span>
<span class="sd">				self._basis = _np.array([],dtype=basis.dtype)</span>
<span class="sd">				</span>
<span class="sd">			self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._N,self._basis,self._L,self._pars]</span>

<span class="sd">				</span>
<span class="sd">		elif type(pzblock) is int:</span>
<span class="sd">			if self._conserved: self._conserved += &quot; &amp; PZ&quot;</span>
<span class="sd">			else: self._conserved += &quot;PZ&quot;</span>
<span class="sd">			basis = _np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">			N=_np.empty((Ns,),dtype=_np.int8)</span>
<span class="sd">			self._op = ops_module.pz_op</span>

<span class="sd">			if (type(Np) is int):</span>
<span class="sd">				Ns = basis_module.n_pz_basis(L,Np,pzblock,self._pars,N,basis)</span>
<span class="sd">			else:</span>
<span class="sd">				Ns = basis_module.pz_basis(L,pzblock,self._pars,N,basis)</span>

<span class="sd">			if Ns &gt; 0:</span>
<span class="sd">				self._N = N[Ns-1::-1].copy()</span>
<span class="sd">				self._basis = basis[Ns-1::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._N = _np.array([],dtype=N.dtype)</span>
<span class="sd">				self._basis = _np.array([],dtype=basis.dtype)</span>
<span class="sd">				</span>
<span class="sd">			self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._N,self._basis,self._L,self._pars]</span>
<span class="sd">	</span>
<span class="sd">		elif type(kblock) is int:</span>
<span class="sd">			if self._conserved: self._conserved += &quot; &amp; T&quot;</span>
<span class="sd">			else: self._conserved = &quot;T&quot;</span>
<span class="sd">			basis=_np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">			self._op = ops_module.t_op</span>
<span class="sd">			</span>
<span class="sd">			if self._basis_type == _np.object:</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int32) </span>
<span class="sd">			else:			</span>
<span class="sd">				N=_np.empty(basis.shape,dtype=_np.int8)</span>

<span class="sd">			if (type(Np) is int):</span>
<span class="sd">				Ns = basis_module.n_t_basis(L,Np,kblock,a,self._pars,N,basis)</span>
<span class="sd">			else:</span>
<span class="sd">				Ns = basis_module.t_basis(L,kblock,a,self._pars,N,basis)</span>

<span class="sd">			if Ns &gt; 0:</span>
<span class="sd">				self._N = N[Ns-1::-1].copy()</span>
<span class="sd">				self._basis = basis[Ns-1::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._N = _np.array([],dtype=N.dtype)</span>
<span class="sd">				self._basis = _np.array([],dtype=basis.dtype)</span>

<span class="sd">			self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._N,self._basis,self._L,self._pars]</span>

<span class="sd">		else: </span>
<span class="sd">			if type(Np) is int:</span>
<span class="sd">				self._op = ops_module.n_op</span>
<span class="sd">				basis = _np.empty((Ns,),dtype=self._basis_type)</span>
<span class="sd">				basis_module.n_basis(L,Np,Ns,self._pars,basis)</span>
<span class="sd">				self._Ns = Ns</span>
<span class="sd">				self._basis = basis[::-1].copy()</span>
<span class="sd">			else:</span>
<span class="sd">				self._op = ops_module.op</span>
<span class="sd">				self._basis = _np.arange(Ns-1,-1,-1,dtype=self._basis_type)</span>
<span class="sd">				self._Ns = Ns</span>
<span class="sd">			self._op_args=[self._basis,self._pars]</span>


<span class="sd">		if count_particles: self._Np_list = _np.full(basis.shape,Np,dtype=_np.int8)</span>

<span class="sd">	def _append(self,other):</span>
<span class="sd">		Ns = self._Ns + other._Ns</span>

<span class="sd">		if self._conserved == &quot;&quot; or self._conserved == &quot;N&quot;:</span>
<span class="sd">			self._op_args=[self._pars]</span>
<span class="sd">		else:</span>
<span class="sd">			self._op_args=[self._L,self._pars]</span>


<span class="sd">		self._basis.resize((Ns,),refcheck=False)</span>
<span class="sd">		self._basis[self._Ns:] = other._basis[:]</span>
<span class="sd">		arg = self._basis.argsort()[::-1]</span>
<span class="sd">		self._basis = self._basis[arg].copy()</span>
<span class="sd">		self._op_args.insert(0,self._basis)</span>

<span class="sd">		if hasattr(self,&quot;_Np_list&quot;):</span>
<span class="sd">			self._Np_list.resize((Ns,),refcheck=False)</span>
<span class="sd">			self._Np_list[self._Ns:] = other._Np_list[:]</span>
<span class="sd">			self._Np_list = self._Np_list[arg].copy()</span>

<span class="sd">		if hasattr(self,&quot;_M&quot;):</span>
<span class="sd">			self._M.resize((Ns,),refcheck=False)</span>
<span class="sd">			self._M[self._Ns:] = other._M[:]</span>
<span class="sd">			self._M = self._M[arg].copy()</span>
<span class="sd">			self._op_args.insert(0,self._M)	</span>

<span class="sd">		if hasattr(self,&quot;_N&quot;):</span>
<span class="sd">			self._N.resize((Ns,),refcheck=False)</span>
<span class="sd">			self._N[self._Ns:] = other._N[:]</span>
<span class="sd">			self._N = self._N[arg].copy()</span>
<span class="sd">			self._op_args.insert(0,self._N)</span>

<span class="sd">		self._Ns = Ns</span>

<span class="sd">	@property</span>
<span class="sd">	def L(self):</span>
<span class="sd">		&quot;&quot;&quot;int: length of lattice.&quot;&quot;&quot;</span>
<span class="sd">		return self._L</span>

<span class="sd">	@property</span>
<span class="sd">	def N(self):</span>
<span class="sd">		&quot;&quot;&quot;int: number of sites the basis is constructed with.&quot;&quot;&quot;</span>
<span class="sd">		return self._L</span>


<span class="sd">	@property</span>
<span class="sd">	def description(self):</span>
<span class="sd">		&quot;&quot;&quot;str: information about `basis` object.&quot;&quot;&quot;</span>
<span class="sd">		blocks = &quot;&quot;</span>
<span class="sd">		lat_space = &quot;lattice spacing: a = {a}&quot;.format(**self._blocks)</span>

<span class="sd">		for symm in self._blocks:</span>
<span class="sd">			if symm != &quot;a&quot;:</span>
<span class="sd">				blocks += symm+&quot; = {&quot;+symm+&quot;}, &quot;</span>

<span class="sd">		blocks = blocks.format(**self._blocks)</span>

<span class="sd">		if len(self.conserved) == 0:</span>
<span class="sd">			symm = &quot;no symmetry&quot;</span>
<span class="sd">		elif len(self.conserved) == 1:</span>
<span class="sd">			symm = &quot;symmetry&quot;</span>
<span class="sd">		else:</span>
<span class="sd">			symm = &quot;symmetries&quot;</span>

<span class="sd">		string = &quot;&quot;&quot;1d basis for chain of L = {0} containing {5} states \n\t{1}: {2} \n\tquantum numbers: {4} \n\t{3} \n\n&quot;&quot;&quot;.format(self._L,symm,self._conserved,lat_space,blocks,self._Ns)</span>
<span class="sd">		string += self.operators</span>
<span class="sd">		return string </span>



<span class="sd">	def _Op(self,opstr,indx,J,dtype):</span>

<span class="sd">		indx = _np.asarray(indx,dtype=_np.int32)</span>

<span class="sd">		if len(opstr) != len(indx):</span>
<span class="sd">			raise ValueError(&#39;length of opstr does not match length of indx&#39;)</span>

<span class="sd">		if _np.any(indx &gt;= self._L) or _np.any(indx &lt; 0):</span>
<span class="sd">			raise ValueError(&#39;values in indx falls outside of system&#39;)</span>

<span class="sd">		extra_ops = set(opstr) - self._allowed_ops</span>
<span class="sd">		if extra_ops:</span>
<span class="sd">			raise ValueError(&quot;unrecognized characters {} in operator string.&quot;.format(extra_ops))</span>


<span class="sd">		if self._Ns &lt;= 0:</span>
<span class="sd">			return [],[],[]</span>

<span class="sd">		if self._unique_me:</span>
<span class="sd">			N_op = self.Ns</span>
<span class="sd">		else:</span>
<span class="sd">			N_op = 2*self.Ns</span>

<span class="sd">		col = _np.zeros(N_op,dtype=self._basis_type)</span>
<span class="sd">		row = _np.zeros(N_op,dtype=self._basis_type)</span>
<span class="sd">		ME = _np.zeros(N_op,dtype=dtype)</span>
<span class="sd">		error = self._op(row,col,ME,opstr,indx,J,*self._op_args,**self._blocks_1d)</span>

<span class="sd">		if error != 0: raise OpstrError(_basis_op_errors[error])</span>
<span class="sd">		# print ME,row,col</span>
<span class="sd">		mask = _np.logical_not(_np.logical_or(_np.isnan(ME),_np.abs(ME)==0.0))</span>
<span class="sd">		col = col[mask]</span>
<span class="sd">		row = row[mask]</span>
<span class="sd">		ME = ME[mask]</span>

<span class="sd">		return ME,row,col		</span>

<span class="sd">	def get_vec(self,v0,sparse=True):</span>
<span class="sd">		&quot;&quot;&quot;Transforms state from symmetry-reduced basis to full (symmetry-free) basis.</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		Particularly useful when a given operation canot be carried away in the symmetry-reduced basis</span>
<span class="sd">		in a straightforward manner.</span>

<span class="sd">		Supports parallelisation to multiple states listed in the columns.</span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		v0 : numpy.ndarray</span>
<span class="sd">			Contains in its columns the states in the symmetry-reduced basis.</span>
<span class="sd">		sparse : bool, optional</span>
<span class="sd">			Whether or not the output should be in sparse format. Default is `True`.</span>
<span class="sd">		</span>
<span class="sd">		Returns</span>
<span class="sd">		--------</span>
<span class="sd">		numpy.ndarray</span>
<span class="sd">			Array containing the state `v0` in the full basis.</span>

<span class="sd">		Examples</span>
<span class="sd">		--------</span>

<span class="sd">		&gt;&gt;&gt; v_full = get_vec(v0)</span>
<span class="sd">		&gt;&gt;&gt; print(v_full.shape, v0.shape)</span>

<span class="sd">		&quot;&quot;&quot;</span>

<span class="sd">		if not hasattr(v0,&quot;shape&quot;):</span>
<span class="sd">			v0 = _np.asanyarray(v0)</span>

<span class="sd">		squeeze = False</span>

<span class="sd">		if v0.ndim == 1:</span>
<span class="sd">			shape = (self._sps**self._L,1)</span>
<span class="sd">			v0 = v0.reshape((-1,1))</span>
<span class="sd">			squeeze = True</span>
<span class="sd">		elif v0.ndim == 2:</span>
<span class="sd">			shape = (self._sps**self._L,v0.shape[1])</span>
<span class="sd">		else:</span>
<span class="sd">			raise ValueError(&quot;excpecting v0 to have ndim at most 2&quot;)</span>

<span class="sd">		if self._Ns &lt;= 0:</span>
<span class="sd">			if sparse:</span>
<span class="sd">				return _sp.csr_matrix(([],([],[])),shape=(self._sps**self._L,0),dtype=v0.dtype)</span>
<span class="sd">			else:</span>
<span class="sd">				return _np.zeros((self._sps**self._L,0),dtype=v0.dtype)</span>

<span class="sd">		if v0.shape[0] != self._Ns:</span>
<span class="sd">			raise ValueError(&quot;v0 shape {0} not compatible with Ns={1}&quot;.format(v0.shape,self._Ns))</span>

<span class="sd">		if _sp.issparse(v0): # current work around for sparse states.</span>
<span class="sd">			return self.get_proj(v0.dtype).dot(v0)</span>

<span class="sd">		norms = self._get_norms(v0.dtype)</span>

<span class="sd">		a = self._blocks_1d.get(&quot;a&quot;)</span>
<span class="sd">		kblock = self._blocks_1d.get(&quot;kblock&quot;)</span>
<span class="sd">		pblock = self._blocks_1d.get(&quot;pblock&quot;)</span>
<span class="sd">		zblock = self._blocks_1d.get(&quot;zblock&quot;)</span>
<span class="sd">		zAblock = self._blocks_1d.get(&quot;zAblock&quot;)</span>
<span class="sd">		zBblock = self._blocks_1d.get(&quot;zBblock&quot;)</span>
<span class="sd">		pzblock = self._blocks_1d.get(&quot;pzblock&quot;)</span>


<span class="sd">		if (type(kblock) is int) and ((type(pblock) is int) or (type(pzblock) is int)):</span>
<span class="sd">			mask = (self._N &lt; 0)</span>
<span class="sd">			ind_neg, = _np.nonzero(mask)</span>
<span class="sd">			mask = (self._N &gt; 0)</span>
<span class="sd">			ind_pos, = _np.nonzero(mask)</span>
<span class="sd">			del mask</span>
<span class="sd">			def C(r,k,c,norms,dtype,ind_neg,ind_pos):</span>
<span class="sd">				c[ind_pos] = cos(dtype(k*r))</span>
<span class="sd">				c[ind_neg] = -sin(dtype(k*r))</span>
<span class="sd">				_np.true_divide(c,norms,c)</span>
<span class="sd">		else:</span>
<span class="sd">			ind_pos = _np.fromiter(range(v0.shape[0]),count=v0.shape[0],dtype=_np.int32)</span>
<span class="sd">			ind_neg = array([],dtype=_np.int32)</span>
<span class="sd">			def C(r,k,c,norms,dtype,*args):</span>
<span class="sd">				if k == 0.0:</span>
<span class="sd">					c[:] = 1.0</span>
<span class="sd">				elif k == pi:</span>
<span class="sd">					c[:] = (-1.0)**r</span>
<span class="sd">				else:</span>
<span class="sd">					c[:] = exp(dtype(1.0j*k*r))</span>
<span class="sd">				_np.true_divide(c,norms,c)</span>

<span class="sd">		if sparse:</span>
<span class="sd">			return _get_vec_sparse(self._bitops,self._pars,v0,self._basis,norms,ind_neg,ind_pos,shape,C,self._L,**self._blocks_1d)</span>
<span class="sd">		else:</span>
<span class="sd">			if squeeze:</span>
<span class="sd">				return  _np.squeeze(_get_vec_dense(self._bitops,self._pars,v0,self._basis,norms,ind_neg,ind_pos,shape,C,self._L,**self._blocks_1d))</span>
<span class="sd">			else:</span>
<span class="sd">				return _get_vec_dense(self._bitops,self._pars,v0,self._basis,norms,ind_neg,ind_pos,shape,C,self._L,**self._blocks_1d)</span>

<span class="sd">	def get_proj(self,dtype,pcon=False):</span>
<span class="sd">		&quot;&quot;&quot;Calculates transformation/projector from symmetry-reduced basis to full (symmetry-free) basis.</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		Particularly useful when a given operation canot be carried away in the symmetry-reduced basis</span>
<span class="sd">		in a straightforward manner.</span>

<span class="sd">		Parameters</span>
<span class="sd">		-----------</span>
<span class="sd">		dtype : &#39;type&#39;</span>
<span class="sd">			Data type (e.g. numpy.float64) to construct the projector with.</span>
<span class="sd">		sparse : bool, optional</span>
<span class="sd">			Whether or not the output should be in sparse format. Default is `True`.</span>
<span class="sd">		pcon : bool, optional</span>
<span class="sd">			Whether or not to return the projector to the particle number (magnetisation) conserving basis </span>
<span class="sd">			(useful in bosonic/single particle systems). Default is `pcon=False`.</span>
<span class="sd">		</span>
<span class="sd">		Returns</span>
<span class="sd">		--------</span>
<span class="sd">		scipy.sparse.csr_matrix</span>
<span class="sd">			Transformation/projector between the symmetry-reduced and the full basis.</span>

<span class="sd">		Examples</span>
<span class="sd">		--------</span>

<span class="sd">		&gt;&gt;&gt; P = get_proj(np.float64,pcon=False)</span>
<span class="sd">		&gt;&gt;&gt; print(P.shape)</span>

<span class="sd">		&quot;&quot;&quot;</span>

<span class="sd">		norms = self._get_norms(dtype)</span>

<span class="sd">		a = self._blocks_1d.get(&quot;a&quot;)</span>
<span class="sd">		kblock = self._blocks_1d.get(&quot;kblock&quot;)</span>
<span class="sd">		pblock = self._blocks_1d.get(&quot;pblock&quot;)</span>
<span class="sd">		zblock = self._blocks_1d.get(&quot;zblock&quot;)</span>
<span class="sd">		zAblock = self._blocks_1d.get(&quot;zAblock&quot;)</span>
<span class="sd">		zBblock = self._blocks_1d.get(&quot;zBblock&quot;)</span>
<span class="sd">		pzblock = self._blocks_1d.get(&quot;pzblock&quot;)</span>

<span class="sd">		</span>

<span class="sd">		if pcon and self._get_proj_pcon:</span>
<span class="sd">			basis_pcon = _np.ones(self._Ns_pcon,dtype=self._basis_type)</span>
<span class="sd">			self._make_n_basis(self.L,self._Np,self._Ns_pcon,self._pars,basis_pcon)</span>
<span class="sd">			shape = (self._Ns_pcon,self._Ns)</span>
<span class="sd">		elif pcon and not self._get_proj_pcon:</span>
<span class="sd">			raise TypeError(&quot;pcon=True only works for basis of a single particle number sector.&quot;)</span>
<span class="sd">		else:</span>
<span class="sd">			shape = (self.sps**self.L,self._Ns)</span>
<span class="sd">			basis_pcon = None</span>

<span class="sd">		if self._Ns &lt;= 0:</span>
<span class="sd">			return _sp.csr_matrix(([],([],[])),shape=shape)</span>


<span class="sd">		if (type(kblock) is int) and ((type(pblock) is int) or (type(pzblock) is int)):</span>
<span class="sd">			mask = (self._N &lt; 0)</span>
<span class="sd">			ind_neg, = _np.nonzero(mask)</span>
<span class="sd">			mask = (self._N &gt; 0)</span>
<span class="sd">			ind_pos, = _np.nonzero(mask)</span>
<span class="sd">			del mask</span>
<span class="sd">			def C(r,k,c,norms,dtype,ind_neg,ind_pos):</span>
<span class="sd">				c[ind_pos] = cos(dtype(k*r))</span>
<span class="sd">				c[ind_neg] = -sin(dtype(k*r))</span>
<span class="sd">				_np.true_divide(c,norms,c)</span>
<span class="sd">		else:</span>
<span class="sd">			if (type(kblock) is int):</span>
<span class="sd">				if ((2*kblock*a) % self._L != 0) and not _np.iscomplexobj(dtype(1.0)):</span>
<span class="sd">					raise TypeError(&quot;symmetries give complex vector, requested dtype is not complex&quot;)</span>

<span class="sd">			ind_pos = _np.arange(0,self._Ns,1)</span>
<span class="sd">			ind_neg = array([],dtype=_np.int32)</span>
<span class="sd">			def C(r,k,c,norms,dtype,*args):</span>
<span class="sd">				if k == 0.0:</span>
<span class="sd">					c[:] = 1.0</span>
<span class="sd">				elif k == pi:</span>
<span class="sd">					c[:] = (-1.0)**r</span>
<span class="sd">				else:</span>
<span class="sd">					c[:] = exp(dtype(1.0j*k*r))</span>
<span class="sd">				_np.true_divide(c,norms,c)</span>





<span class="sd">		return _get_proj_sparse(self._bitops,self._pars,self._basis,basis_pcon,norms,ind_neg,ind_pos,dtype,shape,C,self._L,**self._blocks_1d)</span>

<span class="sd">	def _get_norms(self,dtype):</span>
<span class="sd">		a = self._blocks_1d.get(&quot;a&quot;)</span>
<span class="sd">		kblock = self._blocks_1d.get(&quot;kblock&quot;)</span>
<span class="sd">		pblock = self._blocks_1d.get(&quot;pblock&quot;)</span>
<span class="sd">		zblock = self._blocks_1d.get(&quot;zblock&quot;)</span>
<span class="sd">		zAblock = self._blocks_1d.get(&quot;zAblock&quot;)</span>
<span class="sd">		zBblock = self._blocks_1d.get(&quot;zBblock&quot;)</span>
<span class="sd">		pzblock = self._blocks_1d.get(&quot;pzblock&quot;)</span>

<span class="sd">		if (type(kblock) is int) and (type(pblock) is int) and (type(zblock) is int):</span>
<span class="sd">			c = _np.empty(self._M.shape,dtype=_np.int8)</span>
<span class="sd">			nn = array(c)</span>
<span class="sd">			mm = array(c)</span>
<span class="sd">			sign = array(c)</span>

<span class="sd">			_np.sign(self._N,out=sign)			</span>
<span class="sd">			</span>
<span class="sd">			_np.floor_divide(self._M,(self._L+1)**2,out=c)</span>
<span class="sd">			_np.floor_divide(self._M,self._L+1,out=nn)</span>
<span class="sd">			_np.mod(nn,self._L+1,out=nn)</span>
<span class="sd">			_np.mod(self._M,self._L+1,out=mm)</span>
<span class="sd">			</span>
<span class="sd">			if _np.abs(_np.sin(self._k)) &lt; 1.0/self._L:</span>
<span class="sd">				norm = _np.full(self._basis.shape,4*(self._L/a)**2,dtype=dtype)</span>
<span class="sd">			else:</span>
<span class="sd">				norm = _np.full(self._basis.shape,2*(self._L/a)**2,dtype=dtype)</span>

<span class="sd">				</span>
<span class="sd">			norm *= sign</span>
<span class="sd">			norm /= self._N</span>

<span class="sd">			mask = c == 1</span>
<span class="sd">			norm[mask] *= (1.0 - sign[mask]*pblock*_np.cos(self._k*mm[mask]))</span>
<span class="sd">			_np.equal(c,2,out=mask)</span>
<span class="sd">			norm[mask] *= (1.0 + sign[mask]*pblock*_np.cos(self._k*mm[mask]))</span>
<span class="sd">			_np.equal(c,3,out=mask)</span>
<span class="sd">			norm[mask] *= (1.0 - zblock*_np.cos(self._k*nn[mask]))	</span>
<span class="sd">			_np.equal(c,4,out=mask)</span>
<span class="sd">			norm[mask] *= (1.0 + zblock*_np.cos(self._k*nn[mask]))	</span>
<span class="sd">			_np.equal(c,5,out=mask)</span>
<span class="sd">			norm[mask] *= (1.0 - sign[mask]*pzblock*_np.cos(self._k*mm[mask]))	</span>
<span class="sd">			_np.equal(c,6,out=mask)</span>
<span class="sd">			norm[mask] *= (1.0 + sign[mask]*pzblock*_np.cos(self._k*mm[mask]))	</span>
<span class="sd">			_np.equal(c,7,out=mask)</span>
<span class="sd">			norm[mask] *= (1.0 - sign[mask]*pblock*_np.cos(self._k*mm[mask]))</span>
<span class="sd">			norm[mask] *= (1.0 - zblock*_np.cos(self._k*nn[mask]))	</span>
<span class="sd">			_np.equal(c,8,out=mask)</span>
<span class="sd">			norm[mask] *= (1.0 + sign[mask]*pblock*_np.cos(self._k*mm[mask]))</span>
<span class="sd">			norm[mask] *= (1.0 - zblock*_np.cos(self._k*nn[mask]))	</span>
<span class="sd">			_np.equal(c,9,out=mask)</span>
<span class="sd">			norm[mask] *= (1.0 - sign[mask]*pblock*_np.cos(self._k*mm[mask]))</span>
<span class="sd">			norm[mask] *= (1.0 + zblock*_np.cos(self._k*nn[mask]))	</span>
<span class="sd">			_np.equal(c,10,out=mask)</span>
<span class="sd">			norm[mask] *= (1.0 + sign[mask]*pblock*_np.cos(self._k*mm[mask]))</span>
<span class="sd">			norm[mask] *= (1.0 + zblock*_np.cos(self._k*nn[mask]))	</span>
<span class="sd">			del mask</span>
<span class="sd">		elif (type(kblock) is int) and (type(zAblock) is int) and (type(zBblock) is int):</span>
<span class="sd">			c = _np.empty(self._M.shape,dtype=_np.int8)</span>
<span class="sd">			mm = array(c)</span>
<span class="sd">			_np.floor_divide(self._M,(self._L+1),c)</span>
<span class="sd">			_np.mod(self._M,self._L+1,mm)</span>
<span class="sd">			norm = _np.full(self._basis.shape,4*(self._L/a)**2,dtype=dtype)</span>
<span class="sd">			norm /= self._N</span>
<span class="sd">			mask = (c == 2)</span>
<span class="sd">			norm[mask] *= (1.0 + zAblock*_np.cos(self._k*mm[mask]))</span>
<span class="sd">			_np.equal(c,3,out=mask)</span>
<span class="sd">			norm[mask] *= (1.0 + zBblock*_np.cos(self._k*mm[mask]))	</span>
<span class="sd">			_np.equal(c,4,out=mask)</span>
<span class="sd">			norm[mask] *= (1.0 + zblock*_np.cos(self._k*mm[mask]))	</span>
<span class="sd">			del mask</span>
<span class="sd">		elif (type(kblock) is int) and (type(pblock) is int):</span>
<span class="sd">			if _np.abs(_np.sin(self._k)) &lt; 1.0/self._L:</span>
<span class="sd">				norm = _np.full(self._basis.shape,2*(self._L/a)**2,dtype=dtype)</span>
<span class="sd">			else:</span>
<span class="sd">				norm = _np.full(self._basis.shape,(self._L/a)**2,dtype=dtype)</span>
<span class="sd">			norm *= _np.sign(self._N)</span>
<span class="sd">			norm /= self._N</span>
<span class="sd">			try:</span>
<span class="sd">				m = self._M.astype(_np.min_scalar_type(-1*(self._M[0]+1)))</span>
<span class="sd">			except IndexError:</span>
<span class="sd">				m = self._M.astype(_np.int8)</span>
<span class="sd">			_np.mod(m,self._L+1,out=m)</span>
<span class="sd">			m -= 1</span>
<span class="sd">			mask = (m &gt;= 0)</span>
<span class="sd">			sign = _np.empty(mask.sum(),dtype=_np.int8)</span>
<span class="sd">			_np.floor_divide(self._M[mask],(self._L+1),out=sign)</span>
<span class="sd">			sign *= 2</span>
<span class="sd">			sign -= 1</span>
<span class="sd">			sign *= self._N[mask]</span>
<span class="sd">			_np.sign(sign,out=sign)</span>
<span class="sd">			norm[mask] *= (1.0 + sign*pblock*_np.cos(self._k*m[mask]))</span>
<span class="sd">			del mask</span>
<span class="sd">		elif (type(kblock) is int) and (type(pzblock) is int):</span>
<span class="sd">			if _np.abs(_np.sin(self._k)) &lt; 1.0/self._L:</span>
<span class="sd">				norm = _np.full(self._basis.shape,2*(self._L/a)**2,dtype=dtype)</span>
<span class="sd">			else:</span>
<span class="sd">				norm = _np.full(self._basis.shape,(self._L/a)**2,dtype=dtype)</span>
<span class="sd">			norm *= _np.sign(self._N)</span>
<span class="sd">			norm /= self._N</span>
<span class="sd">			m = self._M.astype(_np.int8)</span>
<span class="sd">			_np.mod(m,self._L+1,out=m)</span>
<span class="sd">			m -= 1</span>
<span class="sd">			mask = (m &gt;= 0)</span>

<span class="sd">			sign = _np.empty(mask.sum(),dtype=_np.int8)</span>
<span class="sd">			_np.floor_divide(self._M[mask],(self._L+1),out=sign)</span>
<span class="sd">			sign *= 2</span>
<span class="sd">			sign -= 1</span>
<span class="sd">			sign *= self._N[mask]</span>
<span class="sd">			_np.sign(sign,out=sign)</span>

<span class="sd">			norm[mask] *= (1.0 + sign*pzblock*_np.cos(self._k*m[mask]))</span>
<span class="sd">			del mask</span>
<span class="sd">		elif (type(kblock) is int) and (type(zblock) is int):</span>
<span class="sd">			norm = _np.full(self._basis.shape,2*(self._L/a)**2,dtype=dtype)</span>
<span class="sd">			norm /= self._N</span>
<span class="sd">			</span>
<span class="sd">			m = self._M.astype(_np.int8)</span>
<span class="sd">			_np.mod(m,self._L+1,out=m)</span>
<span class="sd">			m -= 1</span>
<span class="sd">			mask = (m &gt;= 0)</span>

<span class="sd">			sign = _np.empty(mask.sum(),dtype=_np.int8)</span>
<span class="sd">			_np.floor_divide(self._M[mask],(self._L+1),out=sign)</span>
<span class="sd">			sign *= 2</span>
<span class="sd">			sign -= 1</span>

<span class="sd">			norm[mask] *= (1.0 + sign*zblock*_np.cos(self._k*m[mask]))</span>
<span class="sd">			del mask</span>
<span class="sd">		elif (type(kblock) is int) and (type(zAblock) is int):</span>
<span class="sd">			norm = _np.full(self._basis.shape,2*(self._L/a)**2,dtype=dtype)</span>
<span class="sd">			norm /= self._N</span>
<span class="sd">			mask = (self._M &gt; 0)</span>
<span class="sd">			m = _np.empty(self._M.shape,dtype=_np.int8)</span>
<span class="sd">			_np.subtract(self._M,1,out=m)</span>
<span class="sd">			norm[mask] *= (1.0 + zAblock*_np.cos(self._k*m[mask]))</span>
<span class="sd">			del mask</span>
<span class="sd">		elif (type(kblock) is int) and (type(zBblock) is int):</span>
<span class="sd">			norm = _np.full(self._basis.shape,2*(self._L/a)**2,dtype=dtype)</span>
<span class="sd">			norm /= self._N</span>
<span class="sd">			mask = (self._M &gt; 0)</span>
<span class="sd">			m = _np.empty(self._M.shape,dtype=_np.int8)</span>
<span class="sd">			_np.subtract(self._M,1,out=m)</span>
<span class="sd">			norm[mask] *= (1.0 + zBblock*_np.cos(self._k*m[mask]))</span>
<span class="sd">			del mask</span>
<span class="sd">		elif (type(pblock) is int) and (type(zblock) is int):</span>
<span class="sd">			norm = array(self._N,dtype=dtype)</span>
<span class="sd">		elif (type(zAblock) is int) and (type(zBblock) is int):</span>
<span class="sd">			norm = array(self._N,dtype=dtype)</span>
<span class="sd">		elif (type(pblock) is int):</span>
<span class="sd">			norm = array(self._N,dtype=dtype)</span>
<span class="sd">		elif (type(pzblock) is int):</span>
<span class="sd">			norm = array(self._N,dtype=dtype)</span>
<span class="sd">		elif (type(zblock) is int):</span>
<span class="sd">			norm = array(self._N,dtype=dtype)</span>
<span class="sd">		elif (type(zAblock) is int):</span>
<span class="sd">			norm = array(self._N,dtype=dtype)</span>
<span class="sd">		elif (type(zBblock) is int):</span>
<span class="sd">			norm = array(self._N,dtype=dtype)</span>
<span class="sd">		elif (type(kblock) is int):</span>
<span class="sd">			norm = _np.full(self._basis.shape,(self._L/a)**2,dtype=dtype)</span>
<span class="sd">			norm /= self._N</span>
<span class="sd">		else:</span>
<span class="sd">			norm = _np.ones(self._basis.shape,dtype=dtype)</span>

<span class="sd">		_np.sqrt(norm,norm)</span>

<span class="sd">		return norm</span>

<span class="sd">	##### provate methods</span>

<span class="sd">	def _check_symm(self,static,dynamic,photon_basis=None):</span>
<span class="sd">		kblock = self._blocks_1d.get(&quot;kblock&quot;)</span>
<span class="sd">		pblock = self._blocks_1d.get(&quot;pblock&quot;)</span>
<span class="sd">		zblock = self._blocks_1d.get(&quot;zblock&quot;)</span>
<span class="sd">		pzblock = self._blocks_1d.get(&quot;pzblock&quot;)</span>
<span class="sd">		zAblock = self._blocks_1d.get(&quot;zAblock&quot;)</span>
<span class="sd">		zBblock = self._blocks_1d.get(&quot;zBblock&quot;)</span>
<span class="sd">		a = self._blocks_1d.get(&quot;a&quot;)</span>
<span class="sd">		L = self.L</span>

<span class="sd">		if photon_basis is None:</span>
<span class="sd">			basis_sort_opstr = self._sort_opstr</span>
<span class="sd">			static_list,dynamic_list = self._get_local_lists(static,dynamic)</span>
<span class="sd">		else:</span>
<span class="sd">			basis_sort_opstr = photon_basis._sort_opstr</span>
<span class="sd">			static_list,dynamic_list = photon_basis._get_local_lists(static,dynamic)</span>


<span class="sd">		static_blocks = {}</span>
<span class="sd">		dynamic_blocks = {}</span>
<span class="sd">		if kblock is not None:</span>
<span class="sd">			missingops = _check.check_T(basis_sort_opstr,static_list,L,a)</span>
<span class="sd">			if missingops:	static_blocks[&quot;T symm&quot;] = (tuple(missingops),)</span>

<span class="sd">			missingops = _check.check_T(basis_sort_opstr,dynamic_list,L,a)</span>
<span class="sd">			if missingops:	dynamic_blocks[&quot;T symm&quot;] = (tuple(missingops),)</span>

<span class="sd">		if pblock is not None:</span>
<span class="sd">			missingops = _check.check_P(basis_sort_opstr,static_list,L)</span>
<span class="sd">			if missingops:	static_blocks[&quot;P symm&quot;] = (tuple(missingops),)</span>

<span class="sd">			missingops = _check.check_P(basis_sort_opstr,dynamic_list,L)</span>
<span class="sd">			if missingops:	dynamic_blocks[&quot;P symm&quot;] = (tuple(missingops),)</span>

<span class="sd">		if zblock is not None:</span>
<span class="sd">			oddops,missingops = _check.check_Z(basis_sort_opstr,static_list)</span>
<span class="sd">			if missingops or oddops:</span>
<span class="sd">				static_blocks[&quot;Z/C symm&quot;] = (tuple(oddops),tuple(missingops))</span>

<span class="sd">			oddops,missingops = _check.check_Z(basis_sort_opstr,dynamic_list)</span>
<span class="sd">			if missingops or oddops:</span>
<span class="sd">				dynamic_blocks[&quot;Z/C symm&quot;] = (tuple(oddops),tuple(missingops))</span>

<span class="sd">		if zAblock is not None:</span>
<span class="sd">			oddops,missingops = _check.check_ZA(basis_sort_opstr,static_list)</span>
<span class="sd">			if missingops or oddops:</span>
<span class="sd">				static_blocks[&quot;ZA/CA symm&quot;] = (tuple(oddops),tuple(missingops))</span>

<span class="sd">			oddops,missingops = _check.check_ZA(basis_sort_opstr,dynamic_list)</span>
<span class="sd">			if missingops or oddops:</span>
<span class="sd">				dynamic_blocks[&quot;ZA/CA symm&quot;] = (tuple(oddops),tuple(missingops))</span>

<span class="sd">		if zBblock is not None:</span>
<span class="sd">			oddops,missingops = _check.check_ZB(basis_sort_opstr,static_list)</span>
<span class="sd">			if missingops or oddops:</span>
<span class="sd">				static_blocks[&quot;ZB/CB symm&quot;] = (tuple(oddops),tuple(missingops))</span>

<span class="sd">			oddops,missingops = _check.check_ZB(basis_sort_opstr,dynamic_list)</span>
<span class="sd">			if missingops or oddops:</span>
<span class="sd">				dynamic_blocks[&quot;ZB/CB symm&quot;] = (tuple(oddops),tuple(missingops))</span>

<span class="sd">		if pzblock is not None:</span>
<span class="sd">			missingops = _check.check_PZ(basis_sort_opstr,static_list,L)</span>
<span class="sd">			if missingops:	static_blocks[&quot;PZ/PC symm&quot;] = (tuple(missingops),)</span>

<span class="sd">			missingops = _check.check_PZ(basis_sort_opstr,dynamic_list,L)</span>
<span class="sd">			if missingops:	dynamic_blocks[&quot;PZ/PC symm&quot;] = (tuple(missingops),)</span>

<span class="sd">		return static_blocks,dynamic_blocks</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span> <span class="nf">_get_vec_dense</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">basis_in</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">,</span><span class="n">shape</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="o">**</span><span class="n">blocks</span><span class="p">):</span>
	<span class="n">dtype</span><span class="o">=</span><span class="n">_dtypes</span><span class="p">[</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="p">]</span>

	<span class="n">a</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
	<span class="n">kblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kblock&quot;</span><span class="p">)</span>
	<span class="n">pblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pblock&quot;</span><span class="p">)</span>
	<span class="n">zblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zblock&quot;</span><span class="p">)</span>
	<span class="n">zAblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zAblock&quot;</span><span class="p">)</span>
	<span class="n">zBblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zBblock&quot;</span><span class="p">)</span>
	<span class="n">pzblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pzblock&quot;</span><span class="p">)</span>


	<span class="n">c</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">basis_in</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
	<span class="n">sign</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">basis_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>	
	<span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

	<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
		<span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">kblock</span><span class="o">*</span><span class="n">a</span><span class="o">/</span><span class="n">L</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">k</span> <span class="o">=</span> <span class="mf">0.0</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">L</span>
	
	<span class="n">Ns_full</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">v_rev</span> <span class="o">=</span> <span class="n">v</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># access array in reverse order. </span>

	<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">L</span><span class="o">//</span><span class="n">a</span><span class="p">):</span>
		<span class="n">C</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">)</span>	
		<span class="n">vc</span> <span class="o">=</span> <span class="p">(</span><span class="n">v0</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
		<span class="n">vc_tran</span> <span class="o">=</span> <span class="n">vc</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
		<span class="n">vc_tran</span> <span class="o">*=</span> <span class="n">sign</span>
		<span class="n">v_rev</span><span class="p">[</span><span class="n">basis_in</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">vc</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
		<span class="n">v_rev</span><span class="p">[</span><span class="n">basis_in</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">vc</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
		<span class="n">vc_tran</span> <span class="o">*=</span> <span class="n">sign</span>

		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">zAblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_sublat_A</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">vc</span> <span class="o">*=</span> <span class="n">zAblock</span>
			<span class="n">vc_tran</span> <span class="o">*=</span> <span class="n">sign</span>
			<span class="n">v_rev</span><span class="p">[</span><span class="n">basis_in</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">vc</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">v_rev</span><span class="p">[</span><span class="n">basis_in</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">vc</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">vc</span> <span class="o">*=</span> <span class="n">zAblock</span>
			<span class="n">vc_tran</span> <span class="o">*=</span> <span class="n">sign</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_sublat_A</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
		
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">zBblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_sublat_B</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">vc</span> <span class="o">*=</span> <span class="n">zBblock</span>
			<span class="n">vc_tran</span> <span class="o">*=</span> <span class="n">sign</span>
			<span class="n">v_rev</span><span class="p">[</span><span class="n">basis_in</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">vc</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">v_rev</span><span class="p">[</span><span class="n">basis_in</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">vc</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">vc</span> <span class="o">*=</span> <span class="n">zBblock</span>
			<span class="n">vc_tran</span> <span class="o">*=</span> <span class="n">sign</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_sublat_B</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
		
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">zblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_all</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">vc</span> <span class="o">*=</span> <span class="n">zblock</span>
			<span class="n">vc_tran</span> <span class="o">*=</span> <span class="n">sign</span>
			<span class="n">v_rev</span><span class="p">[</span><span class="n">basis_in</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">vc</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">v_rev</span><span class="p">[</span><span class="n">basis_in</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">vc</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">vc</span> <span class="o">*=</span> <span class="n">zblock</span>
			<span class="n">vc_tran</span> <span class="o">*=</span> <span class="n">sign</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_all</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_fliplr</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">vc</span> <span class="o">*=</span> <span class="n">pblock</span>
			<span class="n">vc_tran</span> <span class="o">*=</span> <span class="n">sign</span>
			<span class="n">v_rev</span><span class="p">[</span><span class="n">basis_in</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">vc</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">v_rev</span><span class="p">[</span><span class="n">basis_in</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">vc</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">vc</span> <span class="o">*=</span> <span class="n">pblock</span>
			<span class="n">vc_tran</span> <span class="o">*=</span> <span class="n">sign</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_fliplr</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pzblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_fliplr</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_all</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">vc</span> <span class="o">*=</span> <span class="n">pzblock</span>
			<span class="n">vc_tran</span> <span class="o">*=</span> <span class="n">sign</span>
			<span class="n">v_rev</span><span class="p">[</span><span class="n">basis_in</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">vc</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">v_rev</span><span class="p">[</span><span class="n">basis_in</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">vc</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">vc</span> <span class="o">*=</span> <span class="n">pzblock</span>
			<span class="n">vc_tran</span> <span class="o">*=</span> <span class="n">sign</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_fliplr</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_all</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
		
		<span class="n">ops</span><span class="o">.</span><span class="n">py_shift</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
	
	<span class="k">return</span> <span class="n">v</span>

<span class="k">def</span> <span class="nf">_get_vec_sparse</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">basis_in</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">,</span><span class="n">shape</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="o">**</span><span class="n">blocks</span><span class="p">):</span>
	<span class="n">dtype</span><span class="o">=</span><span class="n">_dtypes</span><span class="p">[</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="p">]</span>

	<span class="n">a</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
	<span class="n">kblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kblock&quot;</span><span class="p">)</span>
	<span class="n">pblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pblock&quot;</span><span class="p">)</span>
	<span class="n">zblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zblock&quot;</span><span class="p">)</span>
	<span class="n">zAblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zAblock&quot;</span><span class="p">)</span>
	<span class="n">zBblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zBblock&quot;</span><span class="p">)</span>
	<span class="n">pzblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pzblock&quot;</span><span class="p">)</span>

	<span class="n">m</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


	
	<span class="k">if</span> <span class="n">ind_neg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">row_neg</span> <span class="o">=</span> <span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
		<span class="n">col_neg</span> <span class="o">=</span> <span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">col_neg</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">row_neg</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">ind_neg</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">col_neg</span><span class="p">))</span>
		<span class="n">col_neg</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ind_neg</span><span class="p">),</span><span class="n">col_neg</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">ind_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">row_pos</span> <span class="o">=</span> <span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
		<span class="n">col_pos</span> <span class="o">=</span> <span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">col_pos</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">row_pos</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">ind_pos</span><span class="p">,</span><span class="n">_np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">col_pos</span><span class="p">))</span>
		<span class="n">col_pos</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ind_pos</span><span class="p">),</span><span class="n">col_pos</span><span class="p">)</span>


	<span class="n">c</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">basis_in</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>	
	<span class="n">sign</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">basis_in</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

	<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
		<span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">kblock</span><span class="o">*</span><span class="n">a</span><span class="o">/</span><span class="n">L</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">k</span> <span class="o">=</span> <span class="mf">0.0</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">L</span>


	<span class="n">Ns_full</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">basis_in</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">L</span><span class="o">//</span><span class="n">a</span><span class="p">):</span>
		<span class="n">C</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">)</span>
		<span class="n">vc</span> <span class="o">=</span> <span class="p">(</span><span class="n">v0</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
		<span class="n">data_pos</span> <span class="o">=</span> <span class="n">vc</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="n">data_neg</span> <span class="o">=</span> <span class="n">vc</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
		<span class="c1"># view which passes into sparse matrix constructor</span>
		<span class="n">data_pos_flat</span> <span class="o">=</span> <span class="n">data_pos</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
		<span class="n">data_neg_flat</span> <span class="o">=</span> <span class="n">data_neg</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
		<span class="c1"># view which us used to multiply by sign</span>
		<span class="n">data_pos_tran</span> <span class="o">=</span> <span class="n">data_pos</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
		<span class="n">data_neg_tran</span> <span class="o">=</span> <span class="n">data_neg</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
		
		<span class="n">data_pos_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
		<span class="n">data_neg_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
		<span class="n">index</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Ns_full</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="n">index</span> <span class="o">-=</span> <span class="n">basis_in</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_pos_flat</span><span class="p">,(</span><span class="n">index</span><span class="p">[</span><span class="n">row_pos</span><span class="p">],</span><span class="n">col_pos</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_neg_flat</span><span class="p">,(</span><span class="n">index</span><span class="p">[</span><span class="n">row_neg</span><span class="p">],</span><span class="n">col_neg</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
		<span class="n">data_pos_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
		<span class="n">data_neg_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>

		<span class="n">index</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Ns_full</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">zAblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_sublat_A</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">zAblock</span>
			<span class="n">data_pos_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">zAblock</span>
			<span class="n">data_neg_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">index</span> <span class="o">-=</span> <span class="n">basis_in</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_pos_flat</span><span class="p">,(</span><span class="n">index</span><span class="p">[</span><span class="n">row_pos</span><span class="p">],</span><span class="n">col_pos</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_neg_flat</span><span class="p">,(</span><span class="n">index</span><span class="p">[</span><span class="n">row_neg</span><span class="p">],</span><span class="n">col_neg</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">zAblock</span>
			<span class="n">data_pos_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">zAblock</span>
			<span class="n">data_neg_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_sublat_A</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>

		<span class="n">index</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Ns_full</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">zBblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_sublat_B</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">zBblock</span>
			<span class="n">data_pos_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">zBblock</span>
			<span class="n">data_neg_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">index</span> <span class="o">-=</span> <span class="n">basis_in</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_pos_flat</span><span class="p">,(</span><span class="n">index</span><span class="p">[</span><span class="n">row_pos</span><span class="p">],</span><span class="n">col_pos</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_neg_flat</span><span class="p">,(</span><span class="n">index</span><span class="p">[</span><span class="n">row_neg</span><span class="p">],</span><span class="n">col_neg</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">zBblock</span>
			<span class="n">data_pos_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">zBblock</span>
			<span class="n">data_neg_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_sublat_B</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>

		<span class="n">index</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Ns_full</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">zblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_all</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">zblock</span>
			<span class="n">data_pos_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">zblock</span>
			<span class="n">data_neg_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">index</span> <span class="o">-=</span> <span class="n">basis_in</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_pos_flat</span><span class="p">,(</span><span class="n">index</span><span class="p">[</span><span class="n">row_pos</span><span class="p">],</span><span class="n">col_pos</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_neg_flat</span><span class="p">,(</span><span class="n">index</span><span class="p">[</span><span class="n">row_neg</span><span class="p">],</span><span class="n">col_neg</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">zblock</span>
			<span class="n">data_pos_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">zblock</span>
			<span class="n">data_neg_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_all</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>

		<span class="n">index</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Ns_full</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_fliplr</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">pblock</span>
			<span class="n">data_pos_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">pblock</span>
			<span class="n">data_neg_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">index</span> <span class="o">-=</span> <span class="n">basis_in</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_pos_flat</span><span class="p">,(</span><span class="n">index</span><span class="p">[</span><span class="n">row_pos</span><span class="p">],</span><span class="n">col_pos</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_neg_flat</span><span class="p">,(</span><span class="n">index</span><span class="p">[</span><span class="n">row_neg</span><span class="p">],</span><span class="n">col_neg</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">pblock</span>
			<span class="n">data_pos_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">pblock</span>
			<span class="n">data_neg_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_fliplr</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>

		<span class="n">index</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Ns_full</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pzblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_all</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_fliplr</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">pzblock</span>
			<span class="n">data_pos_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">pzblock</span>
			<span class="n">data_neg_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">index</span> <span class="o">-=</span> <span class="n">basis_in</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_pos_flat</span><span class="p">,(</span><span class="n">index</span><span class="p">[</span><span class="n">row_pos</span><span class="p">],</span><span class="n">col_pos</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_neg_flat</span><span class="p">,(</span><span class="n">index</span><span class="p">[</span><span class="n">row_neg</span><span class="p">],</span><span class="n">col_neg</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">pzblock</span>
			<span class="n">data_pos_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">pzblock</span>
			<span class="n">data_neg_tran</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_fliplr</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_all</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>

		<span class="n">v</span><span class="o">.</span><span class="n">sum_duplicates</span><span class="p">()</span>
		<span class="n">v</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>
		<span class="n">ops</span><span class="o">.</span><span class="n">py_shift</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">v</span>

<span class="k">def</span> <span class="nf">_get_proj_sparse</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">basis_in</span><span class="p">,</span><span class="n">basis_pcon</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">shape</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="o">**</span><span class="n">blocks</span><span class="p">):</span>

	<span class="n">a</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
	<span class="n">kblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kblock&quot;</span><span class="p">)</span>
	<span class="n">pblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pblock&quot;</span><span class="p">)</span>
	<span class="n">zblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zblock&quot;</span><span class="p">)</span>
	<span class="n">zAblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zAblock&quot;</span><span class="p">)</span>
	<span class="n">zBblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zBblock&quot;</span><span class="p">)</span>
	<span class="n">pzblock</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pzblock&quot;</span><span class="p">)</span>


	<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">kblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
		<span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">kblock</span><span class="o">*</span><span class="n">a</span><span class="o">/</span><span class="n">L</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">k</span> <span class="o">=</span> <span class="mf">0.0</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">L</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">basis_in</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
	<span class="n">sign</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">basis_in</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">_np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">basis_pcon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="k">def</span> <span class="nf">get_index</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">basis_in</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">def</span> <span class="nf">get_index</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">basis_pcon</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">basis_in</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>

	<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">L</span><span class="o">//</span><span class="n">a</span><span class="p">):</span>
		<span class="n">C</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">norms</span><span class="p">,</span><span class="n">dtype</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">)</span>
		<span class="n">data_pos</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
		<span class="n">data_neg</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>

		<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
		<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">ind_pos</span><span class="p">)</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_pos</span><span class="p">,(</span><span class="n">index</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">ind_neg</span><span class="p">)</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_neg</span><span class="p">,(</span><span class="n">index</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
		<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
		<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>


		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">zAblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_sublat_A</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">zAblock</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">zAblock</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">ind_pos</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_pos</span><span class="p">,(</span><span class="n">index</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">ind_neg</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_neg</span><span class="p">,(</span><span class="n">index</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">zAblock</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">zAblock</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_sublat_A</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">zBblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_sublat_B</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">zBblock</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">zBblock</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">ind_pos</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_pos</span><span class="p">,(</span><span class="n">index</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">ind_neg</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_neg</span><span class="p">,(</span><span class="n">index</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">zBblock</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">zBblock</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_sublat_B</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">zblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_all</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">zblock</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">zblock</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">ind_pos</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_pos</span><span class="p">,(</span><span class="n">index</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">ind_neg</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_neg</span><span class="p">,(</span><span class="n">index</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">zblock</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">zblock</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_all</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_fliplr</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">pblock</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">pblock</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">ind_pos</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_pos</span><span class="p">,(</span><span class="n">index</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">ind_neg</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_neg</span><span class="p">,(</span><span class="n">index</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">pblock</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">pblock</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_fliplr</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pzblock</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_fliplr</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_all</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">pzblock</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">pzblock</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">ind_pos</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_pos</span><span class="p">,(</span><span class="n">index</span><span class="p">,</span><span class="n">ind_pos</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">ind_neg</span><span class="p">)</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">_sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data_neg</span><span class="p">,(</span><span class="n">index</span><span class="p">,</span><span class="n">ind_neg</span><span class="p">)),</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">pzblock</span>
			<span class="n">data_pos</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">]</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">pzblock</span>
			<span class="n">data_neg</span> <span class="o">*=</span> <span class="n">sign</span><span class="p">[</span><span class="n">ind_neg</span><span class="p">]</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_fliplr</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>
			<span class="n">ops</span><span class="o">.</span><span class="n">py_flip_all</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>

		<span class="n">ops</span><span class="o">.</span><span class="n">py_shift</span><span class="p">(</span><span class="n">basis_in</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">pars</span><span class="p">,</span><span class="n">sign</span><span class="p">)</span>


	<span class="k">return</span> <span class="n">v</span>


</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">QuSpin 0.2.9 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Phillip Weinberg and Marin Bukov.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>