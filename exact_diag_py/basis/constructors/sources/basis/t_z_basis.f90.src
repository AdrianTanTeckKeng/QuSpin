subroutine checkstate_t_z(s,L,k,a,r,m)
implicit none
integer(kind=4), intent(in) :: s,L,k,a
integer(kind=1), intent(out) :: r,m
integer(kind=4) :: t,i,rr

t=s
r=-1
m=-1

do i=1,L/a
t=ishftc(t,a,L)
if ( t .lt. s ) then
return
else if ( t .eq. s) then 
if ( modulo(k,(L/(a*int(i)))) .ne. 0) then
return
end if
r=int(i,1)
exit
end if
end do

rr=int(r,4)
t = s
call flip_all(t,L)

do i=0,rr-1
if (t .lt. s) then
r = -1
return
else if(t .eq. s) then
m = int(i,1)
return
end if
t = ishftc(t,a,L)
end do

end subroutine





subroutine make_t_z_basis(L,mbasis,Ns_m,zblock,kblock,a,N,m)
implicit none
real(kind=8), parameter :: pi = 4.0d0*datan(1.0d0)
integer(kind=4), intent(in) :: L, kblock, zblock, Ns_m,a
integer(kind=4), intent(inout) ,dimension(Ns_m) :: mbasis
integer(kind=1), intent(out), dimension(Ns_m) :: N,m
integer(kind=4) :: i

do i=1,Ns_m
call checkstate_t_z(mbasis(i),L,kblock,a,N(i),m(i))
if(m(i) .ge. 0)then
if( zblock*dcos(2*kblock*m(i)*pi/L) .eq. -1.0d0) then
N(i) = 0
m(i) = 0
mbasis(i) = -1
end if
end if
if(N(i) .lt. 0) then
N(i)=0
mbasis(i)=-1
end if

end do

end subroutine





