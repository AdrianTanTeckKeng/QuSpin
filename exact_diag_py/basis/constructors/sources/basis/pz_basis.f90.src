subroutine CheckState_PZ(s,L,pz,r)
implicit none
integer(kind=4), intent(in) :: s,L,pz
integer(kind=1), intent(out) :: r
integer(kind=4) :: t
t=s
call flip_lr(t,L)
call flip_all(t,L)
if(t .eq. s) then
if(pz .ne. -1) then
r=4; return
else
r=-1; return
end if
else if(t .gt. s) then
r=2; return
else
r=-1; return
end if

end subroutine







!subroutine make_pz_basis(L,mbasis,Ns_m,pzblock,N)
!implicit none
!integer(kind=4), intent(in) :: L, pzblock, Ns_m
!integer(kind=4), intent(inout) ,dimension(Ns_m) :: mbasis
!integer(kind=1), intent(out), dimension(Ns_m) :: N
!integer(kind=4) :: i
!integer(kind=1) :: r


!do i=1,Ns_m
!call CheckState_PZ(mbasis(i),L,pzblock,r)
!N(i)=r
!if(r .lt. 0) then
!mbasis(i)=-1
!end if
!end do


!end subroutine






subroutine make_pz_basis(L,pzblock,N,basis,Ns,Ns_out)
implicit none
integer(kind=4), intent(in) :: L,pzblock,Ns
integer(kind=4), intent(inout), dimension(Ns) :: basis
integer(kind=1), intent(inout), dimension(Ns) :: N
integer(kind=4), intent(out) :: Ns_out
integer(kind=4) :: s
integer(kind=1) :: r


Ns_out = 0
do s=0,2**L - 1
call CheckState_pz(s,L,pzblock,r)
if(r.ge.0) then
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = r
end if
end do 

end subroutine











subroutine make_m_pz_basis(L,Nup,pzblock,N,basis,Ns,Ns_out)
implicit none
integer(kind=4), intent(in) :: L,Nup,pzblock,Ns
integer(kind=4), intent(inout) ,dimension(Ns) :: basis
integer(kind=1), intent(inout), dimension(Ns) :: N
integer(kind=4), intent(out) :: Ns_out
integer(kind=4), dimension(L) :: i_bits
Integer(kind=4) :: s,t
integer(kind=1) :: r

i_bits=0
do s=1,Nup
i_bits(s)=2**(s-1)
end do


Ns_out = 0
s=sum(i_bits)

if(Nup.eq.0) then

call CheckState_pz(s,L,pzblock,r)
if(r.ge.0) then
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = r
end if

return

end if


do while(.not.btest(s,L))

call CheckState_pz(s,L,pzblock,r)
if(r.ge.0) then
Ns_out = Ns_out + 1
basis(Ns_out) = s
N(Ns_out) = r
end if

t=ior(s,s-1)+1
s=ior(t,ishft(iand(t,-t)/iand(s,-s),-1)-1)
end do


end subroutine



