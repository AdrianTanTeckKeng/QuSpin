subroutine checkstate_t_p(s,L,k,a,r,m)
implicit none
integer(kind=4), intent(in) :: s,L,k,a
integer(kind=1), intent(out) :: r,m
integer(kind=4) :: t,i,rr

t=s
r=-1
m=-1

do i=1,L/a
t=ishftc(t,a,L)
if ( t .lt. s ) then
return
else if ( t .eq. s) then 
if ( modulo(k,(L/(a*int(i)))) .ne. 0) then
return
end if
r=int(i,1)
exit
end if
end do

rr=int(r,4)
t = s
call flip_lr(t,L)

do i=0,rr-1
if (t .lt. s) then
r = -1
return
else if(t .eq. s) then
m = int(i,1)
return
end if
t = ishftc(t,a,L)
end do

end subroutine





subroutine make_t_p_basis(L,mbasis,Ns_m,pblock,kblock,a,N,m)
implicit none
real(kind=8), parameter :: pi = 4.0d0*datan(1.0d0)
integer(kind=4), intent(in) :: L, kblock, pblock, Ns_m,a
integer(kind=4), intent(inout) ,dimension(Ns_m) :: mbasis
integer(kind=1), intent(out), dimension(Ns_m) :: N,m
integer(kind=4) :: i,b,f,sigma
integer(kind=1) :: n1,n2

if(modulo(kblock,L/2) .eq. 0) then
b = 1
f = 1
else
b = -1
f = 1
end if

do i=1,Ns_m

call checkstate_t_z(mbasis(i),L,kblock,a,n1,n2)
do sigma=b,f,2
N(i)=n1
m(i)=n2

if(m(i) .ge. 0)then
if( zblock*dcos(2*kblock*m(i)*pi/L) .eq. -1.0d0) then
N(i) = 0
m(i) = 0
mbasis(i) = -1
end if
if( (sigma .eq. -1) .and. ( zblock*dcos(2*kblock*m(i)*pi/L) .eq. 1.0d0)) then
N(i) = 0
m(i) = 0
mbasis(i) = -1
end if
end if

if(N(i) .lt. 0) then
N(i)=0
mbasis(i)=-1
end if


end do
end do

end subroutine





