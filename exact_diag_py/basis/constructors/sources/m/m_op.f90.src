
subroutine <name=s,d,c,z>_m_op(basis,Ns,opstr,indx,N_indx,col,ME,error)
implicit none
integer(kind=4), intent(in) :: Ns, N_indx
integer(kind=4), intent(in), dimension(N_indx) :: indx
character, intent(in), dimension(N_indx) :: opstr
integer(kind=4), intent(in), dimension(Ns) :: basis
integer(kind=4), intent(out), dimension(Ns) :: col
<real(kind=4),real(kind=8),complex(kind=4),complex(kind=8)>, intent(out), dimension(Ns) :: ME
integer(kind=4), intent(out) :: error
integer(kind=4), external :: FindZstate
integer(kind=4) :: i


call <name>_spinop(basis,Ns,opstr,indx,N_indx,ME,col,error)

if(error .ne. 0) then
return
end if

do i=1,Ns
col(i) = FindZstate(basis,Ns, col(i))
end do

end subroutine



function FindZstate(A,N,s)
implicit none
integer(kind=4) :: FindZstate
integer(kind=4), intent(in) :: N, s
integer(kind=4), intent(in), dimension(N) :: A
integer(kind=4) :: bmin,bmax,b

bmin=1;bmax=N
do while(bmin .le. bmax)
b=(bmin+bmax)/2
if(s < A(b)) then
bmax=b-1
else if(s > A(b)) then
bmin=b+1
else
FindZstate=b
return 
end if
end do
FindZstate=-1
end function
